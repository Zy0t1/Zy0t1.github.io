<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS of 王道 | Zy0t1's blog</title><meta name="author" content="Zy0t1"><meta name="copyright" content="Zy0t1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于25王道，后续可能会进行补充">
<meta property="og:type" content="article">
<meta property="og:title" content="OS of 王道">
<meta property="og:url" content="http://zy0t1.github.io/2024/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Zy0t1&#39;s blog">
<meta property="og:description" content="基于25王道，后续可能会进行补充">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp">
<meta property="article:published_time" content="2024-02-21T04:00:00.000Z">
<meta property="article:modified_time" content="2024-08-07T09:34:31.366Z">
<meta property="article:author" content="Zy0t1">
<meta property="article:tag" content="408">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp"><link rel="shortcut icon" href="/img/web.png"><link rel="canonical" href="http://zy0t1.github.io/2024/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS of 王道',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-07 17:34:31'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/web.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Zy0t1's blog"><span class="site-name">Zy0t1's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS of 王道</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-21T04:00:00.000Z" title="发表于 2024-02-21 12:00:00">2024-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-07T09:34:31.366Z" title="更新于 2024-08-07 17:34:31">2024-08-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%80%83%E7%A0%94/">考研</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS of 王道"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<h3 id="0x01-计算机系统概述"><a href="#0x01-计算机系统概述" class="headerlink" title="0x01.计算机系统概述"></a>0x01.计算机系统概述</h3><h4 id="1-操作系统基本概念"><a href="#1-操作系统基本概念" class="headerlink" title="1. 操作系统基本概念"></a>1. 操作系统基本概念</h4><p>什么是操作系统：首先操作系统是一种软件（系统软件），OS负责管理各种计算机硬件，是处在用户和硬件之间的中间层，为应用程序提供基础，OS控制并协调应用程序对硬件的使用与分配。</p>
<p>操作系统特征（前两个最基本）：</p>
<ul>
<li><p>并发：在一个时间段内有两个或以上的事件发生。并行则是同一时刻有两个及以上</p>
</li>
<li><p>共享：系统中的资源可以同时供多个并发执行的进程共同使用。主要包括下面两种</p>
<ul>
<li>互斥共享方式：例如打印机，只有当A访问完成后才能给B访问，这样的资源也叫做<strong>临界资源</strong></li>
<li>同时访问方式：同时指的是并发一样的时间段上“同时”</li>
</ul>
</li>
<li><p>虚拟：一个实际上东西，使用起来感觉有好多，即虚拟技术。</p>
</li>
<li><p>异步：一个事件基本不可能直接运行完，必定有停顿。换到多个时间上来说就是不清楚其他事件跑到哪里了</p>
</li>
</ul>
<p>操作系统功能（侧重于软件）：</p>
<ul>
<li><p>对于计算机系统资源的管理=处理机管理+存储器管理+文件管理+设备管理</p>
</li>
<li><p>为用户提供了接口=命令接口+程序接口（理解为API即可）</p>
<blockquote>
<p>命令接口=联机命令接口/交互式命令接口（cmd命令）+脱机命令接口/批处理命令接口（bat脚本）</p>
</blockquote>
</li>
<li><p>对计算资源的扩充。裸机+操作系统=扩充机器/虚拟机</p>
</li>
</ul>
<h4 id="2-操作系统发展历程"><a href="#2-操作系统发展历程" class="headerlink" title="2. 操作系统发展历程"></a>2. 操作系统发展历程</h4><ol>
<li>手工操作阶段：一张纸条处理完等待下一个</li>
<li>单道批处理系统：多张纸条放在一起，自动处理下一个</li>
<li>多道批处理系统：一次吞入好几个纸条，基于前面的并发的思想</li>
<li>分时操作系统：多个用户共享一台计算机，将并发的思想放置到用户上</li>
<li>实时操作系统：由于分时操作无法处理紧急任务而诞生，包括硬实时和软实时，前者对于特定操作必定会在某个时间内处理，后者则相对宽松</li>
<li>网络操作系统&amp;分布式操作系统：对于用户来说操作多台计算机就像一台一样，但后者则看起来更像一台（相互协同完成同一个任务）</li>
<li>个人计算机操作系统：阿巴阿巴……</li>
</ol>
<h4 id="3-操作系统运行环境"><a href="#3-操作系统运行环境" class="headerlink" title="3. 操作系统运行环境"></a>3. 操作系统运行环境</h4><ul>
<li>CPU的运行模式：用户态和内核态，后者供给操作系统使用，以便使用一些特权指令，例如中断、IO操作等</li>
<li>操作系统内核功能（这个更贴近于硬件）：<ul>
<li>时钟管理：并发重要东东，用于计算机衡量时间</li>
<li>中断机制：使得CPU在进行IO操作期间可以执行其他指令，其中只有一小部分属于内核</li>
<li>原语：即原子性操作，不可再分割且时间较短</li>
<li>系统控制的数据结构及处理：接上前面说的处理器管理、文件管理、存储器管理、设备管理等</li>
</ul>
</li>
</ul>
<p>中断与异常</p>
<ul>
<li>概念：用户程序通过中断/异常来进入到核心态，执行一些特权指令。</li>
<li>分类：一般将外部硬件设备发出的中断叫做<strong>外中断</strong>，程序引发的诸如“除0”、“溢出”等叫做<strong>内中断</strong>或异常。</li>
<li><p>细分：外部中断包括可屏蔽中断（INTR）与不可屏蔽中断（NMI）；内部异常包括故障（上面说到的溢出与除0）、自陷（程序自己设置的异常模块）、终止（出现了使CPU无法继续运行的硬件故障）</p>
</li>
<li><p>处理：处理器收到来自程序的中断请求信号后，打断当前进程，之后根据信号的值查找中断向量表，并跳到相应的中断异常处理程序去执行。若该处理程序能解决则返回到原先指令或者其下一条指令，否则终止该程序</p>
</li>
</ul>
<p>系统调用</p>
<ul>
<li>概念：即操作系统提供给开发者的功能函数，包括但不限于设备、文件、内存管理、进程的通信与控制。当然一般来说这些调用功能运行在核心态，有些是为了安全性包装为用户态的</li>
<li>处理：<ol>
<li>用户程序将所需参数压栈，在调用指令后，执行陷入操作用于将CPU从用户态转为核心态，由硬件与操作系统将进程信息、寄存器等压栈，保护现场</li>
<li>分析调用类型，根据系统调用号找到对应处理子程序的入口地址</li>
<li>子程序执行完成后恢复现场，源程序继续向下执行（此时CPU又处于用户态）</li>
</ol>
</li>
</ul>
<h4 id="4-操作系统结构"><a href="#4-操作系统结构" class="headerlink" title="4. 操作系统结构"></a>4. 操作系统结构</h4><p>分层化与模块化</p>
<ul>
<li><p>分层法：也就是常说的ring环，从内向外依次增高，外层依赖于内层，【win】</p>
</li>
<li><p>模块化：一个模块对应一个功能，例如将进程管理做成单独一个模块，其下面根据功能还可以细分为子模块，【linux】</p>
<blockquote>
<p>高内聚、低耦合：指的是模块内部关联性高，模块之间的相关连程度低</p>
</blockquote>
</li>
</ul>
<p>宏内核与微内核</p>
<ul>
<li><p>主要区别：前者将系统的主要功能都作为一个整体运行在核心态，而后者则是将最基本的功能保留在内核中，剩下的移动到用户态。目前市面上的主要是这两种加在一起的混合内核</p>
</li>
<li><p>微内核：将操作系统分为微内核和服务器。</p>
<ul>
<li>微内核包括：与硬件处理相关的部分、最基本的功能（如进程管理、低级存储器管理、终端陷入处理）、客户和服务器之间的通信。</li>
<li>服务器：包括但不限于进程服务器、IO设备管理器、客户进程等。这样任何一个服务崩溃后不会影响其他功能</li>
</ul>
</li>
</ul>
<h4 id="5-操作系统引导"><a href="#5-操作系统引导" class="headerlink" title="5. 操作系统引导"></a>5. 操作系统引导</h4><ol>
<li>按下开关—》激活CPU—》读取ROM中的Boot程序—》指令寄存器放入BIOS的地址</li>
<li>BIOS程序开始在内存起始位置构建中断向量表—》之后进行通电自检查硬件</li>
<li>自检完成—》BIOS读取Boot Sequence—》控制权交给目标系统存储设备</li>
<li>加载主引导记录MBR—》获得操作系统位置—》并获取硬盘分区表</li>
<li>加载操作系统所在分区的引导记录PBR—》寻找并激活分区分目录下用于引导操作系统的程序—》OS，启动</li>
</ol>
<h4 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6. 虚拟机"></a>6. 虚拟机</h4><p>利用虚拟化技术，使得一台物理机在体验上就像有多台物理机一样，特别注意不是一个机器上运行多个操作系统，而是一套硬件就像有多套硬件。</p>
<ul>
<li>第一类虚拟机管理<strong>系统</strong>：可以理解此类软件就是一个操作系统，在下面直接与硬件打交道，上面一层就是各类操作系统，例如VM ESXI。</li>
<li>第二类虚拟机管理<strong>程序</strong>：理解为一个程序，运行于宿主操作系统之上，常说的虚拟机就是这个，例如VM ware</li>
</ul>
<blockquote>
<p>关于虚拟化、容器化和模拟可以在“数据库理论”一文中查看</p>
</blockquote>
<h3 id="0x02-进程管理"><a href="#0x02-进程管理" class="headerlink" title="0x02.进程管理"></a>0x02.进程管理</h3><h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h4><p>源代码文件编译之后成为程序，将程序加载到内存中执行就可以变为动态的进程，一个进程下面可以有多个同时进行的事件，也就是线程。</p>
<blockquote>
<p>进程是系统进行资源分配和调度的一个独立单位，线程是一个基本的CPU执行单元（也就是常说的x核x线程）</p>
</blockquote>
<p>进程基本特征：动态、并发、独立、异步</p>
<p>进程实体=程序段+相关数据段+进程控制块（PCB）</p>
<ul>
<li>PCB：由操作系统创建，创建后常驻内存，进程结束时删除。其中包括但不限于：进程标识符PID、用户标识符UID、进程状态优先级、内存各段相关地址、CPU上下文（即寄存器中的值）</li>
<li>PCB块管理有链式和索引表式，前者将同一个状态的进程PCB连接在一起，后者则是建立索引表，不同状态有不同的索引表</li>
</ul>
<p>进程的状态与转换</p>
<ul>
<li><p>运行态：正在使用CPU</p>
</li>
<li><p>就绪态：我准备好了，但是CPU还被占着</p>
</li>
<li><p>阻塞态：我没准备好，比如某个资源不可用或者在等待I/O</p>
</li>
<li><p>创建态：正在由OS第一次初始化PCB、内存空间等</p>
</li>
<li><p>终止态：进程结束后先设置为终止态，之后再由OS对资源回收</p>
<blockquote>
<p>另外还有七态模型多了挂载就绪和挂载阻塞，其实就是将这两种状态的进程内容先暂时放置在外存，而非内存中</p>
</blockquote>
</li>
</ul>
<p>进程的通信-IPC（浏览器请求打开xx网盘）</p>
<ul>
<li><p>共享存储：两个进程之间可以共享一块内存空间，通过这块两个进程都可操作的空间实现通信，需要借助同步互斥（PV操作）</p>
</li>
<li><p>消息传递：操作系统提供的消息机制，在安卓里面最为明显。进程间的数据交换以格式化的信息为单位，两个进程以系统提供的发送和接受两个原语操作进行交换</p>
<blockquote>
<p>还可以根据中间是否有信箱（实体）分为直接通信和间接通信</p>
</blockquote>
</li>
<li><p>管道通信：在Linux中的管道符就是其中之一，叫做匿名管道，只能实现父子进程之间的通信，而且是单向流动的。与此相对的是有名管道（一种特殊文件），因为有名所以可以实现不同进程之间的通信。需要注意管道依赖于生产消费者模型，有生产必须有消费，且互斥</p>
<blockquote>
<p>和此类似的叫做消息队列，A进程将自己需要发送的消息发送（拷贝）到系统中的队列（内核态空间）就可以走了，之后由B进程随来随查</p>
</blockquote>
</li>
<li><p>Socket：等于IP+Port，在网络的基础上定位另一个进程，通过包装的API实现不同进程之间的通信，当然也可以本机上两个进程如此通信（localhost）</p>
<blockquote>
<p>要注意和消息传递并不一样，Socket底层实现上和消息传递并不相同，后者依赖于特定的数据结构</p>
</blockquote>
</li>
<li><p>信号：和前几个不同，信号量通常用于传递少量信息，例如一个1111，可能每一位代表一个意思。Ctrl+C终止信息就是此类</p>
<blockquote>
<p>区别一下信号量，信号量通常是代码层面的变量，经常与PV操作结合实现互斥资源的访问操作</p>
</blockquote>
</li>
</ul>
<p>线程基本</p>
<ul>
<li>线程调度要远低于进程，因为不需要进行上下文切换</li>
<li>一个进程中有多个线程，每个线程可以有自己独立的空间，其中各个线程也有共享的空间</li>
<li>线程对外不可见，仅对内，并且并发执行（多核CPU可以并行）</li>
</ul>
<p>线程的组织与实现</p>
<ul>
<li><p>线程控制块TCB，包括但不限于：线程标识符、寄存器、线程运行状态、优先级、堆栈指针等。根据下面的用户内核分为内核线程控制块TCB和用户空间的UTCB</p>
</li>
<li><p>线程包括用户级线程ULT、内核级线程KLT。前者是开发者可见（Thread），一个线程被阻塞同一进程下都受影响；后者是系统可见，互相之间不影响</p>
<blockquote>
<p>线程池：预先设置好各个线程，需要的时候直接拿来用即可。相当于提前new过，只要给信息就行</p>
</blockquote>
</li>
<li><p>多线程模型：多对多、一对一、多对一。将用户线程与内核级线程对应起来</p>
</li>
</ul>
<h4 id="2-CPU调度"><a href="#2-CPU调度" class="headerlink" title="2. CPU调度"></a>2. CPU调度</h4><p>调度概念：前面我们所说的并发，一个时间段内运行多个事件，那么决定下一个时刻是哪个事件在CPU上执行就是调度，当然具体还有细节</p>
<ul>
<li>高级调度（作业调度）：将外存上后备队列中的作业中挑一个，并给他们分配内存等资源——次数少</li>
<li>中级调度（内存调度）：将暂时不能运行的进程放置到外存上，也就是上面说的挂载——中</li>
<li>低级调度（进程调度）：按照算法从就绪队列中挑一个进程放在CPU上运行——多</li>
</ul>
<p>调度实现</p>
<ul>
<li>调度程序=排队器+分派器+上下文切换器。排队器用于插入删除队列，分派器用于分配CPU，切换器用于保存移出PCB中存储的进程上下文</li>
<li>调度条件：新进程创建、结束、I/O阻塞发生、I/O完成使原先阻塞进程就绪</li>
<li>不能实行调度：处理中断时、原子操作</li>
<li>调度方式类型：非抢占与抢占式，也就是A正在执行时B到来，是选择让A继续还是B优先</li>
<li>闲逛进程：系统中没有就绪进程，就会调度这个PID=0的进程运行，不会被阻塞，仅仅是让CPU处理nop</li>
</ul>
<p>调度算法（）</p>
<ul>
<li><p>FCFS—先来先服务算法：谁先到谁就先执行，众生平等；非抢占式</p>
</li>
<li><p>SJF—短作业优先：如果本次运行完成之后，选择就绪队列中估计事情最少的进程（需要时间短）执行；默认非抢占式</p>
<blockquote>
<p>如果一直有短进程进来，比如运行时间&lt;=5，那么很早进来的$T_{A}=6$不就运行不了了，这叫做饥饿。因此单纯这个算法是非常不好，需要与后面的优先级等配合，使得等待时间越长的优先级更高</p>
</blockquote>
</li>
<li><p>高响应比优先调度算法：选择具有更高响应比$R_{p}=\frac{等待时间+所需时间}{所需时间}$的运行，也是对上面算法的饥饿的解决</p>
</li>
<li><p>优先级调度算法：比较广泛的说辞，优先级可以自己定，比如系统进程&gt;用户进程、I/O密集型&gt;计算密集型等、交互式&gt;非交互等。此外优先级还是可以在运行时改变的，也就因此衍生出了静态/动态优先级。可以是抢占也可以是非抢占</p>
</li>
<li><p>RR—时间片轮转调度算法：在FCFS基础上，将时间划分出一个单位，如果在该单位时间内进程运行完则提前调度，否则在单位时间结束后切换进程，将本进程仍队尾。</p>
</li>
<li><p>多级队列调度算法：每个队列可以有自己的调度算法，比如在Q1中是FCFS，Q2中是SJF等。队列之间也可以有优先级，比如设置系统队列和用户队列</p>
</li>
<li><p>多级反馈队列调度算法：在上面的队列基础上，队列之间可以有联系，即Q1出来之后可以到Q2再运行</p>
</li>
</ul>
<h4 id="3-同步与互斥"><a href="#3-同步与互斥" class="headerlink" title="3. 同步与互斥"></a>3. 同步与互斥</h4><ul>
<li>临界资源：在一个时刻只能有一个人占用，比如坑位</li>
<li>同步：直接制约关系，对于处理一件事的不同进程之间需要协调好<strong>顺序</strong></li>
<li>互斥：间接制约关系，A在处理时B不能干扰需要<strong>等待</strong>A完毕</li>
<li>准则：空闲让进、忙则等待、有限等待、让权等待</li>
</ul>
<p>临界区互斥软件实现：</p>
<ul>
<li><p>单标志：flag=0时，进程0可以进入到临界区，从中出来之后设置flag=1。但一旦0不进，1就进不去</p>
</li>
<li><p>双标先检查：当flag[0]=true表示0想进入临界区，此时1不能进，0出来之后将flag[0]=false。有可能flag[0：1]都是false，这时01就都进去了</p>
</li>
<li><p>双标后检查：类似上，但先设置flag[0]=true，之后再检查flag[1]。有可能flag[0:1]都是true，这时01都在等对方flag解锁，引起饥饿</p>
</li>
<li><p>Peterson算法：前面1、3算法合体，先设置flag[0]=true，之后设置flagg=0，再检查(flag[1]&amp;&amp;flagg==1)。没有啥大问题</p>
</li>
<li><p>互斥锁：进入临界区调用acquire来获得锁，退出临界区时调用release释放锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!available)&#123;&#125;;</span><br><span class="line">	available = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">	available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量：一个变量S记录目前还剩资源数量，如果够的话就可以分配，否则等待<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149161327">操作系统之信号量机制 - 知乎 (zhihu.com)</a></p>
</li>
<li><p>管程：简化理解一下，管程是一个类，其中封装的关于互斥锁、共享变量等信息。也就是将一个临界资源放到了一个只有一把钥匙的房间里。<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_63006478/article/details/130796059">一文搞懂操作系统中的管程-CSDN博客</a></p>
</li>
</ul>
<p>临界区互斥硬件实现：</p>
<ul>
<li>中断屏蔽方法：关闭中断，也就是无论如何当前进程A在临界区都不会被打断（即使除0）</li>
<li>硬件指令—TestAndSet：TS指令原子操作，用于读出旧值，赋true。</li>
<li>硬件指令—Swap：原子交换两个变量内容</li>
</ul>
<blockquote>
<p>经典同步问题：生产-消费者问题；读者-写者问题；吸烟问题；哲学家就餐问题；理发师问题</p>
</blockquote>
<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h4><p>死锁的出现：现在有两个进程，A进程需要B进程目前占据的资源a，但是由于B缺少A现在占据资源b，因此不放a出来，这就出现了A等B，B等A的现象，就是死锁。其本质就是对资源的竞争。</p>
<blockquote>
<p>和饥饿区别一下，饥饿是Alice一直在等，而Bob其他人都正常，死锁则是大家都活不了</p>
</blockquote>
<p>其产生原因：对不可剥夺资源的争抢、请求释放资源的顺序不当、信号量使用不当等</p>
<p>死锁产生必要条件：</p>
<ul>
<li>互斥条件：本资源一个时刻下只能有一个主</li>
<li>不可剥夺：Alice没用完就不能给Bob</li>
<li>请求并保持条件：Bob需要资源a，但是不能丢掉另一个已有的需要的资源b</li>
<li>循环等待条件：A等B，B等C，C等A，需要成一个环</li>
</ul>
<p>死锁的处理方式：</p>
<ul>
<li><p>死锁预防：设置限制条件，使得上面的4个条件至少一个不成立</p>
<ul>
<li>破互斥：将竞争资源设置为可共享</li>
<li>破不可剥夺：把Alice正在用的给释放掉</li>
<li>破请求并保持：Bob在运行前需要一次性全部请求完，否则不能动。或者首先获取运行初期必须的，在运行过程中释放不用的东西，全释放完后才能请求新的</li>
<li>破坏循环等待：比如规定，PID小的拥有资源的优先权</li>
</ul>
</li>
<li><p>避免死锁：防止进入死锁状态</p>
<ul>
<li><p>系统安全状态：系统分配资源之前，先检查这次分配是否会进入到不安全状态。安全状态是系统按照某种顺序为各进程分配其所需，使得每个进程最终都能顺利完成，这样的顺序叫做安全序列。</p>
<blockquote>
<p>不安全状态不一定死锁，可能本来就不够；死锁一定处于不安全状态</p>
</blockquote>
</li>
<li><p>银行家算法：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/11929508.html">操作系统——银行家算法（Banker’s Algorithm） - 王陸 - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
</li>
<li><p>死锁检测与解除：时刻检测当前是否死锁，如果是就想办法解决</p>
<ul>
<li>死锁检测：资源分配图（也就是画图理清关系，具体实现可以对应到数据结构中的图）</li>
<li>解除：资源剥夺——挂起某些死锁进程并瓜分资源；强制撤销部分/全部死锁进程；回退到足以回避死锁的地步</li>
</ul>
</li>
</ul>
<h3 id="0x03-内存管理"><a href="#0x03-内存管理" class="headerlink" title="0x03.内存管理"></a>0x03.内存管理</h3><p>内存管理的主要功能：内存空间的分配与回收、地址转换、内存空间的扩充、内存共享、存储保护</p>
<ul>
<li><p>逻辑地址与物理地址：在32位系统上，逻辑地址/虚拟地址空间为0~2^32^-1，开发者看到的就是虚拟地址，就比如在0x100000000处，但是实际上可能内存条都没有这么长，于是乎它的物理地址可能就不在这个地方，那为什么比我内存条长嘞，这与后面虚拟内存相关</p>
</li>
<li><p>内存保护：设置进程的上下限地址寄存器；基地址寄存器+限长寄存器</p>
</li>
<li><p>内存共享：仅只读区域可以共享，不仅仅数据，也可能是动态链接库代码</p>
<blockquote>
<p>COW：copy on write写时复制技术，对于的确需要修改的自己会单独复制一份出来，原来的代码数据还是不变</p>
</blockquote>
</li>
</ul>
<h4 id="1-内存分配与回收"><a href="#1-内存分配与回收" class="headerlink" title="1. 内存分配与回收"></a>1. 内存分配与回收</h4><p><strong>连续分配方式</strong>：一个进程拥有一块连续的虚拟内存空间</p>
<ul>
<li>单一连续分配：内存分为系统区和用户区，用户区中仅存在一个进程</li>
<li>固定分区分配：将用户区分成若干个固定大小的空间，有一个分区表记录起始地址、大小及状态。注意程序所需空间可能小于所分配的区块大小，如此一来就产生了内部碎片</li>
<li>动态分区分配：不存在分区一说，需要多大就给多大，不够的话就选择内存中的一个进程替换。会产生外部碎片，即存在于内存中但不被分配给进程。通过紧凑操作来移动进程空间，从而合并这些外部碎片，方便其他程序<ul>
<li>首次适应算法：每次都从低地址到高地址，找到第一个满足条件的空间；缺点是后面的空间利用率太低</li>
<li>循环首次适应算法：从上一次分配空间开始，继续向下搜索，找到第一个满足条件的空间；缺点是几乎没有较大的空闲区域</li>
<li>最佳适应算法：空闲分区按照容量递增，找到最小的满足条件的空间；缺点是会不断产生外部碎片</li>
<li>最坏适应算法：空闲空间按照容量递减，找到最大的空间后切出部分空间给进程，剩下的再排队；缺点是后期大空间少</li>
<li>快速适应算法：在索引表中找到最小的满足条件的空间链表，之后拿出链表中的一块空间；缺点是算法杂开销大</li>
<li>伙伴系统：所有分区都是2^k^大小，为进程查找2^i-1^&lt;k&lt;=2^i^的空间，有则分配，无则在更高一级的链中查找，之后在这个链中将空间切半，一个插回链表合适位置，一个给进程用</li>
<li>哈希算法：分配时计算进程所需空间大小的hash函数，之后查找以空闲空间大小为关键字的哈希表，得到对应位置</li>
</ul>
</li>
</ul>
<p><strong>页式存储管理</strong></p>
<ul>
<li><p>页：将内存分割成若干固定大小的分区（一般都是4KB）叫做页框/页帧/物理块，进程的逻辑空间也同理分成此类若干区域叫做页/页面。逻辑空间页面编号—页号，物理空间编号—页框号/物理块号</p>
</li>
<li><p>页表：为了将逻辑空间与物理空间编号一一对应，于是就有了页表，每个进程都有自己独特的页表，注意页号是不需要存储空间的，ex：page_table[0]=2。而这个页表的位置与长度一般有专门的页表寄存器存储，当进程运行时，系统会将该进程PCB中对应的相关内容赋值到页表寄存器中，这个过程一般由内存管理单元MMU执行</p>
</li>
<li><p>快表：从上面我们知道，现在需要先查找页表后才能知道目标空间在哪里，为了加快速率，就有了快表TLB。地址转换时会先在一个高速缓冲存储器查找该表（仅部分项），没有的话再去查找内存中的页表，之后更新快表（时间局部性）</p>
<blockquote>
<p>注意快表中的页号显然不具有连续性，因此需要额外空间存储&lt;页号，块号&gt;</p>
</blockquote>
</li>
<li><p>两级页表：页表项太多了，需要占据不少空间，因此有了页目录。页目录中存储各个页表的起始位置。页目录的位置存放在CR3寄存器中<a target="_blank" rel="noopener" href="https://blog.csdn.net/SweeNeil/article/details/106171361">X86_64 CR3控制寄存器详解_cr3 process context identifier-CSDN博客</a></p>
</li>
</ul>
<p>段式存储管理</p>
<ul>
<li><p>段：将用户的逻辑地址分为大小不等的段，比如代码段、数据段、堆栈段等，段内连续段间可以不连续。</p>
<blockquote>
<p>注意这里的段和PE/ELF文件中的段不一样，这里的是在内存中的段。比如进程分了一些内存空间，其中某些地方是数据段，那么对应PE/ELF文件中的相关数据就要放置在这些地方</p>
</blockquote>
</li>
<li><p>段表：段号:&lt;段长，本段在主存的地址&gt;。段表起始地址和长度存放在段表寄存器中</p>
</li>
</ul>
<p>段页式存储管理：顾名思义前两种的结合，进程的逻辑空间首先被分成段，每个段有自己的段号，之后根据段号到页表中查询&lt;页表长度，页表起始地址&gt;，一个段表寄存器存储段表位置与长度，每个进程都有一个段表，每个段都有一个页表，</p>
<h4 id="2-虚拟内存管理"><a href="#2-虚拟内存管理" class="headerlink" title="2. 虚拟内存管理"></a>2. 虚拟内存管理</h4><p>为什么要虚拟内存：假如现在有个2GB的内存条，可能塞个win11就满了，这样其他程序就无法运行了，所以虚拟内存的任务就是解决内存不充足的问题。</p>
<p>什么是虚拟内存：虚拟内存是建立了内存-外存的存储器结构，利用时间/空间局部性原理从而实现高速缓存。之所以叫做虚拟是因为这个东西不是硬件，而是软件层面的实现。</p>
<p>虚拟内存执行过程：其基于上述局部性原理，在进程装入时仅装入部分需要用到的内容，而非所有，当需要的时候再从内存中腾出空间将还在外存中需要的东西放置到内存去，这个过程叫请求调页。如果内存空间不足，则需要将内存中某几页进行替换，这叫做页面置换。</p>
<blockquote>
<p>并非整个外存都属于虚拟内存，其中用于上述功能的外存区域叫做交换区。win下：高级系统设置—高级—性能设置中更改；Linux下的<code>swapon</code>用于开启虚拟内存。内存下的集合叫做驻留集</p>
</blockquote>
<p>虚拟内存的实现：请求分页/分段/段页式存储管理。下面我们主要讲请求分页式存储管理</p>
<p>请求分页式存储管理：</p>
<ul>
<li><p>在页式存储管理上增加了请求调页和页面调换的功能</p>
</li>
<li><p>需要在页表中添加：<em>状态位</em>来查看本页是否在内存，<em>访问字段</em>记录在一段时间内的访问次数，<em>修改位</em>标记在加入内存后是否有改动，<em>外存地址</em></p>
</li>
<li><p>缺页中断：当所需访问页面不在内存中时引起，有OS的缺页中断处理程序处理，并将原进程阻塞，之后执行请求调页或是页面替换。</p>
<blockquote>
<p>在页面替换时，如果被替换下来的页修改过，则需要将修改同步到外存</p>
</blockquote>
</li>
</ul>
<p>内存分配策略</p>
<ul>
<li><p>固定分配局部置换：每个进程固定N个物理块，若发生缺页则仅在本进程分配的块中选择置换</p>
<blockquote>
<p>固定分配时可以有如下方式设置N的大小：平均分配、按进程大小成比例分配、优先权分配</p>
</blockquote>
</li>
<li><p>可变分配全局置换：先分配M个物理块，进程运行期间可以看情况适当增加或减少，发生缺页则可以从其他空闲物理块中调入</p>
</li>
<li><p>可变分配局部置换：先分配M个块（运行时可增减块数），发生缺页则只能从M个中换出</p>
</li>
</ul>
<p>调页面</p>
<ul>
<li>何时调入页面：预调页策略、请求调页策略</li>
<li>何处调页：可能改变的放在交换区空间、不会改的放在文件区、与进程有关的放在文件区，被换出的放在交换区</li>
<li>如何调：所访问页面不存在——》缺页中断——》转入缺页中断处理程序——》查找页表得到物理块——》内存未满则调入内存并修改页表——内存满则选择置换算法换出——》若待换出被改则需写回磁盘，之后再调换并修改页表</li>
</ul>
<p>局部页面置换算法</p>
<ul>
<li><p>最佳置换算法OPT：选择以后最长时间内都不用的替换。仅适用于做题，因为无法预知</p>
</li>
<li><p>先进先出页面置换算法FIFO：淘汰最早进入内存的页面，基于队列实现。会有Belady异常</p>
<blockquote>
<p>Belady异常：当分配的物理块增多时，缺页次数增多</p>
</blockquote>
</li>
<li><p>最近最久未使用置换算法LRU：向前看最长时间没有被使用的进行替换，性能较好。基于堆栈实现，需要硬件加持</p>
</li>
<li><p>最不常用算法LFU：每个页面设一个计数器，调用时+1，替换时选择内存中计数器值最小的替换</p>
</li>
<li><p>时钟置换算法CLOCK/最近未使用算法NUR：每个页面一个访问位A=1，所有页面形成一个环。有空时则直接加入，没空时则向后检查访问位，A=1则置A=0，A=0则替换</p>
</li>
<li><p>改进的CLOCK/二次机会法：在CLOCK基础上增加了修改位M，{A=1,M=1} &gt; {A=1, M=0} &gt; {A=0,M=1} &gt; {A=0,M=0}。</p>
<ul>
<li>第一次扫描一圈若有{A=0,M=0}则替换，并不改变A</li>
<li>第二轮找{A=0,M=1}并将访问过的A置0</li>
<li>第三轮则将所有A置0重复第一轮/第二轮</li>
</ul>
</li>
</ul>
<p>全局页面置换<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/649722046">工作集算法（动态页面替换算法，不同于FIFO、LRU、MRU和LFU算法—静态） - 知乎 (zhihu.com)</a></p>
<ul>
<li>抖动：也叫颠簸，指的是刚刚换出去的页面又要马上换入内存，刚换入的页面又要马上换出内存。其根本原因是分配给每个进程的物理块数太少</li>
<li>工作集：某段时间内进程要访问的页面的集合，其反应了接下来一段时间内有可能访问的页面的集合，因此驻留集不能小于工作集</li>
</ul>
<h3 id="0x04-文件管理"><a href="#0x04-文件管理" class="headerlink" title="0x04.文件管理"></a>0x04.文件管理</h3><p>文件系统中包含目录是用于实现文件的管理，目录则是对文件的索引，目录也可以是一个文件</p>
<h4 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h4><ul>
<li><p>属性/元数据：并非文件内容，而是由OS创建的信息，例如文件名称、所属者、创建时间等</p>
</li>
<li><p>文件控制块FCB：存放该文件的相关信息，并非文件内容。主要包含文件名、存取控制信息等元数据</p>
<blockquote>
<p>通常我们都是用文件名来找到对应文件，而在UNIX中，根据文件名找到对应的索引节点（其中存放其他元数据）编号</p>
</blockquote>
</li>
<li><p>文件的操作：创建（分配空间并创建目录项）、删除（查目录项后删除空间）、读写（目录项中有对应指针）、打开、关闭</p>
<ul>
<li>打开&amp;关闭：系统在内存中有一个打开目录表，将对应文件目录项放入后返回文件描述符给程序，方便后续操作。系统和进程都有上述表，前者存放的是与进程无关的信息，后者存放诸如读写指针、访问权限等信息。如果打开多次则会在打开计数器中++，关闭时会—，并删除进程中的目录表，为0时从系统表中删除</li>
</ul>
</li>
<li><p>文件保护：</p>
<ul>
<li>一般访问权限：可读、可写、可执行、添加、删除、列出信息</li>
<li>访问控制：通过访问控制列表ACL来记录用户等对文件或目录的上述权限有哪些</li>
<li>口令密码：防止他人存取</li>
</ul>
</li>
<li><p>文件的逻辑结构：即数据在逻辑上是如何组织起来的。首先可以分为流式文件和记录式文件/有结构文件，前者仅以读写指针来指出访问对象。后者按照记录的组织形式又可以分为下面几种</p>
<ul>
<li>顺序文件：文件中的记录按照顺序排列，记录可以是变长或者定长</li>
<li>索引文件：建立一个索引表，其中包含&lt;索引号，记录长度，记录的起始指针&gt;</li>
<li>索引顺序文件：顺序文件中的所有记录分为若干个组，之后建立一张索引表，在索引表中有每组&lt;起始记录键值，对应指针&gt;</li>
<li>直接文件/散列文件：散列函数转换的键值直接决定记录的物理地址</li>
</ul>
<blockquote>
<p>这个概念相对抽象，并非文件系统中的组织方式，而是用户可以自己操作的</p>
</blockquote>
</li>
<li><p>文件的物理结构：在磁盘中存储的东西，用户看不见</p>
<ul>
<li>连续分配：文件在磁盘上占据连续的一组块</li>
<li>链接分配：目录中有第一块的指针，第一块内容中存储着第二块的指针（隐式链接）；对于显示链接则是将上述指针都放在一个地方</li>
<li>索引分配：拿出一个块存集中存放该文件占据的各个块，也可以在此基础上实现多级索引。混合索引则是某些块为直接块用于直接指向数据，剩下的采用一级、多级索引分配</li>
</ul>
</li>
</ul>
<h4 id="2-目录"><a href="#2-目录" class="headerlink" title="2. 目录"></a>2. 目录</h4><ul>
<li>目录：FCB的有序集合</li>
<li>目录结构<ul>
<li>单级目录结构：一个系统一张目录表，每个文件只占一个目录项</li>
<li>两级目录结构：主文件目录和用户文件目录两级，主文件目录指出用户A对应哪个用户文件目录，之后按照单级目录</li>
<li>树形目录结构：不止两级，按照树形式，多叉多层，必定有个根目录</li>
<li>无环图目录结构：在树的基础上可以实现叶子间的联系，但不形成环，类似于快捷方式</li>
</ul>
</li>
<li>目录的操作：搜索、删除/创建文件、创建删除目录、移动、显示、修改目录</li>
<li>目录的实现：线性列表&lt;文件名，数据块指针&gt;、哈希表</li>
<li>基于无环图目录结构实现文件共享（下面以Linux下实现为准）<ul>
<li>硬链接：两个文件目录下对应一个inode节点，其中的计数器++，inode对应真正的文件</li>
<li>软链接：在本目录下指向一个inode，其指向一个文件，这个文件内容是链接文件的地址，因此删除这个链接不会删除目标文件</li>
</ul>
</li>
</ul>
<h4 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3. 文件系统"></a>3. 文件系统</h4><ul>
<li><p>啥是文件系统：如何在磁盘上布局文件，如何提供操作，其实现的算法数据结构怎样</p>
</li>
<li><p>文件系统结构：设备——》I/O控制——》基本文件系统——》文件组织模块——》逻辑文件系统</p>
<ul>
<li>I/O控制层：用于在内存和磁盘之间传输信息</li>
<li>基本文件系统：向设备驱动发送命令，并管理内存缓冲区</li>
<li>文件组织模块：组织文件及其逻辑块和物理块</li>
<li>逻辑文件系统：管理文件系统的元数据信息</li>
</ul>
</li>
<li><p>外存空闲空间管理：空闲表法（单独建个表记录空白）、空闲链表法（空闲区拉成一条链）、位视图法（按位表示相应块是否空白-0=空）、成组链接法（空闲表的其中部分直接指向空白块，其中一个指向另一个此类空闲表）</p>
</li>
<li><p>虚拟文件系统：一个分区可以有一种文件系统，那么os内核如何统一操作不同的文件系统嘞，就在其中加入了VFS（虚拟文件系统），来消除这种差异，使得OS可以向开发者提供统一的调用函数</p>
<blockquote>
<p>VFS在Linux中实现很清晰，其中更是有四大对象【超级块-文件系统元数据、目录-记录文件、文件-具体文件、索引节点-inode】<a target="_blank" rel="noopener" href="https://stemha.github.io/2020/08/12/Linux-VFS中的数据结构/">Linux-VFS中的数据结构 - STEMHA’s Blog</a></p>
</blockquote>
</li>
</ul>
<h3 id="0x05-输入-输出管理"><a href="#0x05-输入-输出管理" class="headerlink" title="0x05.输入/输出管理"></a>0x05.输入/输出管理</h3><p>I/O设备是指可以将数据输入计算机的外部设备，或者可以接受计算机输出数据的外部设备</p>
<h4 id="1-I-O管理基本"><a href="#1-I-O管理基本" class="headerlink" title="1. I/O管理基本"></a>1. I/O管理基本</h4><p>I/O设备的分类</p>
<ul>
<li>按照信息交换单位分类：块设备（磁盘）、字符设备（打印机）</li>
<li>按照传输速率分类：低速（键盘鼠标）、中速（打印机）、高速（磁盘内存）</li>
<li>使用特性分类：存储设备、输入输出设备</li>
<li>按照共享属性分类：独占设备、共享、虚拟设备（借助SPOOLing可以将独占设备改为共享设备）</li>
</ul>
<p>I/O接口：又叫做设备控制器，是CPU与设备打交道的中间桥梁，一个设备控制器可以连接多个设备。其中的寄存器又叫做I/O端口，通过编址后能够直接被CPU访问的寄存器，主要有数据、状态、控制寄存器。编址方式有独立编址（每个端口一个I/O编号，可以和内存地址重叠）、统一编址（主存地址一部分划给I/O）</p>
<p>I/O接口按照数据传送方式分为并行接口和串行接口。具有阻塞和非阻塞两种模式。按照主机的访问I/O设备的控制方式有以下几种：</p>
<ul>
<li><p>程序直接控制方式/轮询：CPU向设备控制器发送读命令，之后循环检查其状态</p>
</li>
<li><p>中断驱动方式：I/O设备主动发送中断信号来让CPU读取</p>
</li>
<li><p>DMA接口：DMA（直接存储器存取）作为一种硬件，能过够避开CPU，直接与内存打交道从而实现I/O与内存直接交互。当传送一个或多个数据块时需要CPU干预</p>
<blockquote>
<p>为实现上述“代理人”的效果，至少需要DMA中有命令状态寄存器CR（接收CPU信息）、内存地址寄存器MAR（存放映射/目标地址）、数据寄存器DR（暂存数据）、数据计数器DC（传输字节数）</p>
</blockquote>
</li>
<li><p>通道控制方式：设置通道后，根据CPU的I/O指令及相关信息，执行通道程序完成规定I/O任务，之后再以中断方式提醒CPU处理。软件实现还是处于内存里面，一个通道就可以处理多个I/O</p>
</li>
</ul>
<p>I/O软件层次结构</p>
<ul>
<li>用户层软件：例如系统的open()和read()等接口</li>
<li>设备独立性软件：将不同的设备操作接口相统一</li>
<li>设备驱动程序：具体实现系统对设备的操作，根据设备不同而异</li>
<li>中断处理程序：用于保存中断进程的CPU环境与上下文切换等工作</li>
</ul>
<h4 id="2-设备独立性"><a href="#2-设备独立性" class="headerlink" title="2. 设备独立性"></a>2. 设备独立性</h4><p>设备分配：根据用户的I/O请求分配所需要的设备</p>
<ul>
<li><p>相关数据结构如下（以Linux为例子）</p>
<ul>
<li>设备控制表DCT：每个设备都有，其中包括设备类型、标识符、状态、相关指针等信息</li>
<li>控制器控制表COCT：一个设备控制器对应一个，OS根据此表信息对控制器进行操作管理</li>
<li>通道控制表CHCT：照应前面的通道控制方式，一个通道对应一个表</li>
<li>系统设备表SDT：整个系统只有一个，记录所有的已连接的设备情况</li>
<li>逻辑设备表LUT：用于将逻辑设备名映射为物理设备名。可以在系统中共用一张，也可以每个用户一张表</li>
</ul>
</li>
<li><p>分配算法：FCFS、最高优先级</p>
</li>
<li><p>分配步骤：</p>
<ol>
<li><p>进程根据逻辑设备名查找LUT中对应物理设备名，并根据系统API发送请求</p>
</li>
<li><p>根据I/O请求中的物理设备名查找SDT，找到DCT，得知设备状态</p>
</li>
<li><p>设备分配后，根据DCT找到COCT查询控制器状态</p>
</li>
<li><p>控制器分配后，根据COCT找到CHCT查询通道状态，不忙则分配，之后便开始数据传输</p>
</li>
</ol>
</li>
</ul>
<p>设备驱动程序接口：即常说的驱动，是I/O系统的上层与设备控制器之间的通信程序。基本功能如下：</p>
<ul>
<li>接收上层软件的命令参数，并将其转换为对设备的具体操作</li>
<li>检查I/O请求合法性，传递与设备操作有关的参数</li>
<li>发出I/O命令，设备空闲则启动，忙则将进程PCB挂载</li>
<li>及时响应设备控制器的中断请求，并据此调用相应中断处理程序</li>
</ul>
<p>SPOOLing技术/假脱机技术：为了缓和CPU高速和I/O设备低速的矛盾，并非具体的硬件，而是软件实现。大致思想是，在磁盘中建立输入井&amp;输出井，在内存中构建输入/输出缓冲区，以此来实现CPU与I/O设备之间的数据传输</p>
<h4 id="3-磁盘与固态硬盘"><a href="#3-磁盘与固态硬盘" class="headerlink" title="3. 磁盘与固态硬盘"></a>3. 磁盘与固态硬盘</h4><p>磁盘管理</p>
<ul>
<li>磁盘初始化：也叫低级格式化，对于空白盘，经此初始化后将其分为区，分区由头部、数据区域、尾部组成</li>
<li>磁盘分区：分区后，每个区都需要一个文件系统，这步也叫高级格式化，用于在分区中装入初始文件系统数据结构</li>
<li>磁盘引导块：由自举程序初始化CPU，寄存器等，并找到操作系统内核将其加载至内存。这个程序一般很小，在启动分区上</li>
</ul>
<p>磁盘调度算法</p>
<ul>
<li>先来先服务FCFS：根据访问磁盘的先后顺序查找</li>
<li>最短寻道时间有限SSTF：在当前位置，哪个请求的代价最小（最近）就先找谁</li>
<li>扫描算法SCAN：先顺着某个方向走到头之后，在更换方向去访问剩下的</li>
<li>循环扫描C-SCAN：先访问到向右访问到最右端，之后跳到最左端开始向右访问</li>
</ul>
<p>磁盘优化：磁盘会转，而且读入后需要一定时间处理，因此可以给扇区交错编号；采用磁盘高速缓存；提前读与延迟写；优化数据块的分布；磁盘阵列RAID。</p>
<p>固态硬盘SSD：由一个或多个闪存芯片和闪存翻译层构成，闪存芯片由许多块构成，块由页构成，页是数据的读写的基本单位，但在一定次数的读写后就会损坏。为了弥补页上的这种磨损，可采用动态/静态磨损均衡，前者在写时自动优先写新的，后者则是自动监测进行分配</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/05/%E6%B7%B1%E5%85%A5cpp/" title="《C++反汇编与逆向分析技术解密》读书笔记"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《C++反汇编与逆向分析技术解密》读书笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/31/%E7%BC%96%E9%93%BE%E8%A3%85/" title="《程序员自我修养——链接、装载与库》读书笔记"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《程序员自我修养——链接、装载与库》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/web.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zy0t1</div><div class="author-info__description">中二次元晚期</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zy0t1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zy0t1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wy1078041755@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62036500" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">0x01.计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1. 操作系统基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2. 操作系统发展历程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text">3. 操作系统运行环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">4. 操作系统结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-number">1.5.</span> <span class="toc-text">5. 操作系统引导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">6. 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">0x02.进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1. 进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CPU%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2. CPU调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">2.3.</span> <span class="toc-text">3. 同步与互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">4. 死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">0x03.内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">3.1.</span> <span class="toc-text">1. 内存分配与回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">2. 虚拟内存管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">0x04.文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">1. 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%AE%E5%BD%95"><span class="toc-number">4.2.</span> <span class="toc-text">2. 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3. 文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">0x05.输入&#x2F;输出管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-I-O%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC"><span class="toc-number">5.1.</span> <span class="toc-text">1. I&#x2F;O管理基本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">2. 设备独立性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A3%81%E7%9B%98%E4%B8%8E%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">5.3.</span> <span class="toc-text">3. 磁盘与固态硬盘</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Zy0t1</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>