<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《加密与解密》读书笔记1 | Zy0t1's blog</title><meta name="author" content="Zy0t1"><meta name="copyright" content="Zy0t1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《加密与解密》-第四版，基础篇至系统篇笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《加密与解密》读书笔记1">
<meta property="og:url" content="http://zy0t1.github.io/2024/04/27/%E5%8A%A0%E8%A7%A3%E5%AF%86/index.html">
<meta property="og:site_name" content="Zy0t1&#39;s blog">
<meta property="og:description" content="《加密与解密》-第四版，基础篇至系统篇笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp">
<meta property="article:published_time" content="2024-04-27T14:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T03:24:14.898Z">
<meta property="article:author" content="Zy0t1">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="Re">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp"><link rel="shortcut icon" href="/img/web.png"><link rel="canonical" href="http://zy0t1.github.io/2024/04/27/%E5%8A%A0%E8%A7%A3%E5%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《加密与解密》读书笔记1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-08 11:24:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/web.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Zy0t1's blog"><span class="site-name">Zy0t1's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《加密与解密》读书笔记1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-27T14:00:00.000Z" title="发表于 2024-04-27 22:00:00">2024-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T03:24:14.898Z" title="更新于 2024-08-08 11:24:14">2024-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《加密与解密》读书笔记1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p>API即应用程序编程接口，WinAPI子系统负责将API调用转换成Windows操作系统的系统服务调用，其下面就是Windows核心，上面是各种应用程序。</p>
<p>WinNT，也就是当前居多的XP/7/10等，在其上面的16位API都会通过一个转换层换为Win32函数调用，之后被操作系统处理。</p>
<p>WinNT中，DLL通常位于<code>\SYSTEM</code>和<code>\SYSTEM32</code>子目录中。winNT内核仅接受Unicode字符</p>
<blockquote>
<p>在winAPI中，A表示ANSI字符即单字节，W表示宽字符。A版的一般都会先转为W再给内存处理，会慢一点</p>
</blockquote>
<p>Windows主要部分在三个动态链接库中实现</p>
<ul>
<li>kernel（kernel32.dll）操作系统核心功能服务，包括进程线程控制、内存管理、文件访问等</li>
<li>User（USER32.dll）负责用户接口，包括键盘鼠标输入、窗口和菜单管理等</li>
<li>GDI（GDI32.dll）图形设备接口，允许程序在屏幕上显示文本和图形</li>
<li>注册表操作（AFVAPI32.dll）；通用控件（COMCTL32.dll）；公共对话框（COMDLG32.dll）；用户界面外壳（SHELL32.dll）；网络（NETAPI32.dll）</li>
</ul>
<p>WOW64：在64位的win上运行的32位子系统。64位系统文件放在<code>System32</code>文件夹下，<code>SysWOW64</code>则是存放的32位系统文件。64位的程序加载<code>System32</code>下的64位dll，当32位程序加载时WOW64会建立32位ntdll.dll的启动环境，并切换CPU模式为32位。</p>
<blockquote>
<p>WOW64通过将32位ntdll.dll重定向到64位的，发出对应的64位系统调用，返回时再转为32位</p>
<p>天堂之门：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-270153.htm">[原创]天堂之门 (Heaven’s Gate) C语言实现-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></p>
</blockquote>
<p>消息机制：windows是消息驱动式系统，消息提供与程序与程序之间、程序与系统之间。包括两种队列，系统消息队列和程序消息队列。当事件发生时由windows先放入系统消息队列，之后再复制到相应的程序队列中（非抢占，除部分系统消息基本都是先来先开）</p>
<h2 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h2><blockquote>
<p>这篇主要在于工具的使用，这里随笔带过</p>
</blockquote>
<p>动态分析工具：Ollydbg、MDebug、x96dbg、windbg</p>
<p>反汇编引擎：ODDisasm（OD）、BeaEngine、Udis86、Capstone、AsmJit、Keystone、XDE、LDasm等</p>
<ul>
<li>性能Udis86&gt;BeaEngine&gt;Capstone</li>
<li>解码能力：Capstone&gt;BeaEngine&gt;Udis86</li>
<li>平台支持：Capstone&gt;Udis86=BeaEngine</li>
<li>x86扩展指令：Capstone&gt;Udis86=BeaEngine</li>
</ul>
<p>十六进制工具：HexWorkshop、Winhex、Hiew</p>
<h2 id="解密篇"><a href="#解密篇" class="headerlink" title="解密篇"></a>解密篇</h2><blockquote>
<p>逆向分析技术内容与《C++反汇编》大致相同，这里不多介绍</p>
</blockquote>
<h4 id="演示版保护技术"><a href="#演示版保护技术" class="headerlink" title="演示版保护技术"></a>演示版保护技术</h4><ul>
<li><p>序列号保护机制</p>
<ol>
<li>用户名做变量，函数F变换得到注册码</li>
<li>注册码验证用户名正确性</li>
<li>对等函数检查注册码，F1(用户名)=F2(注册码)</li>
<li>同时将用户名注册码作为自变量</li>
</ol>
<ul>
<li>攻击思路：消息断点、提示信息、字符串比较</li>
</ul>
</li>
<li><p>警告窗口：eXeScope、Resource Hacker等工具打开对话框，可以设置屏蔽或者消息断点</p>
</li>
<li><p>时限：</p>
<ul>
<li>计时器：每次使用时间固定<code>setTimer()</code>、多媒体计时器、<code>GetTickCount()</code>、<code>timeGetTime()</code>等函数</li>
<li>天数限制：一个是安装时间，另一个是最近运行时间（可能会与当前系统时间进行比较）</li>
<li>破解思路：跳过有关函数，或者利用函数的参数进行更换，再或者变速齿轮更改时间</li>
</ul>
</li>
<li><p>菜单功能限制：一种是代码就不全（除了自己写没啥办法）；另一种是窗口变灰，有关函数<code>EnableMenuItem()</code>、<code>EnableWindow()</code></p>
</li>
<li><p>KeyFile：付费后发给一个小文件，其中包含垃圾信息和有用数据。破解思路一般跟踪文件读取等API函数，监视操作等</p>
</li>
<li><p>网络验证：抓包，本地模拟服务端，根据发送的包跟踪有关函数</p>
</li>
<li><p>光盘：刻录复制光盘，虚拟光盘模拟</p>
</li>
</ul>
<h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><blockquote>
<p>加密算法部分在密码学有关文章中有部分说明，这里仅补充</p>
</blockquote>
<p>单向散列函数，也叫hash算法，不可逆，可用于数字签名完整性检验等</p>
<ul>
<li><p>SHA算法，安全散列函数，包括sha1、sha256、sha384、sha512四种，分别产生160位、256位、384位、512位散列值</p>
</li>
<li><p>该算法系列会有初始散列值H用以进行初始化，SHA-1中：<code>H0=67452301h</code>、<code>H1=EFCDAB89h</code>、<code>H2=98BADCFEh</code>、<code>H3=10325476h</code>、<code>H4=C3D2E1F0h</code>可以作为特征进行识别</p>
</li>
</ul>
<p>对称加密算法，即加解密密钥相同</p>
<ul>
<li>BlowFish算法是一个64位分组及可变密钥长度的分组密码算法。</li>
<li>加密函数迭代执行16轮，分组长度为64位，密钥长度32位到448位。包括密钥扩展部分和数据加密部分<ul>
<li>密钥扩展：密钥转换为4168B的子密钥数组</li>
<li>数据加密：16轮的Feistel网络结构完成，每一轮由一个密钥相关置换和替换组成</li>
</ul>
</li>
</ul>
<p>公开密钥加密算法：加解密时使用不同的密钥。都基于NP问题进行设计，常见的有RSA、ElGamal、ECC（椭圆曲线）、DSA数字签名算法</p>
<p>常见加密库接口及识别</p>
<ul>
<li>Miracl：多精度整数和有理数算数运算库。<code>MR_IN(xx)</code>是该库的错误处理机制，用来表示Miracl中的函数以及退出代码，每个函数的xx都不同</li>
<li>FGInt：以$2^{31}$进制表示大数。PEiD中的<code>Krypto ANALyzer</code>插件可识别有关函数</li>
<li>其他加密算法库：freeLIP、Crypto++、LibTomCrypt、GMP、OpenSSL、DCP、DEC、NTL等</li>
</ul>
<h2 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h2><p>非常难！！！！好多看不懂！！！</p>
<h3 id="windows内核基础"><a href="#windows内核基础" class="headerlink" title="windows内核基础"></a>windows内核基础</h3><blockquote>
<p>内核在这本书中包括内核本身和以内核模块方式加载的驱动文件</p>
</blockquote>
<p>CPU设计之初是让R0运行内核，R1和R2运行设备驱动，R3运行程序。但实际是设备驱动与内核运行在R0级别，其余的在R3级别</p>
<p><strong>HAL</strong>：硬件抽象层，一个可加载的核心模块HAL.dll，它为系统上的硬件平台提供低级接口。在用户层导出NTDLL.dll通过win32API或其他子环境对其访问</p>
<p><strong>内存空间布局</strong>：</p>
<ul>
<li>在32位下，windows内存2GB内核空间与应用层空间，其中还有两个64KB大小的NULL空间和非法区域</li>
<li>64位下，除了上述空间外还有部分空洞。而且一般64位系统不会全用完，目前都是&lt;50位</li>
<li>逻辑地址=段选择符+偏移地址。CPU先通过分段机制计算出一个线性地址，之后再通过页表机制将线性地址映射到物理地址，从而获取内存中的数据指令</li>
</ul>
<p><strong>windows与内核启动</strong>：</p>
<ol>
<li>启动自检：BIOS中载入必要指令，进行自检，硬件初始化，同时在屏幕上显示信息</li>
<li>初始化启动：自检完后根据CMOS设置，BIOS加载启动盘，将MBR中的引导代码加载到内存，之后控制权交给MBR，搜索其中的分区表并找出活动分区，将第一个扇区中的引导代码载入内存。引导代码检测当前文件系统，查找并启动ntldr文件，转交控制权。（win7后一般是Bootmgr）</li>
<li>Boot加载：对ntldr有如下设置<ul>
<li>设置内存模式，32/64位</li>
<li>启动一个简单的文件系统，定位boot.ini等启动文件</li>
<li>读取boot.ini文件</li>
</ul>
</li>
<li>检测配置硬件</li>
<li>内核加载阶段：<ul>
<li>ntldr首先加载Windows内核Ntoskrnl.exe和硬件抽象层。后者对硬件底层进行隔离，转换为调用接口。</li>
<li>ntldr从注册表<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet</code>下读取已安装的驱动程序，然后依次加载驱动</li>
<li>初始化驱动，<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services</code>下查找“Start”值小于4的设备驱动（该值越小启动越早，4不被允许启动）</li>
</ul>
</li>
<li>Windows会话管理启动：驱动加载后内核会启动会话管理器，smss.exe，是第一个创建的用户模式进程<ul>
<li>创建系统环境变量</li>
<li>加载win32k.sys，它是win子系统的内核模式部分</li>
<li>启动csrss.exe是子系统的用户模式</li>
<li>启动winlogon.exe</li>
<li>创建虚拟内存页面文件</li>
<li>执行上次重启前没完成的重命名工作</li>
</ul>
</li>
<li>登录：由子系统启动的winlogon.exe提供对win用户的登录和注销支持<ul>
<li>启动服务子系统service.exe，即服务控制管理器</li>
<li>启动本地安全授权LSA过程lsass.exe</li>
<li>显示登陆界面</li>
</ul>
</li>
</ol>
<blockquote>
<p>win7与xp启动过程区别：ntldr替换为Bootmgr，之后Bootmgr寻找活动分区boot文件夹中的启动配置数据BCD文件，读取并组成启动菜单，显示多操作系统选择的画面。选择win7后，读取windows\system32\winload.exe，并转交控制权，由其加载内核硬件服务等</p>
<p>UEFI和GPT：替代BIOS和MBR，突破了分区容量的限制（实际上win对GPT分区数限制在128以内）。UEFI本身相当于一个微型操作系统，其上运行的程序以“.efi”结尾。也就是windows安装程序做成efi后可以从任意位置（分区、U盘等）启动</p>
</blockquote>
<p><strong>R3与R0通信</strong>：应用程序调用一个I/O有关API——》该API被封装在应用层某个DLL库中（kernel32.dll或user32.dll）——》更底层函数封装在ntdll.dll中（函数成对出现Nt、Zw开头）完成参数检查工作——》调用中断（int 2Eh或SysEnter指令）从R3进入到R0——》内核ntoskrnl.exe中有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SSDT/6338082">SSDT</a>，里面存放了与ntdll.dll中对应的SSDT系统服务处理函数，即内核态的Nt函数，与ntdll.dll中函数对应</p>
<blockquote>
<p>用户模式调用Zw/Nt开头的函数没有区别</p>
<p>在内核模式下后者会直接调用对应的函数代码，前者则是通过KiSystemService跳转到对应的代码处。</p>
<p>PS：这一part太难了，暂时看不懂</p>
</blockquote>
<p><strong>内核函数</strong>：调用时需要注意IRQL（中断请求级别）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>前缀</th>
<th>注释</th>
<th>前缀</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ex</td>
<td>管理层</td>
<td>Ke</td>
<td>核心层</td>
</tr>
<tr>
<td>HAL</td>
<td>硬件抽象层</td>
<td>Ob</td>
<td>对象管理</td>
</tr>
<tr>
<td>MM</td>
<td>内存管理</td>
<td>Ps</td>
<td>进程线程管理</td>
</tr>
<tr>
<td>Se</td>
<td>安全管理</td>
<td>Io</td>
<td>I/O管理</td>
</tr>
<tr>
<td>Fs</td>
<td>文件系统</td>
<td>Cc</td>
<td>文件缓存管理</td>
</tr>
<tr>
<td>Cm</td>
<td>系统配置管理</td>
<td>Pp</td>
<td>即插即用管理</td>
</tr>
<tr>
<td>Rtl</td>
<td>运行时程序库</td>
<td>Zw/Nt</td>
<td>对应SSDT服务函数</td>
</tr>
<tr>
<td>Flt</td>
<td>文件过滤驱动</td>
<td>Ndis</td>
<td>网络框架调用</td>
</tr>
</tbody>
</table>
</div>
<p><strong>内核驱动模块</strong>：包括巨硬自己的和第三方的，既有硬件的驱动也有软件的驱动。内核驱动在磁盘上是一个扩展名为.sys的遵守PE规范的文件。编译好的驱动执行过程如下：</p>
<ol>
<li>创建一个服务。注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\xxxxx</code>下建立一个与驱动名称相关的服务键</li>
<li>对象管理器生成驱动对象（DriverObject）传递给DriverEntry()并执行（）该函数是驱动执行的入口函数，类似于R3中的main</li>
<li>创建控制设备对象</li>
<li>创建控制设备符号链接</li>
<li>如果是过滤驱动则创建过滤设备对象并绑定</li>
<li>注册特定的分发派遣函数</li>
<li>其他初始化动作等的注册和初始化</li>
</ol>
<h3 id="内核重要结构！！！"><a href="#内核重要结构！！！" class="headerlink" title="内核重要结构！！！"></a>内核重要结构！！！</h3><h4 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h4><p>应用层的进程/线程、文件、驱动、事件、信号量或是句柄都在内核之中有对应的内核对象</p>
<p>内核对象=对象头（至少有一个OBJECT_HEADER和对象额外信息）+对象体（紧接着OBJECT_HEADER）。对象指针总是指向对象体，而非对象头，需要通过指针减去一定偏移。对象体内部一般会有一个type和一个size类型，来表示对象类型和大小。内核对象如下三种：</p>
<ul>
<li><p>Dispatcher对象：对象体开始位置有一个DISPATCHER_HEADER数据结构。包含该结构的内核对象都会以K开头，如“KPROCESS”、“KTHREAD”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DISPACHER_HEADER</span>&#123;</span></span><br><span class="line">	UCHAR	Type;</span><br><span class="line">	UCHAR	Absolute;</span><br><span class="line">	UCHAR	Size;</span><br><span class="line">	UCHAR	Inserted;</span><br><span class="line">	LONG	SignalState;</span><br><span class="line">	LIST_ENTRY	WaitListHead;</span><br><span class="line">&#125;DISPATCHER_HEADER;</span><br></pre></td></tr></table></figure>
</li>
<li><p>I/O对象：在对象体开头位置没有上述结构，但会放置一个与type和size有关的整型成员。常见的<code>DEVICE_OBJECT</code>、<code>DRIVER_OBJECT</code>等</p>
</li>
<li><p>其他对象：除了上述两种，剩下的都属于此。两个常用的“EPROCESS”、“ETHREAD”对象。</p>
<ul>
<li>EPROCESS用于内核中管理进程的各种信息，每个进程都对应这样一个结构体。所有的EPROCESS都被放入了一个双向链表，R3在枚举系统进程时会通过遍历这个链表来获得进程的列表。其中必定会包含前面的“KPROCESS”结构</li>
<li>ETHREAD同上，每个线程对应一个，并且也在一个双向链表中管理，其中必定包含一个“KTHREAD”结构</li>
</ul>
</li>
</ul>
<h4 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h4><p>即系统服务描述符表=“KeServiceDescriptorTable”。</p>
<p>ntdll.dll中的API是一个简单的包装函数——》当kernel32.dll中的API通过ntdll.dll时先完成对参数的检查——》在调用一个中断（int 2Eh或SysEnter指令）从而实现R3到R0——》并将需要调用的服务号（SSDT数组中的索引号index值）放入EAX中——》之后根据EAX索引在SSDT数组中调用指定的服务（Nt函数）</p>
<p>SSDT表结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ServiceDescriptorEntry</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *ServiceTableBase;		<span class="comment">//表的基地址</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *ServiceCounterTableBase;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> NumberOfServices;		<span class="comment">//表中服务函数个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *ParamTableBase;	</span><br><span class="line">&#125;ServiceDescriptorTableEntry_t *PServiceDescriptorTableEntry_t;</span><br></pre></td></tr></table></figure>
<p>Shadow SSDT和此类似，对应的表名“KeServiceDescriptorTableShadow”，是内核未导出的另一张表（自己不能直接导入引用），包含Ntoskrnel.exe和win32k.sys服务函数，主要处理来自User32.dll和GDI32.dll的系统调用。结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_DESCRIPTOR_TABLE</span>&#123;</span></span><br><span class="line">	SYSTEM_SERVICE_TABLE ntoskrnl;	<span class="comment">//ntoskrnl.exe</span></span><br><span class="line">	SYSTEM_SERVICE_TABLE win32k;		<span class="comment">//win32k.sys</span></span><br><span class="line">	SYSTEM_SERVICE_TABLE Table3;</span><br><span class="line">	SYSTEM_SERVICE_TABLE Table4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="TEB-amp-PEB"><a href="#TEB-amp-PEB" class="headerlink" title="TEB&amp;PEB"></a>TEB&amp;PEB</h4><p>TEB线程环境块，和PEB进程环境块，一样不在系统的内核空间中，是应用层的结构。</p>
<p>进程中除了系统线程外每个线程都有一个自己的TEB，一个进程的所有的TEB都在0x7FFDE000开始的线性地址，每4KB为一个完整的TEB。</p>
<p><code>NtCurrentTeb</code>可以返回当前线程TEB结构地址，通过其中的成员<code>ProcessEnvironmentBlock</code>可以获得当前进程的PEB地址</p>
<p>内核结构对象EPROCESS中同样记录了PEB结构地址，ETHREAD同样指向了应用层的TEB</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-teb">TEB (winternl.h) - Win32 apps | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb">PEB (winternl.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<h3 id="Win异常处理"><a href="#Win异常处理" class="headerlink" title="Win异常处理"></a>Win异常处理</h3><p>异常处理是OS处理程序错误或异常的一系列流程和技术总称。SEH结构化异常处理；VEH向量化异常处理（winxp以上版本）</p>
<h4 id="异常处理基本概念"><a href="#异常处理基本概念" class="headerlink" title="异常处理基本概念"></a>异常处理基本概念</h4><p>中断由外部硬件设备或异步事件引起，异常由内部事件产生，包括故障、陷阱、终止。故障陷阱是可恢复的，而终止类异常不可恢复，需要重启</p>
<p><strong>异常列表</strong>：由CPU引发的异常叫硬件异常，访问无效地址等；由操作系统或程序引发的叫软件异常。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>中断类型号</th>
<th>类型</th>
<th>类型号</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>除数为0</td>
<td>01</td>
<td>调试中断</td>
</tr>
<tr>
<td>03</td>
<td>断点中断</td>
<td>04</td>
<td>溢出中断</td>
</tr>
<tr>
<td>05</td>
<td>边界检查</td>
<td>06</td>
<td>非法指令故障</td>
</tr>
<tr>
<td>07</td>
<td>设备不可用</td>
<td>08</td>
<td>双重故障</td>
</tr>
<tr>
<td>0a</td>
<td>无效TSS中断</td>
<td>0b</td>
<td>段不存在异常</td>
</tr>
<tr>
<td>0c</td>
<td>栈异常</td>
<td>0d</td>
<td>通用保护异常</td>
</tr>
<tr>
<td>0e</td>
<td>页异常</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>软件异常还可以由代码主动引起<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-CN/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception">RaiseException 函数 (errhandlingapi.h) - Win32 apps | Microsoft Learn</a>，程序捕获软件异常的方法与捕获硬件异常的方法完全相同</p>
</blockquote>
<p><strong>异常处理的基本过程</strong></p>
<p>win启动后会运行在保护模式下，中断/异常发生时，CPU通过中断描述符表IDT来寻找处理函数。</p>
<ol>
<li><strong>IDT</strong>（下面在32位下说明）</li>
</ol>
<p>IDT存在于物理内存中的线性表，共256项，32位下每个IDT项长8字节，64位模式下64字节。OS在启动时会初始化这个表，每个CPU都会有一份该表拷贝。IDTR寄存器共48位=32位表基址+16位表长，可以使用SIDT、LIDT指令读写该寄存器。</p>
<p>IDT每项都是一个门结构，是中断/异常是CPU转移控制权的地方，包括3种</p>
<ul>
<li>任务门描述符，用于CPU的任务切换</li>
<li>中断门描述符，用于描述中断处理程序的入口</li>
<li>陷阱门描述符，描述异常处理程序的入口</li>
</ul>
<p>中断/异常发生时，CPU根据中断类型号转而执行对应的中断处理程序，也就是IDT表项下对应的函数，各异常处理函数除了对异常处理外还会将异常信息封装，方便后续处理</p>
<ul>
<li><p>封装的内容1：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-exception_record">EXCEPTION_RECORD (winnt.h) - Win32 apps | Microsoft Learn</a>即异常记录</p>
</li>
<li><p>封装的内容2：陷阱帧，用于描述发生异常时线程的状态（win的任务调度基于线程），<code>_KTRAP_FRAME</code>结构体，一般仅供系统内核自身或调试系统使用，当需要将控制权交给用户注册的异常处理程序时，会将该结构转为<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT (winnt.h) - Win32 apps | Microsoft Learn</a>结构</p>
</li>
</ul>
<p>包装完后，异常处理函数调用内核<code>KiDispatchException</code>函数来处理异常，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VOID KiDispatchException&#123;</span><br><span class="line">	IN	PEXCEPTION_RECORD ExceptionRecord,	<span class="comment">//异常结构信息</span></span><br><span class="line">	IN	PKEXCEPTION_FRAME ExceptionFrame,	<span class="comment">//未使用</span></span><br><span class="line">	IN	PKTRAP_FRAME TrapFrame,				<span class="comment">//发生异常时的陷阱帧</span></span><br><span class="line">	IN	KPROCESSOR_MODE PreviousMode,		<span class="comment">//异常发生时CPU是内核模式or用户模式</span></span><br><span class="line">	IN	BOOLEAN FirstChance					<span class="comment">//是否第一次处理该异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核态异常处理</p>
<ol>
<li>检测当前系统是否正被内核调试器调试，存在的话系统会转交控制权，否则跳过。内核调试器取得控制权后会根据用户的设置来确定是否处理该异常，如果没设置就把控制权交给用户。正确处理完之后回到原来的位置继续执行</li>
<li>若无内核调试器，或在第一次处理时调试器选择不处理，系统就会调用<code>RtlDispatchException</code>函数，根据线程注册的结构化异常处理SEH过程来处理该异常</li>
<li>如果<code>RtlDispatchException</code>函数没有处理该异常，系统会给调试器第二次处理机会，此时调试器可以再次取得对异常的处理权</li>
<li>上面两个都不行的话，系统则会认为不能继续运行了，并调用<code>KeBugCheckEx</code>产生蓝屏错误</li>
</ol>
<p>用户态异常处理</p>
<ol>
<li>如果程序正在被调试则会将异常信息发送给正在调试它的用户态调试器，如果没有被调试则跳过</li>
<li>不存在用户调试器或没处理，则会在栈上放置<code>EXCEPTION_RECORD</code>和<code>CONTEXT</code>两个结构，并将控制权返回用户态ntdll.dll中的<code>KiUserExceptionDispatcher</code>函数——》<code>RtDispatchException</code>函数进行用户态异常处理。</li>
<li>如果<code>Rt~</code>未能处理该异常，则会返回<code>Ki~</code>，并再次将异常信息发送给用户态的调试器（没有调试器就调用<code>ExitProcess</code>终结程序）</li>
</ol>
<h4 id="SEH说明"><a href="#SEH说明" class="headerlink" title="SEH说明"></a>SEH说明</h4><p>当没有调试器参与异常处理时，主要就是依靠SEH（用户模式和内核模式均可）和VEH（仅支持用户模式）机制</p>
<p>在程序运行错误时，SEH告诉系统由谁来处理，可以说是系统在终结程序之前提供的一个执行回调函数的机会</p>
<p><strong>SEH数据结构</strong></p>
<ul>
<li><p>TIB线程信息块，用于保存线程基本信息。在用户模式下位于TEB线程环境块头部。<a target="_blank" rel="noopener" href="https://www.nirsoft.net/kernel_struct/vista/NT_TIB.html">struct NT_TIB (nirsoft.net)</a></p>
</li>
<li><p><code>_EXCEPTION_REGISTRATION_RECORD</code>结构，位于TEB的偏移量0处，主要用于描述线程异常处理过程的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	_<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span>	<span class="comment">//指向下一个该结构的指针，也叫ERR指针</span></span><br><span class="line">	PEXCEPTION_ROUTINE Handler;		<span class="comment">//当前异常处理回调函数地址</span></span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>EXCEPTION_RECORD</code>结构和<code>CONTEXT</code>结构，分别描述异常发生的相关信息和线程状态信息</p>
</li>
<li><p><code>_EXCEPTION_POINTERS</code>结构：包括两个指针分别指向上面两个结构体。异常发生且没有调试器时，OS会将异常信息交给用户态的异常处理过程。同一线程在用户态和内核态是不同的栈，会在用户态栈中copy一下上面两个重要结构，并在栈中设置一个本结构体用以指向它们</p>
</li>
</ul>
<p><strong>SEH处理程序的安装卸载</strong></p>
<p>根据前面的结构体，我们只要在<code>_EXCEPTION_REGISTRATION_RECORD</code>结构链头部插入一个新的结构体就行。在安装SEH处理程序之前，需要一个符合SEH标准的回调函数，然后使用如下代码进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume fs:nothing</span><br><span class="line">	push	offset SEHandler	#压入Handler也就是异常处理回调函数地址</span><br><span class="line">	push	fs:[0]		#压入SEH链表头，相当于*Next</span><br><span class="line">	mov		fs:[0],esp		#更新SEH链表头</span><br></pre></td></tr></table></figure>
<p>SEH卸载类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov		esp,dword ptr fs:[0]</span><br><span class="line">pop		dword ptr fs:[0]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SEH异常处理程序原理及设计这部分就不展开了</p>
</blockquote>
<h4 id="VEH向量化异常处理"><a href="#VEH向量化异常处理" class="headerlink" title="VEH向量化异常处理"></a>VEH向量化异常处理</h4><p>与SEH类似，通过注册一个回调函数，发生异常时会被系统的异常处理过程调用，可以通过<code>AddVectoredExceptionHandler</code>注册VEH回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI PVOID WINAPI <span class="title function_">AddVectoredExceptionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">  ULONG                       First,</span></span><br><span class="line"><span class="params">  PVECTORED_EXCEPTION_HANDLER Handler		<span class="comment">//回调函数地址</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//回调函数原型</span></span><br><span class="line">LONG CALLBACK <span class="title function_">VectoredHandler</span><span class="params">(PEXCEPTION_POINTERS ExceptionInfo)</span>;</span><br><span class="line"><span class="comment">//卸载VEH函数,唯一参数是最上面函数的返回值</span></span><br><span class="line">ULONG <span class="title function_">RemoveVectoredExceptionHandler</span><span class="params">(PVOID VectorHandlerHandle)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler">AddVectoredExceptionHandler 函数 (errhandlingapi.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<p>该回调函数也形成了链表，如果First=0则置于链表尾，非0则放置于VEH链表最前端。</p>
<p>有异常时获得控制权优先级：调试器&gt;VEH&gt;SEH。VEH和SEH区别</p>
<ul>
<li>SEH信息在栈中，且后注册的在链前端；VEH信息存储于ntdll中的独立链表，可以指定链表头or尾</li>
<li>SEH基于线程，VEH作用于整个进程（旗下的所有线程）</li>
<li>VEH无需栈展开，只有一次被调的机会。</li>
</ul>
<blockquote>
<p>VCH属于VEH一部分，当SEH无法正常运行（ex：未过安全验证SafeSEH、SEHOP等）或SEH回调函数返回<code>RtIdspatchException</code>函数时才有机会执行</p>
</blockquote>
<h4 id="x64平台的异常处理"><a href="#x64平台的异常处理" class="headerlink" title="x64平台的异常处理"></a>x64平台的异常处理</h4><p><strong>原生x64</strong></p>
<p>新变化：SEH相关数据结构重定义；函数调用约定统一<code>_fastcall</code>。具体实施如下：</p>
<ol>
<li><p>提取所有函数起始、结束地址、函数的栈/寄存器操作（书中简称“序幕”操作）、异常处理信息，生成两个表</p>
<ul>
<li><p>函数信息表：所有函数在内存中的位置信息。在PE头部的数据目录<code>IMAGE_DIRECOTRY_EXCEPTION_DIRECOTY</code>中就有</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-runtime_function">RUNTIME_FUNCTION (winnt.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>异常发生时，<code>RtDispatchException()</code>根据发生时的rip调用<code>RtLookupFunctionTable()</code>查找rip位于哪个模块的<code>ExceptionTable</code>中</p>
</li>
<li><p>调用<code>RtLookupFunctionEntry()</code>查找rip所在的<code>FunctionEntry</code>，并获取它的“序幕”操作信息，从中取得<code>ExceptionHandler</code>规定的函数并执行</p>
<blockquote>
<p>x64上该函数通常是<code>_C_specific_handler()</code>。等同于x86上的<code>_except_handler3/4()</code></p>
</blockquote>
</li>
<li><p>该函数根据rip和ScopeTable来定位在哪一个Try块中，然后执行相应的FiterFunc，并根据返回值确定：A-执行HandlerFunc、返回异常点继续；B-查找下一个异常处理函数（需要<code>RtVirtualUnwind()</code>模拟展开）</p>
<blockquote>
<p>ScopeTable：该表紧跟于前面的“序幕”操作表，其中包含了try块的开始结束地址、异常函数的Handler函数、FilterFunc、HandlerFunc地址等</p>
</blockquote>
</li>
</ol>
<p><strong>WOW64下异常分发</strong></p>
<p>有关的用户模式下dll：</p>
<ul>
<li>Wow64.dll：管理进程/线程注册，钩住异常分发和Ntoskrnl.exe导出的基本系统调用，实现文件重定位及注册表重定位</li>
<li>Wow64Cpu.dll：管理WOW64内部运行的线程的32位CPU环境，针对32-64位的CPU模式互切</li>
<li>Wow64win.dll：截取Win32k.sys导出的GUI系统调用</li>
<li>64位ntdll.dll：负责执行真正的系统调用</li>
</ul>
<p>Wow64通过上面64位ntdll中的<code>KiUserExceptionDispatcher</code>钩住异常分发——》该函数捕获原生异常信息+用户模式下环境记录——》转换为32位的异常和环境记录——》转交给32位ntdll下<code>KiUserExceptionDispatcher</code>，之后与原生32位中的异常分发过程一致</p>
<h3 id="Win32调试API"><a href="#Win32调试API" class="headerlink" title="Win32调试API"></a>Win32调试API</h3><blockquote>
<p>加载/捆绑一个正在运行的程序以供调试，可以获得被调试程序的底层信息，甚至修改内存、线程运行环境等</p>
</blockquote>
<h4 id="相关函数说明"><a href="#相关函数说明" class="headerlink" title="相关函数说明"></a>相关函数说明</h4><ul>
<li>允许调试器恢复之前由于调试事件而挂起的线程<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-continuedebugevent">ContinueDebugEvent 函数 (debugapi.h)</a></li>
<li><strong>允许调试器捆绑到一个正在运行的进程上</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-debugactiveprocess">DebugActiveProcess 函数 (debugapi.h)</a></li>
<li>调试器卸载<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-debugactiveprocessstop">DebugActiveProcessStop 函数 (debugapi.h) - Win32 apps | Microsoft Learn</a></li>
<li>在当前进程产生一个断点异常，如果未在调试下该异常会被系统接管，一般进程终止<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-debugbreak">DebugBreak 函数 (debugapi.h) | Microsoft Learn</a>等同于插入int 3断点</li>
<li><strong>指定进程中产生一个异常断点</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-debugbreakprocess">debugBreakProcess 函数 (winbase.h) | Microsoft Learn</a></li>
<li>调用进程强制退出，控制权转移至调试器，并在推出前产生一个int 3断点<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-fatalexit">FatalExit 函数 （winbase.h）| Microsoft Learn</a></li>
<li>刷新指令高速缓存<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-flushinstructioncache">FlushInstructionCache 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></li>
<li><strong>获取指定线程执行环境</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></li>
<li>返回指定选择器和线程的描述符表入口地址<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-getthreadselectorentry">GetThreadSelectorEntry 函数 (winbase.h) </a></li>
<li>判断是否处在调试环境中<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent">isDebuggerPresent 函数 (debugapi.h) </a></li>
<li>传递字符串给调试器显示<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa">OutputDebugStringA 函数 (Windows.h) </a></li>
<li><strong>读取指定进程某区域内数据</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory">ReadProcessMemory 函数 (memoryapi.h) </a></li>
<li>设置指定线程执行环境<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext 函数 (processthreadsapi.h) </a></li>
<li>等待被调试进程发生调试事件<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent">WaitForDebugEvent 函数 (debugapi.h)</a></li>
<li><strong>指定进程某区域写入内存</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory 函数 (memoryapi.h)</a></li>
</ul>
<h4 id="代码注入进程"><a href="#代码注入进程" class="headerlink" title="代码注入进程"></a>代码注入进程</h4><blockquote>
<p>注入代码注意栈平衡</p>
</blockquote>
<ol>
<li><p><code>CreateProcess()</code>创建进程设置debug标志；<code>IsDebuggerPresent()</code>查看是否在调试器下运行；<code>DebugActiveProcess()</code>绑定到正在运行的进程</p>
</li>
<li><p><code>WaitForDebugEvent()</code>+<code>ContinueDebugEvent()</code>构成调试循环体来等待获取信息-处理-继续线程，并根据<code>WaitForDebugEvent()</code>返回的<code>DEBUG_EVENT</code>来分支判断</p>
</li>
<li><p><code>SuspendThread()</code>挂起目标线程</p>
</li>
<li><p><code>VirtualProtectEx()</code>修改目标页读写权限</p>
</li>
<li><p><code>ReadProcessMemory()</code>读取目标页</p>
</li>
<li><p><code>GetThreadContext()</code>保存线程环境</p>
</li>
<li><p><code>WriteProcessMemory()</code>写入新的代码页</p>
<blockquote>
<p>可以在目标中调用<code>VirtualAlloc()</code>申请额外空间</p>
</blockquote>
</li>
<li><p>新指令最后是一条是int 3，利用此获取系统控制权</p>
</li>
<li><p>保存CONTEXT结构的临时拷贝</p>
</li>
<li><p>在拷贝中新设置EIP值</p>
</li>
<li><p>恢复原线程的执行，执行我们的代码直到int 3被执行，此时程序被捕获，目标线程再次挂起</p>
</li>
<li><p>利用<code>WriteProcessMemory()</code>恢复线程原始代码页</p>
</li>
<li><p>恢复原始代码页读写属性</p>
</li>
<li><p><code>SetThreadContext()</code>恢复线程原始环境</p>
</li>
<li><p>恢复原始线程执行</p>
</li>
</ol>
<h3 id="VT技术"><a href="#VT技术" class="headerlink" title="VT技术"></a>VT技术</h3><p>VT指的是Intel的硬件辅助虚拟化技术，处于Ring -1层级。目的是为了提升VMM-虚拟机监视器（win上俗称Hypervisor）的性能。</p>
<p>该技术提供了一种虚拟机扩展VMX给CPU，在该扩展中CPU多了一个Root模式（仅供VMM食用），而其上运行的系统处于non-Root模式，VMM通过VMCS-虚拟机控制结构，可以捕获系统使用的特权指令和对硬件的访问，此时VM退出，CPU从non-root切换到Root模式，VMM进行控制。</p>
<p>创建一个VT技术Hypervisor过程大致如下：</p>
<ol>
<li>分配VMXOn区域和VMCS控制块（一个VMCS代表一个GuestOS）</li>
<li>填写VMCS控制块</li>
<li>调用VMXLaunch指令启动虚拟机</li>
<li>当产生#VMExit事件时调用<code>VMExitProc()</code>，并处理各种虚拟机陷入消息</li>
</ol>
<blockquote>
<p>Intel为VT技术引入了一系列新指令集。<code>VMXOn</code>打开VT模式，此时CPU处于root模式——》对GuestOS进行配置——》<code>VMLaunch</code>从root模式转入non-root模式——》GuestOS产生Hypervisor感兴趣事件则陷入处理——》<code>VMXOff</code>关闭VT模式</p>
</blockquote>
<p>VMCS=4B-版本标志+4B-VMX退出原因指示器+数据区；数据区包括如下六个部分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟机状态域</td>
<td>GuestOS运行时从该区域加载诸如CPU状态等信息，退出时在此处保存状态</td>
</tr>
<tr>
<td>宿主机状态域</td>
<td>记录所有有关Hypervisor的状态信息，只存储寄存器有关信息。（#VMExit时通过此区域恢复Hypervisor信息）</td>
</tr>
<tr>
<td>虚拟机执行控制域！！</td>
<td>用于设置推出条件，以及哪些事件会导致陷入，类似于代码段</td>
</tr>
<tr>
<td>虚拟机VMEntry控制域</td>
<td>控制虚拟机#VMEntry发生时（Hypervisor——》GuestOS）的行为，类似于.init段</td>
</tr>
<tr>
<td>虚拟机VMExit控制域</td>
<td>在#VMExit后硬件立即要做的事情，类似于.fini段</td>
</tr>
<tr>
<td>虚拟机VMExit信息域</td>
<td>只读区域，包含最近#VMExit事件的相关信息，算是一种日志</td>
</tr>
</tbody>
</table>
</div>
<p>EPT，即扩展页表技术，用于隔离各个GuestOS。在开启EPT的CPU上，GuestOS通过CR3寄存器——》物理地址GuestPA通过EPT机制（EPTP寄存器）——》真实平台物理空间地址HostPA。</p>
<blockquote>
<p>EPT类似于分页机制，就是中间多加了一层。最多可以包含4级页表结构</p>
</blockquote>
<h3 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h3><p>PE文件中的数据结构一般有32位和64位之分，除了在64位版本中的一些扩展域之外剩下几乎一样</p>
<p><img src="https://s2.loli.net/2024/08/08/qSL9hFCMET8krt7.png" alt="PE.png"></p>
<h4 id="PE基本概念（x86）"><a href="#PE基本概念（x86）" class="headerlink" title="PE基本概念（x86）"></a>PE基本概念（x86）</h4><p>文件内容被分割为不同的区块，其中包含着代码或数据，每个区块按照页边界对齐。Windows加载器遍历PE文件并决定文件的哪一部分被映射到内存的某个地方。</p>
<ul>
<li>基地址：PE文件通过加载器到内存后，内存中的版本叫“模块”，其开始地址叫”模块句柄“，也叫“基地址”—ImageBase。该值由PE文件本身决定，默认下EXE=400000h、DLL=10000000h。</li>
<li>虚拟地址：PE被加载器映射到内存中，每个程序都有自己的虚拟空间，这个虚拟空间的地址叫“虚拟地址”—VA</li>
<li>相对虚拟地址：RVA是内存中相对于PE基地址的偏移，VA=ImageBase+RVA</li>
<li>文件偏移地址：PE文件在磁盘上时，数据的位置相对于文件头的偏移量，即文件偏移地址/物理地址—File_Offset/RAW_Offset</li>
</ul>
<h4 id="MS-DOS头"><a href="#MS-DOS头" class="headerlink" title="MS-DOS头"></a>MS-DOS头</h4><p>每个PE文件都以一个DOS程序开头，如果程序在DOS下执行就会被识别出来，并显示一个类似的错误提示“This program cannot be run in MS-DOS mode”。一般由汇编器/编译器自动生成。</p>
<p><code>IMAGE_DOS_HEADER</code>（共0x40=64B）以“MZ”标志开头-魔数，其中的<code>e_lfanew</code>字段（最后4B）是真正的PE文件头的RVA</p>
<h4 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h4><p><code>IMAGE_NT_HEADERS</code>其中包含许多重要字段，由<code>Signature</code>+<code>IMAGE_FILE_HEADER</code>+<code>IMAGE_OPTIONAL_HEADER32</code>构成</p>
<ul>
<li><code>Signature</code>：“PE\0\0”表明PE文件头的开始</li>
<li><code>IMAGE_FILE_HEADER</code>：也叫COFF file header，因为在COFF格式的obj文件开始处也是这个<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_file_header">IMAGE_FILE_HEADER (winnt.h)</a></li>
<li><code>IMAGE_OPTIONAL_HEADER</code>：可选结构，但一般都会有因为前面一个结构体不足以定义PE的文件属性<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">IMAGE_OPTIONAL_HEADER32 (winnt.h)</a></li>
</ul>
<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p>在PE文件头和原始数据之间有一个区块表，是一个<code>IMAGE_SECTION_HEADER</code>结构数组<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_section_header">IMAGE_SECTION_HEADER (winnt.h)</a>，每一项结构都包含了相应区块的信息，例如位置、长度、属性等，其长度=前面FILE_HEADER下的<code>NumberOfSections</code>指出</p>
<p>PE文件至少两个区块=代码块+数据块。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区块名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.text</td>
<td>代码区块。或者叫code，内容全是指令代码</td>
</tr>
<tr>
<td>.data</td>
<td>默认读/写数据区块。全局+静态</td>
</tr>
<tr>
<td>.rdata</td>
<td>默认只读数据区。少见，存放说明字符串或存放调试目录</td>
</tr>
<tr>
<td>.idata</td>
<td>输入表。包含其他DLL的函数及数据信息，常合并到.rdata中</td>
</tr>
<tr>
<td>.edata</td>
<td>输出表。创建输出API或数据的可执行文件时，会有一个.EXP文件，其中包含此，但常被合并到.text或.tdata</td>
</tr>
<tr>
<td>.rsrc</td>
<td>资源。只读，不能是其他名字，包含图标/菜单/位图等</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化数据。少用，常.data区</td>
</tr>
<tr>
<td>.crt</td>
<td>用于支持Cpp运行时（CRT）所添加的数据</td>
</tr>
<tr>
<td>.tls</td>
<td>线程局部存储器，支持通过<code>__declspec(thread)</code>声明的线程局部存储变量的数据</td>
</tr>
<tr>
<td>.reloc</td>
<td>可执行文件的基址重定位。一般只有DLL有</td>
</tr>
<tr>
<td>.sdata</td>
<td>用于IA-64体系结构下（该体系纯血64位，不兼容32位）</td>
</tr>
<tr>
<td>.srdata</td>
<td>同上</td>
</tr>
<tr>
<td>.pdata</td>
<td>异常表。用于异常处理</td>
</tr>
<tr>
<td>.debug$S</td>
<td>OBJ文件中CodeView格式的<strong>符号</strong>记录流。</td>
</tr>
<tr>
<td>.debug$T</td>
<td>CodeView格式的<strong>类型</strong>记录流</td>
</tr>
<tr>
<td>.debug$P</td>
<td>与预编译有关</td>
</tr>
<tr>
<td>.drectve</td>
<td>链接器命令，只存在于OBJ文件。命令是给链接器的，空格隔开</td>
</tr>
<tr>
<td>.didat</td>
<td>延迟载入的输入数据。debug模式下才有，release模式下会合并到另一区块</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>VC编译器<code>#pragma data_seg(&quot;hh&quot;)</code>可自定义hh数据区块。</p>
</li>
<li><p>链接器会将不同文件中的区块进行<strong>部分</strong>合并（例如所有的text），有些模块是给链接器看的因此不会合并。</p>
</li>
<li>合并区块能够节省空间，因为一个区块至少占用1个内存页。</li>
<li>在PE文件头中有指出区块的大小是要对齐的，一种用于磁盘文件<code>FileAlignment</code>，一种用于内存中<code>SectionAlignment</code>。每个区块都从对齐值倍数处开始，中间填0（在磁盘中叫区块间隔）。一般默认都是4KB</li>
<li>磁盘对齐值和内存对齐值不同时，则磁盘映像和内存映像就不同（DOS头、PE头、块表不动）。<code>FileOffset = RVA - Δ</code> ；<code>VA - ImageBase - Δ = FileOffset</code>，画个图茅塞顿开</li>
</ul>
<blockquote>
<p>注意区分区块表和数据目录表，区块表顾名思义指向的是区块，而数据目录表则是指向一些重要的数据结构（目前msdn仅有15个表项），这些数据结构可能会存在于区块之下。后面的内容都是由数据目录表指向的</p>
</blockquote>
<h4 id="输入表"><a href="#输入表" class="headerlink" title="输入表"></a>输入表</h4><p>windows加载器通过PE文件的输入表（IT，也叫导入表）使得本程序可以使用其他文件中（如DLL）的函数数据（<code>__declspec(dllimport)</code>）。其中保存的是函数名和其驻留的DLL等动态链接所需的信息</p>
<ul>
<li><p>隐式链接：程序调用DLL的代码数据时，隐式被windows加载器完成（即下面的两个函数由加载器完成，而非自己编写的程序）</p>
<blockquote>
<p>windows加载器会一次性将所有需要的dll都给加载到内存中</p>
</blockquote>
</li>
<li><p>显式链接：在运行期链接，即DLL已经在内存中，<code>LoadLibrary()</code>和<code>GetProcAddress()</code></p>
</li>
</ul>
<p>输入表以一个<code>IMAGE_IMPORT_DESCRIPTOR</code>（IID）数组开始，一个外部DLL对应一个该结构。数组以NULL结尾，据此可得出项数（引入的dll数目）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;</span><br><span class="line">    &#125; DUMMYUNIONNAME;		<span class="comment">//指向INT表的RVA</span></span><br><span class="line">    DWORD   TimeDateStamp;		<span class="comment">//文件建立时间戳</span></span><br><span class="line">    DWORD   ForwarderChain;		<span class="comment">//引用的DLL的API，又引用了其他DLL的API，现在一般为0</span></span><br><span class="line">    DWORD   Name;		<span class="comment">//指向的DLL名字</span></span><br><span class="line">    DWORD   FirstThunk;		<span class="comment">//一个指向IAT表的RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="comment">//IAT-输入地址表&amp;INT-输入名称表，都是一个IMAGE_THUNK_DATA结构数组，且以0为结尾</span></span><br></pre></td></tr></table></figure>
<p>下面是<code>IMAGE_THUNK_DATA</code>结构体的说明，一个该结构体对应一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">//指向一个字符串的RVA</span></span><br><span class="line">        DWORD Function;             <span class="comment">//输入函数地址</span></span><br><span class="line">        DWORD Ordinal;				<span class="comment">//输入API的序数值</span></span><br><span class="line">        DWORD AddressOfData;        <span class="comment">//指向IMAGE_IMPORT_BY_NAME表</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="comment">//双字最高位是1时，函数是以序号形式导入的，此时的低31/63位就是函数序号</span></span><br><span class="line"><span class="comment">//最高位是0时，函数以字符串形式导入，此时双字=RVA地址，指向一个IMAGE_IMPORT_BY_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;		<span class="comment">//表示函数的序号</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>];		<span class="comment">//导入函数的名称字符串</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME</span><br></pre></td></tr></table></figure>
<p>上述几个数据结构关系如下。PE装载器先搜索“OriginalFirstThunk”，据此<code>IMAGE_IMPORT_BY_NAME</code>来对比函数名，找出对应函数地址，并最终填入IAT</p>
<p><img src="https://s2.loli.net/2024/08/08/4jcUIxu5DarsOwC.png" alt="PE_IAT.png"></p>
<blockquote>
<p>有时一些函数仅通过序号引出，只能根据其相对位置来调用。</p>
<p>另一种情况是OriginalFirstThunk=0，初始化时系统根据FirstThunk——》IAT——》函数名——》得到函数入口地址——》替换IAT中的“指向字符串”的指针</p>
</blockquote>
<h4 id="绑定输入"><a href="#绑定输入" class="headerlink" title="绑定输入"></a>绑定输入</h4><p>在上一步我们需要在每次装载时，将需要用到的dll都给映射到内存，并替换函数地址。可以通过<strong>绑定输入</strong>将dll的地址提前写入程序IAT中（绑定程序在编译期间写入，而非加载运行时慢慢找）</p>
<ul>
<li>进程初始化时，需要的dll实际上加载到了他们首选的基地址中</li>
<li>绑定后，dll的输出表中的符号位置没有改变</li>
</ul>
<p>有一个不满足，就说明绑定的地址无效。当绑定时，会有dll的相关信息放入文件，加载器会对这些信息进行检查，来判断是否有效。数据目录表（可选头的最后一项）的第12项即T[11]<code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code>指向绑定输入，是<code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>结构数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span>&#123;</span></span><br><span class="line">	DWORD	TimeDateStamp;	<span class="comment">//时间戳</span></span><br><span class="line">    WORD	OffsetModuleName;	<span class="comment">//一个指向被输入dll的名称的偏移</span></span><br><span class="line">    WORD	NumberOfModuleForwardRefs;	<span class="comment">//本结构后面紧跟的IMAGE_BOUND_FORWARDER_REF的数目(该结构前两项都和此结构相同,最后一项保留)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个DLL中的API需要用到别的DLL时，后面这个dll也需要检查，也就有了IMAGE_BOUND_FORWARDER_REF</p>
</blockquote>
<p>当dll版本信息与PE文件中不同时，就会认为绑定的信息无效，需要重定位（再次遍历找地址填入IAT）</p>
<h4 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h4><p>有输入就有输出，常见于dll。输出表位置由数据目录表（可选头最后一项）中的第一项指出，其中包含有函数名称、输出序数等，序数在一个dll中独一无二，长16位（但很少以此导出，容易出问题）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;	<span class="comment">//属性，一般为0</span></span><br><span class="line">    DWORD   TimeDateStamp;		<span class="comment">//文件生成时间戳</span></span><br><span class="line">    WORD    MajorVersion;		<span class="comment">//主版本号，常0</span></span><br><span class="line">    WORD    MinorVersion;		<span class="comment">//次版本号</span></span><br><span class="line">    DWORD   Name;		<span class="comment">//指向DLL名字</span></span><br><span class="line">    DWORD   Base;		<span class="comment">//导出函数的起始序列号，与下面的序号y相加得到对应函数的导出序号</span></span><br><span class="line">    DWORD   NumberOfFunctions;		<span class="comment">//EAT-输出地址表 元素个数</span></span><br><span class="line">    DWORD   NumberOfNames;		<span class="comment">//ENT-输出函数名称表 元素个数</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">//指向EAT，每个成员占4B，表示相应函数的RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">//指向ENT，一个指针数组，每个元素地址指向函数名字字符串，借此数组与我们需要的函数名称进行对比，我们可以找到目标的序号x</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">//指向一个序号对应数组，由上面的序号x，查找得到需要的函数地址在EAT中的序号y</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY</span><br></pre></td></tr></table></figure>
<p>注：NumberOfNames &lt;= NumberOfFunctions（导出的都有），有些函数只通过序数输出</p>
<h4 id="基址重定位"><a href="#基址重定位" class="headerlink" title="基址重定位"></a>基址重定位</h4><p>PE文件在执行时会装载到默认的基地址，如果此位置有东西，此时PE文件就需要装载到另一个地址中，就需要重定位表来调整</p>
<p>PE文件将文件中所有可能修改的地址都放在一个数组中（基地址重定位表），只要有一个需要修正，那么每个定位都会被修正（装载器换映射地址）</p>
<p>exe文件使用自己的独立的虚拟空间地址，因而能够正常的载入；但对于dll来说，dll无法保证载入地址没有其他dll，因此dll中常包含重定位信息</p>
<p>在.reloc区块中，由许多<strong>重定位块</strong>串接构成，每个块中有共计4KB大小的重定位信息，每个块以下面结构开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;		<span class="comment">//重定位数据开始的RVA地址</span></span><br><span class="line">    DWORD   SizeOfBlock;		<span class="comment">//重定位块大小</span></span><br><span class="line">    WORD    TypeOffset[];		<span class="comment">//重定位数组-RVA(每项16位，高四位=0100时，低12位地址才有效)</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>windows程序的各种界面，包括加速键、位图、光标、对话框、图标、菜单等都是资源。</p>
<ul>
<li>资源目录结构：节点=<code>IMAGE_RESOURCE_DIRECTORY</code>+若干<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>构成。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_RESOURCE_DIRECTORY</span>&#123;</span></span><br><span class="line">	DWORD	Characteristics;	<span class="comment">//资源属性标志，常0</span></span><br><span class="line">	DWORD	TimeDateStamp;	</span><br><span class="line">	DWORD	MajorVersion;		</span><br><span class="line">	DWORD	MinorVersion;</span><br><span class="line">	DWORD	NumberOfNameEntries;	<span class="comment">//使用名字的资源条目个数</span></span><br><span class="line">	DWORD	NumberOfEntries;		<span class="comment">//使用ID数字的资源条目个数</span></span><br><span class="line">&#125;<span class="comment">//上面两个Number的和，就是该结构后面紧跟的XX_DIRECTORY_ENTRY结构的数目</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span>&#123;</span></span><br><span class="line">	DWORD	Name;			<span class="comment">//目录项的名称字符串指针或ID</span></span><br><span class="line">    <span class="comment">//最高位=1，低位——》指针;否则当ID使用</span></span><br><span class="line">	DWORD	OffsetToData;	<span class="comment">//资源数据偏移地址或子目录偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将上面的<strong>节点</strong>分为三层，简称为结构A、B。</p>
<ul>
<li><p>第一层=1×A+k×B，每个B中的Name字段表示资源类型</p>
<blockquote>
<p>01h=光标；02h=位图；03h=图标。。。</p>
</blockquote>
</li>
<li><p>第二层=k×(A+B)，每个B中Name字段表示资源名称</p>
<blockquote>
<p>此时Name指向一个<code>IMAGERESOURCE_DIR_STRING_U</code>的字符串结构</p>
</blockquote>
</li>
<li><p>第三层=k×(A+B)，Name字段表示代码页编号</p>
<blockquote>
<p>该层的OffsetToData才指向下面的结构（资源数据）</p>
</blockquote>
</li>
</ul>
<p>每个资源必定由一个<code>IMAGE_RESOURCE_DATA_ENTRY</code>指向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_RESOURCE_DATA_ENTRY</span>&#123;</span></span><br><span class="line">	DWORD	OffsetToData;	<span class="comment">//资源数据RVA</span></span><br><span class="line">	DWORD	Size;			<span class="comment">//资源大小</span></span><br><span class="line">	DWORD	CodePage;		<span class="comment">//代码页，常0</span></span><br><span class="line">	DWORD	Reserved;		<span class="comment">//保留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li><p>TLS初始化：TLS即线程本地存储器。<code>__declspec(thread)</code>声明变量TLS变量时，编译器将其放置到.tls区块，程序执行时，该区块会得到一块内存来存储TLS变量。数据目录表中相应位置有指针的话，会指向<code>IMAGE_TLS_DIRECTORY</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_TLS_DIRECTORY32</span>&#123;</span></span><br><span class="line">	DWORD	StartAddressOfRawData;	<span class="comment">//内存起始地址，用于初始化新线程TLS</span></span><br><span class="line">	DWORD	EndAddressOfRawData;	<span class="comment">//对应上面区域的结束地址</span></span><br><span class="line">	DWORD	AddressOfIndex;			<span class="comment">//运行库利用该索引定位线程局部数据</span></span><br><span class="line">	DWORD	AddressOfCallBacks;		<span class="comment">//回调函数指针数组的地址</span></span><br><span class="line">	DWORD	SizeOfZeroFill;			<span class="comment">//后面跟的个数</span></span><br><span class="line">	DWORD	Characteristics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调试目录：数据目录表中第七项指出调试目录，是一个<code>IMAGE_DEBUG_DIRECTORY</code>结构数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DEBUG_DIRECTORY</span>&#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	DWORD	Type;		<span class="comment">//debug信息类型</span></span><br><span class="line">	DWORD	SizeOfData;	<span class="comment">//debug数据大小</span></span><br><span class="line">	DWORD	AddressOfRawData;	<span class="comment">//debug数据在内存的RVA，0表示不映射</span></span><br><span class="line">	DWORD	PointerToRawData;	<span class="comment">//debug数据的FOA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多用pdb文件存储debug信息。</p>
</blockquote>
</li>
<li><p>延迟载入：即程序运行时通过<code>LoadLibrary()</code>、<code>GetProcAddress()</code>等获取延迟加载函数的地址。数据目录表中的相应位置指向<code>ImgDelayDescr</code>结构数组，一个延迟的dll对应这样一个结构。该结构中包含对应dll的IAT、INT指针，当程序需要调用其他API时，会先通过上面两个函数将得到的dll中IAT、INT地址填入本结构中，之后再调用时就在这里找。</p>
</li>
<li><p>程序异常数据：在x86基于表的异常处理方式下，数据目录表中会指向一个<code>IMAGE_RUNTIME_FUNCTION_ENTRY</code>结构数组，该数组记录每个函数的起始结束地址与异常处理方法等信息</p>
</li>
</ul>
<h3 id="注入技术"><a href="#注入技术" class="headerlink" title="注入技术"></a>注入技术</h3><p><code>VirtualQueryEx/VirtualProtectEx()</code>可以查询目标进程的内存信息和页属性，<code>ReadProcessMemory/WriteProcessMemory()</code>等可以对目标进程空间进行读写，但是跨进程不能执行自己的代码，于是dll注入目标就派上用场了</p>
<p>dll注入方法 == 程序加载dll的三个时机</p>
<ol>
<li>进程创建阶段加载输入表中的dll——静态输入</li>
<li>通过调用<code>LoadLibrary()</code>主动加载——动态加载</li>
<li>系统机制要求的一些系统预设的基础服务模块</li>
</ol>
<h4 id="干预输入表"><a href="#干预输入表" class="headerlink" title="干预输入表"></a>干预输入表</h4><p>进程创建后——》ntdll中的<code>LdrInitializeThunk()</code>调用——》<code>LdrpInitializeProcess()</code>对进程初始化——》<code>LdrpWalkImportDescriptor()</code>对输入表进行处理，填充相应IAT。因此需要在输入表被处理之前给输入表增加一个项目，使其指向需要加载的目标dll（或者替换dll）</p>
<p><strong>静态修改PE输入表</strong></p>
<ol>
<li><p>编写要注入的dll</p>
</li>
<li><p>寻找空间来增添新的IID，最好情况就是某节内部存在足够空隙，否则就需要扩展节/增加新节</p>
<blockquote>
<p>因为IID数组紧挨着OriginalFirstThunk和FirstThunk相关结构因此不能直接覆盖，故需要将其整体移动到新位置</p>
</blockquote>
</li>
<li><p>备份原IID数组（该位置不可写），将其复制到我们的目标空间（增加一项后，末尾记得补0）</p>
</li>
<li><p>在原IID数组位置上编写，新增项的关联OriginalFirstThunk、FirstThunk、Name有关结构</p>
</li>
<li><p>根据第4步新增结构，填写第3步的新增项</p>
</li>
<li><p>修正PE头中输入表目录位置和大小，主要注意新增的FirstThunk指向的位置（即IAT）要设置为可写。</p>
<blockquote>
<p>即原IID数组所在节整个添加可写属性，在区块表中原属性基础上加上<code>0xE0000020</code></p>
</blockquote>
</li>
<li><p>输入表如果有预先绑定就需要将PE文件头数据目录表中第11项清0</p>
</li>
</ol>
<blockquote>
<p>PEditor,LordPE等工具方便修改PE结构</p>
</blockquote>
<p><strong>进程创建期间修改PE输入表</strong></p>
<p>和上面的相比，因为是在进程创建期间修改，可利用的空间由“文件空隙”变成了“内存空隙”，因此会比较好找空间</p>
<ol>
<li><p>以挂起方式创建目标进程（借助另一个程序的<code>CreatProcess()</code>，加上<code>CREATE_SUSPENDED</code>标志）</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/Detours">GitHub - microsoft/Detours</a></p>
</blockquote>
</li>
<li><p>获取目标进程中的PE结构，因为此时目标进程中许多数据结构没有初始化，需要自行搜索目标进程内存，对比属性为<code>MEM_IMAGE</code>的页映射是不是目标进程</p>
<blockquote>
<p>此时内存一般只有ntdll.dll和exe，前者一般都在靠后位置。或使用<code>ZwQueryInformationProcess()</code>API来查询PEB，其偏移0x8处就能得到exe的ImageBase了</p>
</blockquote>
</li>
<li><p>获取原IID大小，增加一项，直接从PE映射后的最后一个节的结束位置开始申请内存（加上标志<code>MEM_REVERSE</code>）存放新的IID</p>
</li>
<li><p>构造新IID项有关的OriginalFirstThunk、FirstThunk、Name有关结构</p>
</li>
<li><p>修正PE文件头，即输入表的虚拟偏移和大小</p>
<blockquote>
<p>修正之前用<code>VirtualProtectEx</code>将页属性修改位可写</p>
</blockquote>
</li>
<li><p>更新目标进程内存，继续运行主线程</p>
</li>
</ol>
<p><strong>输入表项dll替换法</strong></p>
<p>进程创建未完成之前，ntdll就已经加载了，任何R3下的劫持是无效的，其位于system32目录下。而kernel32.dll、msvcrtd.dll等则是进程创建完成、主线程初始化输入表时才载入的</p>
<p>加载DLL顺序</p>
<ol>
<li>注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>中的对象目录中查找（kernel32.dll）</li>
<li>正在加载DLL的进程的exe目录（程序位置）</li>
<li>系统目录<code>\WINDOWS\SYSTEM32</code>、<code>\WINDOWS\SYSTEM</code>、<code>\WINDOWS</code>（系统目录）</li>
<li>正在加载DLL的进程当前目录（运行位置）</li>
<li>PATH环境变量</li>
<li>系统报错，找不到</li>
</ol>
<p>一般都是将自己的dll改名后放在程序位置下，有必要才到注册表中删除替换。需要注意在自己的dll中导出原dll需要用到的导出函数</p>
<blockquote>
<p>工具AheadLib输入待劫持dll，输出劫持源代码</p>
</blockquote>
<h4 id="改变程序运行流程使其加载至dll"><a href="#改变程序运行流程使其加载至dll" class="headerlink" title="改变程序运行流程使其加载至dll"></a>改变程序运行流程使其加载至dll</h4><p>通常是改变线程EIP、创建新线程或修改目标进程内的某些代码，使其执行<code>LoadLibrary()</code>来执行目标dll</p>
<p><strong>远程线程注入</strong></p>
<p>经典思路：</p>
<ol>
<li><code>OpenProcess()</code>打开目标进程</li>
<li>用<code>VirtualAllocEx()</code>在远程进程的内存地址空间分配区域存放dll文件名，并用<code>WriteProcessMemory()</code>写入</li>
<li>使用<code>GetProcAddress(GetModuleHandle())</code>结合获取kernel32.dll下的<code>LoadLibrary()</code>函数地址</li>
<li>使用<code>CreateRemoteThread()</code>传入<code>LoadLibrary()</code>函数地址与前面写的内存中dll文件路径指针</li>
</ol>
<blockquote>
<p>需要目标进程的4个权限，<code>PROCESS_CREATE_THREAD</code>、<code>PROCESS_QUERY_INFORMATION</code>、<code>PROCESS_VM_OPERATION</code>、<code>PROCESS_VM_WRITE</code></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread function (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<p><strong>RtlCreateUserThread法</strong></p>
<p>原理同上，但是该函数一般用于创建特殊线程，不需要经过系统的验证登记，但是使用该函数需要自己结束自己</p>
<ol>
<li><p>打开目标进程，分配内存，写入shellcode</p>
<blockquote>
<p>shellcode中调用<code>ThreadProc</code>设置线程起始地址</p>
</blockquote>
</li>
<li><p>与前面3相同，获取ntdll.dll下的<code>RtlCreateUserThread()</code>地址</p>
</li>
<li><p>使用获取到的<code>RtlCreateUserThread</code>函数地址进行调用，传入shellcode地址及有关参数</p>
</li>
<li><p>线程创建失败<code>ResumeThread()</code>进行撤销</p>
</li>
</ol>
<p><strong>QueueUserApc/NtQueueAPCThread APC注入法</strong></p>
<p>APC即异步过程调用，是一种软件中断机制，当线程从等待状态苏醒时会检测是否有APC交付给自己，有的话就会执行这些APC过程（即函数）。</p>
<blockquote>
<p>线程调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx、WaitForSignalObjectEx函数时会进入到可唤醒状态</p>
</blockquote>
<p>APC包括两种：系统产生的内核模式APC、程序产生的用户模式APC。于是乎我们可以通过创建远程线程一样，使用<code>QueueUserAPC()</code>将我们的APC添加到目标线程的APC队列之中</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<p><strong>SetThreadContext法</strong></p>
<p>正在执行的线程被<code>SuspendThread()</code>暂停了——》线程环境上下文被保存——》<code>ResumeThread()</code>恢复线程执行——》线程从之前的eip开始执行。于是乎我们可以在目标进程暂停时，使eip指向我们的shellcode地址，在shellcode中先加载我们的dll，之后再跳回到原始的eip执行</p>
<ol>
<li><p>枚举目标进程中的线程，获取线程ID</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32first">Thread32First function (tlhelp32.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
</li>
<li><p>打开进程和线程，暂停线程</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">SuspendThread 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
</li>
<li><p>获取线程的CONTEXT，然后保存eip</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
</li>
<li><p>申请内存，写入shellcode</p>
</li>
<li><p>设置新的CONTEXT并恢复线程的执行</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext 函数 (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
</li>
</ol>
<p><strong>内核中通过hook/Notify干预执行流程</strong></p>
<p>基本操作同上，也是通过写入shellcode并修改CONTEXT</p>
<p><strong>内核KeUserModeCallback法</strong></p>
<p>win在加载全局钩子dll时，由win32k.sys调用<code>KeUserModeCallback()</code>回调user32.dll中的函数并最终调用<code>LoadLibraryExW()</code>实现的</p>
<ul>
<li><p>回调<code>user32.dll!_ClientLoadLibrary</code>加载dll，需要依赖user32.dll</p>
</li>
<li><p>user32.dll在加载时会填充“PEB-&gt;KernelCallbackTable”为“User32! ApfnDispatch”这个回调表地址，<code>KeUserModeCallback()</code>回调后会执行<code>ntdll!KiUserCallbackDispatcher</code>命令，该命令根据提供的ApiIndex从上面回调表地址中取出相应回调函数地址调用</p>
<blockquote>
<p>调用<code>KeUserModeCallback</code>的线程必须是目标进程内自己的用户线程</p>
</blockquote>
</li>
</ul>
<p><strong>纯WriteMemory</strong></p>
<p>修改现有线程的执行流程，不使用<code>SetThreadContext</code>而是在线程要执行的地方预先挖坑，线程执行到此处会转而执行shellcode，执行完再把坑填了，之后线程继续</p>
<ul>
<li>创建进程时注入dll：使用<code>CreateProcess()</code>以“CREATE_SUSPEND”标志创建进程后，进程内还有许多数据没有初始化，有以下几个位置<ul>
<li><code>ntdll!KiUserApcDispatcher</code></li>
<li><code>ntdll!ZwTestAlert</code></li>
<li>进程入口点</li>
</ul>
</li>
<li>将DLL注入运行中的进程：注入位置变成了一些调用频率比较高的API</li>
</ul>
<h4 id="利用系统机制加载DLL"><a href="#利用系统机制加载DLL" class="headerlink" title="利用系统机制加载DLL"></a>利用系统机制加载DLL</h4><p>定制一个基础服务模块，将其注册为系统服务模块，从而实现合法加载</p>
<p><strong>SetWindowHookEx消息钩子注入</strong></p>
<p><code>SetWindowsHookEx()</code>用于过滤特定类型消息的钩子</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookExA 函数 (winuser.h) - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<p>对于没有消息循环的纯后台程序没法</p>
<p><strong>AppInit_DLLs注册表注入</strong></p>
<p>加载user32.dll时，会调用一个<code>LoadAppDLLs()</code>函数，该函数会读取<code>HKEY_LOACL_MACHINE\Software\Mincrosoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs</code>，如果改注册表下登记的有dll就会主动加载，通常只能注入GUI程序</p>
<p><strong>输入法注入</strong></p>
<p>两种实现形式</p>
<ul>
<li>外挂式：通常是一个exe文件，只要启动就能在所有进程中使用，但兼容性不好</li>
<li>输入法接口式IME：是一个符合win输入法规范的dll。当目标进程切换到该输入法时，负责管理输入法的imm32.dll会加载这个IME模块</li>
</ul>
<p><strong>SPI网络过滤器注入</strong></p>
<p>SPI-服务提供者接口，是winsock2的特性，借助实现一个分层服务提供者对现有的传输服务提供者进行扩展，只要安装win就会自行加载</p>
<p>支持用户提供传输者、名称空间两种类型的服务提供者；支持用户开发基础服务提供者、分层服务提供者LSP两种类型的传输服务提供者</p>
<p>将LSP模块写好后，把要安装的SPI模块信息写到注册表位置下即可</p>
<p><strong>ShineEngine注入</strong></p>
<p>Windows兼容性模式实现引擎（Windows Shim Engine），即右键“属性”页面中的“兼容性”。该引擎通过修复有问题的API（旧版本）调用，来实现兼容，ntdll在初始化进程时会加载兼容性引擎的dll，默认是ShimEng.dll</p>
<p>自己编写时需要至少8个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VOID WINAPI <span class="title function_">SE_InstallBeforeInit</span><span class="params">(PUNICODE_STRING pusExecuteFileName, PVOID pShimData)</span>;</span><br><span class="line">BOOL WINAPI <span class="title function_">SE_InstallAfterInit</span><span class="params">(PUNICODE STRING pusExecuteFileName,</span></span><br><span class="line"><span class="params">PVOID pShimData)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_DLLLoaded</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrModuleLoaded)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_DLLUnloaded</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrModuleUnload)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_GetProcAddress</span><span class="params">(PVOID pvUnknown0)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_ProcessDying</span><span class="params">()</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_LdrEntryRemoved</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrEntryRemoved)</span>;</span><br><span class="line">VOID WINAPI <span class="title function_">SE_GetProcAddressLoad</span><span class="params">(PLDR_DATA_TABLE_ENTRY pLdrEntry)</span>;</span><br></pre></td></tr></table></figure>
<p>先以挂起方式启动进程，然后向PEB的偏移0x1E8（32位）处写入我们自己的引擎.dll的完整路径</p>
<p><strong>Explorer shell注入</strong></p>
<p>右键的快捷菜单：扩展模块一般是一个COM dll——》注册为shell扩展——》所有调用shell接口的进程都会加载该dll</p>
<h4 id="注入防范"><a href="#注入防范" class="headerlink" title="注入防范"></a>注入防范</h4><p><strong>驱动层防范</strong></p>
<ul>
<li><code>KeUserModeCallback</code>防全局消息钩子：对InputBuffer参数中的DLL路径进行合法检验</li>
<li><code>NtMapViewOfSection/LoadImageNotify</code>对模块进行验证：dll加载一般都是<code>LoadLibrary()</code>——》<code>ntdll!LdrLoadDL</code>实现——》调用<code>ntdll!NtMapViewOfSection</code>来将目标dll映射到当前进程中，可以对该系统服务进行SSDT hook</li>
<li>拦截进程打开、读写、创建远程进程、发送APC等操作：拦截关键API即可，这样除了创建进程时能够获取进程和主线程句柄，其他时候无法获取</li>
<li>Call Stack检测非法模块：注入进程一般离不开创建线程、申请内存、修改内存的操作。可以对这些敏感服务进行hook，检测用户态调用栈中是否存在非法模块</li>
</ul>
<p><strong>应用层防范</strong></p>
<ul>
<li>通过hook<code>LoadLibraryEx</code>函数防范全局钩子、输入法注入等</li>
<li>在DllMain中防御远程线程：通过栈回溯找到CONTEXT对线程起点进行检查</li>
<li>枚举并查找当前进程中非法模块和可疑内存：利用<code>GetMappedFileName()</code>API可以发现某个位置映射的PE文件</li>
<li>hook ntdll中的底层函数进行call stack检测</li>
</ul>
<h3 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h3><p>一种是修改数据进行hook（通常是引用的函数地址）——修改指针的值；另一类是直接修改函数内的指令进行hook——修改指针指向的内容的值</p>
<h4 id="Address-Hook"><a href="#Address-Hook" class="headerlink" title="Address Hook"></a>Address Hook</h4><p>通过修改数据进行hook的方法，被修改的数据一般是函数的地址。这类数据在执行过程中必定会成为eip，因此只要把地址替换为我们的函数地址就能获取程序控制权</p>
<p><strong>各类表中的地址</strong></p>
<ul>
<li><p>PE的IAT：作用范围只针对被hook的模块，必须在以静态链接方式调用的才能被hook</p>
</li>
<li><p>PE的EAT：EAT存放的是函数地址偏移，使用时需要加上模块基址</p>
</li>
<li><p>user32.dll的回调表：其中有个“USER32!apfnDispatch”的回调函数表，其中存放了各种用于GUI的回调函数，通常与内核中的<code>KeUserModeCallback()</code>相结合</p>
</li>
<li><p>IDT：系统的中断描述符表，中断发生时系统根据该表来选择处理方式。idtr寄存器存放IDT表基址，idtl存放表内项目数，每项在x86下8B大小，其中的中断处理例程叫ISR</p>
</li>
<li><p>SSDT和shadow ssdt：win上应用程序调用API后转入os内核处理，首先就要用到SSDT，表中存放了所有系统调用的地址。Shadow SSDT则是用于处理GUI服务的表<code>KeServiceDesceptorTableShadow</code></p>
</li>
<li><p>C++类的虚函数表：虚函数表VFT保存了基类的虚函数地址，当子类重载某个父类函数时，编译器就会用子类中该函数地址替换虚函数表中相应地址</p>
</li>
<li><p>COM接口的功能函数表：COM组件在二进制层面的接口统一，同一个COM接口的所有接口函数都放在一个表中（与VFT类似）</p>
</li>
</ul>
<p>特殊寄存器中的地址：windows使用MSR寄存器组中的<code>IA32_SYSENTER_EIP</code>的值作为内核调用的入口，当在ntdll中调用汇编指令<code>sysenter</code>进入内核时，CPU会首先执行到这里</p>
<h4 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h4><p>即直接修改指令的hook，关键是转移程序执行流程，一般使用<code>jmp</code>、<code>call</code>、<code>retn</code>等转移指令，主要有五种模式</p>
<ul>
<li>jmp xxxx（5字节）</li>
<li>push xxxxx/retn（6字节）：通过压栈返回实现跳转</li>
<li>mov eax,xxxx/jmp eax（7字节）：先将转移地址放入寄存器，再实现跳转</li>
<li>call hook（更换指令或输入表）</li>
<li>HotPatch Hook：一个短跳+长跳</li>
</ul>
<p>大致思路如下：</p>
<blockquote>
<p>TargetFun：待替换目标函数；DetourFun：用于替代的自定义函数；TrampolineFun：调用原函数的入口</p>
</blockquote>
<ol>
<li>确定hook方式以及需要在TrampolineFun中执行的指令（观察TargetFun开头的几条指令，据此选择机几字节跳转）</li>
<li>准备TrampolineFun函数，可以将函数原型设置为和TargetFun一样，以便调用</li>
<li>利用<code>memcpy()</code>或<code>WriteProcessMemory()</code>等函数将指令写入，需要注意地址偏移量</li>
<li>call back。如果原指令是E8-call则只需要重新计算新偏移后写入即可</li>
</ol>
<h4 id="其他hook与hook点位"><a href="#其他hook与hook点位" class="headerlink" title="其他hook与hook点位"></a>其他hook与hook点位</h4><ul>
<li>基于异常的hook</li>
</ul>
<p>在程序中安装自己的SEH处理过程，之后向被hook的位置写入一条会引发异常的指令（比如INT 3），此时引发访问异常，跳转到事先安装的异常处理过程</p>
<ul>
<li>不是hook的hook</li>
</ul>
<p>PE文件被感染，修改EntryPoint；各类回调机制；分层服务和过滤驱动模型</p>
<ul>
<li>hook位置挑选</li>
</ul>
<p>执行流：程序在某个调用过程中都执行了过哪些地方的哪些函数</p>
<p>hook的位置越早，更早更易获取控制权，但拦截范围有限，容易被绕过；位置越靠下，决定权越大，“流量越大”（调用频率高），对系统影响越大</p>
<p>应用层上：IAT hook和Inline Hook满足，内核中KiFastCallEntry和KeServiceDescriptorTable最合适</p>
<h4 id="Hook典型过程"><a href="#Hook典型过程" class="headerlink" title="Hook典型过程"></a>Hook典型过程</h4><p>不管是哪种hook都需要一个自定义的函数来代替被hook的函数，其原型、调用约定、返回值都需要与原函数一样</p>
<p><strong>Address hook</strong></p>
<p>IAT-Hook</p>
<ol>
<li>准备一个与被hook函数原型一致的函数指针使其指向原始函数</li>
<li><code>LoadLibrary</code>与<code>GetProcAddress</code>获取目标函数地址</li>
<li><code>ImageDirectoryEntryToData</code>获取待hook模块输入表起始地址</li>
<li>循环匹配模块名称，获取目标模块对应的地址表</li>
<li><code>VirtualQuery</code>与<code>VirtualProtect</code>将输入表所在页属性修改为可写</li>
<li>内存页属性修改成功后写入自己的API地址，之后恢复内存页属性</li>
</ol>
<p>虚函数-Hook</p>
<p>虚函数表在编译以后位于PE的rdata段，已经固定，需要注意</p>
<ol>
<li><p>确定被钩函数在类对应虚函数表中的位置及函数原型</p>
</li>
<li><p>定义“替换类”和“钩子类”</p>
</li>
<li><p>修改“替换类”的虚函数表，替换其成员函数的指针为“目标函数”的地址，之后修改“目标类”的虚函数表，替换其“目标函数”指针为“钩子类”中的钩子函数</p>
</li>
</ol>
<p>SSDT-Hook：和IAT-Hook相似，但是省去了逐项对比，因为可以靠服务索引直接获取</p>
<p><strong>二次hook</strong></p>
<p>即待hook的位置已经被hook了，对Address-hook没啥影响，但是对Inline-hook有以下几种处理</p>
<ul>
<li>不再对目标函数进行hook，容易导致蓝屏</li>
<li>直接替换原来的hook指令，用自己的jmp指令覆盖掉上一个hook的jmp指令。或者先恢复再hook</li>
<li>在目标函数中换位置</li>
<li>hook上一个hook过程的Detour函数。即我钩的目标函数是钩子函数，形成hook链</li>
</ul>
<blockquote>
<p>hook引擎：detours express、mhook、easyhook</p>
</blockquote>
<h4 id="Hook注意事项"><a href="#Hook注意事项" class="headerlink" title="Hook注意事项"></a>Hook注意事项</h4><ul>
<li>用法：检查参数、检查结果、拦截调用或下发、信息截获、安全防护、增强补丁</li>
<li>hook操作的多线程安全：待hook的位置处于不稳定状态时要避免影响其他线程（Address-hook不存在该问题，因为修改一个小于机器字长的数据是原子操作）<ul>
<li>避免所有可能执行到目标位置的操作。应用层将其他线程都suspend</li>
<li>使用CPU指令<code>lock xchg/cmpxchg</code></li>
</ul>
</li>
<li>Inline-hook指令碎屑，即覆盖的指令可能不完全，执行完后返回到这些不完整的指令，最好用nop进行填充</li>
<li>保存恢复现场：栈平衡、恢复寄存器值等。注意返回值</li>
<li>避免重入，即套娃现象，待hook的函数在Detours中也要用到。</li>
<li>x64下注意指针定义长度、内存对齐、PE格式的变动、调用约定的变化</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/Windows/">Windows</a><a class="post-meta__tags" href="/tags/Re/">Re</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/03/%E5%8A%A0%E8%A7%A3%E5%AF%862/" title="《加密与解密》读书笔记2"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《加密与解密》读书笔记2</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/05/%E6%B7%B1%E5%85%A5cpp/" title="《C++反汇编与逆向分析技术解密》读书笔记"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《C++反汇编与逆向分析技术解密》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/web.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zy0t1</div><div class="author-info__description">中二次元晚期</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zy0t1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zy0t1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wy1078041755@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62036500" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">调试篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">解密篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E7%89%88%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF"><span class="toc-number">3.0.1.</span> <span class="toc-text">演示版保护技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.0.2.</span> <span class="toc-text">加密算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">系统篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80"><span class="toc-number">4.1.</span> <span class="toc-text">windows内核基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%87%8D%E8%A6%81%E7%BB%93%E6%9E%84%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">4.2.</span> <span class="toc-text">内核重要结构！！！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.1.</span> <span class="toc-text">内核对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSDT"><span class="toc-number">4.2.2.</span> <span class="toc-text">SSDT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TEB-amp-PEB"><span class="toc-number">4.2.3.</span> <span class="toc-text">TEB&amp;PEB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Win%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">Win异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">异常处理基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SEH%E8%AF%B4%E6%98%8E"><span class="toc-number">4.3.2.</span> <span class="toc-text">SEH说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VEH%E5%90%91%E9%87%8F%E5%8C%96%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.3.3.</span> <span class="toc-text">VEH向量化异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.3.4.</span> <span class="toc-text">x64平台的异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Win32%E8%B0%83%E8%AF%95API"><span class="toc-number">4.4.</span> <span class="toc-text">Win32调试API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">4.4.1.</span> <span class="toc-text">相关函数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">代码注入进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VT%E6%8A%80%E6%9C%AF"><span class="toc-number">4.5.</span> <span class="toc-text">VT技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">PE文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88x86%EF%BC%89"><span class="toc-number">4.6.1.</span> <span class="toc-text">PE基本概念（x86）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MS-DOS%E5%A4%B4"><span class="toc-number">4.6.2.</span> <span class="toc-text">MS-DOS头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">4.6.3.</span> <span class="toc-text">PE文件头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97"><span class="toc-number">4.6.4.</span> <span class="toc-text">区块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%A1%A8"><span class="toc-number">4.6.5.</span> <span class="toc-text">输入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%BE%93%E5%85%A5"><span class="toc-number">4.6.6.</span> <span class="toc-text">绑定输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%A1%A8"><span class="toc-number">4.6.7.</span> <span class="toc-text">输出表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.6.8.</span> <span class="toc-text">基址重定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">4.6.9.</span> <span class="toc-text">资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">4.6.10.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF"><span class="toc-number">4.7.</span> <span class="toc-text">注入技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B2%E9%A2%84%E8%BE%93%E5%85%A5%E8%A1%A8"><span class="toc-number">4.7.1.</span> <span class="toc-text">干预输入表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%BD%BF%E5%85%B6%E5%8A%A0%E8%BD%BD%E8%87%B3dll"><span class="toc-number">4.7.2.</span> <span class="toc-text">改变程序运行流程使其加载至dll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BDDLL"><span class="toc-number">4.7.3.</span> <span class="toc-text">利用系统机制加载DLL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E9%98%B2%E8%8C%83"><span class="toc-number">4.7.4.</span> <span class="toc-text">注入防范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook%E6%8A%80%E6%9C%AF"><span class="toc-number">4.8.</span> <span class="toc-text">Hook技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Address-Hook"><span class="toc-number">4.8.1.</span> <span class="toc-text">Address Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inline-Hook"><span class="toc-number">4.8.2.</span> <span class="toc-text">Inline Hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96hook%E4%B8%8Ehook%E7%82%B9%E4%BD%8D"><span class="toc-number">4.8.3.</span> <span class="toc-text">其他hook与hook点位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook%E5%85%B8%E5%9E%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">4.8.4.</span> <span class="toc-text">Hook典型过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.8.5.</span> <span class="toc-text">Hook注意事项</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Zy0t1</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>