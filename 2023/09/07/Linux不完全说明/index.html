<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux不完全说明 | Zy0t1's blog</title><meta name="author" content="Zy0t1"><meta name="copyright" content="Zy0t1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础说明外加一些内核介绍，说明部分还是推荐《鸟哥的Linux私房菜》">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux不完全说明">
<meta property="og:url" content="http://zy0t1.github.io/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/index.html">
<meta property="og:site_name" content="Zy0t1&#39;s blog">
<meta property="og:description" content="基础说明外加一些内核介绍，说明部分还是推荐《鸟哥的Linux私房菜》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp">
<meta property="article:published_time" content="2023-09-07T03:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T08:19:16.904Z">
<meta property="article:author" content="Zy0t1">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp"><link rel="shortcut icon" href="/img/web.png"><link rel="canonical" href="http://zy0t1.github.io/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux不完全说明',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-08 16:19:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/web.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Zy0t1's blog"><span class="site-name">Zy0t1's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux不完全说明</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-07T03:00:00.000Z" title="发表于 2023-09-07 11:00:00">2023-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T08:19:16.904Z" title="更新于 2024-08-08 16:19:16">2024-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux不完全说明"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<p>linux广义上代指一类操作系统，狭义上指内核，下面是一些常见的发行版（=打包(内核+软件)）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系</th>
<th>OS</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arch</td>
<td><a target="_blank" rel="noopener" href="https://archlinux.org">Arch</a>、manjaro</td>
<td>定制化高，适合折腾</td>
</tr>
<tr>
<td>RedHat</td>
<td>RHEL、<a target="_blank" rel="noopener" href="https://www.centos.org">CentOS</a>、<a target="_blank" rel="noopener" href="https://www.fedoraproject.org/zh-Hans/">Fedora</a></td>
<td>好用，但有些收费</td>
</tr>
<tr>
<td>Debian</td>
<td><a target="_blank" rel="noopener" href="https://bits.debian.org">debian</a>、<a target="_blank" rel="noopener" href="https://cn.ubuntu.com/about">ubuntu</a>、<a target="_blank" rel="noopener" href="https://linuxmint.com">Mint</a>、<a target="_blank" rel="noopener" href="https://www.deepin.org/index/zh">deepin</a>、<a target="_blank" rel="noopener" href="https://www.kali.org/features/">Kali</a></td>
<td>大众化，免费</td>
</tr>
<tr>
<td>SUSE</td>
<td><a target="_blank" rel="noopener" href="https://www.opensuse.org">openSUSE</a></td>
<td>针对企业，配置稍复杂，国内少</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>ctrl+alt+t(快速打开终端)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt list(列举)</span><br><span class="line">	upgrade  包名(升级)</span><br><span class="line">	autoremove 包名(移除但不包括相关配置)</span><br><span class="line">	--purge remove  包名(包括相关配置)</span><br><span class="line"><span class="built_in">exit</span>(退出)</span><br><span class="line"><span class="built_in">sudo</span>(管理员)</span><br><span class="line"><span class="built_in">echo</span><span class="string">&quot;要显示的内容&quot;</span></span><br><span class="line"><span class="built_in">kill</span> PID/进程名</span><br><span class="line">ping</span><br><span class="line"><span class="built_in">history</span>(使用过的命令)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>日常没什么用？：<code>date</code>显示日期、<code>cal</code>显示日历、<code>bc</code>简单计算器-交互式、<code>uname</code>-查看本机信息、<code>pwd</code>-当前绝对路径</p>
</li>
<li><p>文件<strong>权限属性</strong>配置：<code>chgrp</code>-改属组、<code>chown</code>-改属主、<code>chmod</code>-变权限、<code>umask</code>-设置默认权限、<code>chattr</code>-设置隐藏属性、<code>lsattr</code>-查看隐藏属性</p>
<blockquote>
<p>文件创建默认666，目录默认777。<code>umask</code>指令后跟要减掉的权限</p>
</blockquote>
</li>
<li><p><strong>文件目录操作</strong>：<code>cd</code>-换目录、<code>ls</code>-检视、<code>cp</code>-复制、<code>rm</code>-删除、<code>mv</code>-移动或改名、<code>mkdir</code>-创建目录、<code>rmdir</code>-删除空目录、<code>touch</code>-修改创建文件</p>
</li>
<li><p>文件内容查阅：<code>cat</code>-第一行开始全部显示、<code>tac</code>-最后一行开始、<code>more/less</code>-页单位显示、<code>head/tail</code>-只看头或尾、<code>od</code>-二进制查看、<code>nl</code>-带行号显示、<code>file</code>-观察文件类型</p>
</li>
<li><p>关机有关指令：<code>shutdown</code>=<code>systemctl</code>+<code>reboot</code>,<code>halt</code>,<code>poweroff</code>；数据同步写入盘中<code>sync</code></p>
</li>
<li><p>文本编辑器：<code>nano</code>、<code>vi</code>、<code>vim</code></p>
<blockquote>
<p>vim：i(进入编辑模式),ESC(退出编辑模式),:(开启命令模式)<br>:q(离开，并不保存) :q!(强制离开不储存) :w(写入) :w!(强制写入，但与权限有关)可配合使用</p>
</blockquote>
</li>
<li><p>求助工具：<code>man</code>一次全显示，<code>info</code>页显示；<code>/usr/share/doc/</code>存放软件信息；<code>xx -h</code></p>
<blockquote>
<p>man中表格第一行，数字-意义：1-可执行文件；3-大多为C函数库；4-设备文件或文件格式；5-配置文件；8-root可用命令；9-与内核相关</p>
</blockquote>
</li>
<li><p>搜索指令：<code>which</code> 寻找可执行文件、<code>whereis</code>、<code>locate</code>、 <code>find</code>根据文件名寻找</p>
<blockquote>
<p>locate使用本地数据库查找/var/lib/mlocate，updatedb指令会读取/etc/updatedb.conf来更新该数据库。whereis仅在指定目录下查找内容，-l列出查找列表。find全盘寻找</p>
</blockquote>
</li>
<li><p><strong>GCC</strong>工具链 = gcc(编译) + cpp(预处理) + as(处理汇编) + ld(链接)+make(构建)</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc [参数] [相关文件名称，可多个] -o [生成文件名称]</span><br><span class="line">gcc hello.c -o hello或hello.out---------------------(一步到位)</span><br><span class="line">1.预处理：gcc -E hello.c -o test.i---------------------(加入头文件)</span><br><span class="line">2.编译：gcc -S test.i -o test1.s-----------------------(生成汇编文件)</span><br><span class="line">3.汇编：gcc -c test1.s -o hello.o----------------------(生成目标文件)</span><br><span class="line"><span class="comment">#ps：在此.o或.obj文件中存放着ELF格式的代码，最接近机器语言</span></span><br><span class="line">4.链接器ld链接生成可执行程序：gcc hello.o -o hello-----------(与其他文件链接)</span><br><span class="line">5.运行：在目标执行文件目录下./hello或hello.out</span><br><span class="line"><span class="comment">#ps：不写生成文件名就会默认a.out；在win平台下中间相同，但生成.exe</span></span><br></pre></td></tr></table></figure>
<ul>
<li>正则表达式（方便bash下使用）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^[a-z0-9] + abc$ //以a-z或0-9开头，以abc结尾的字符串</span><br><span class="line">[^abc]	//匹配字符串中所有的除abc外的东西，包括空格</span><br><span class="line">.	//匹配除换行符外的任何</span><br><span class="line">\w数字，字母下划线、\f换页、\n换行、\r回车、\s匹配所有空白包括换行、\S匹配非空白、\t制表符、\v垂直制表符</span><br><span class="line">*零次或多次、+一次或多次、|表示或、？零次或一次、\转义字符，后跟大小中括号</span><br><span class="line">修饰符</span><br><span class="line">/xxx/i	//不区分大小写</span><br><span class="line">~~~/g	//所有匹配的</span><br><span class="line">~~~/m	//搭配边界字符^与$配合所有行</span><br><span class="line">~~~./s	//在原基础上还需匹配换行符</span><br></pre></td></tr></table></figure>
<h3 id="文件-amp-目录-amp-群组"><a href="#文件-amp-目录-amp-群组" class="headerlink" title="文件&amp;目录&amp;群组"></a>文件&amp;目录&amp;群组</h3><p>一切皆文件：在Linux下文件的识别执行仅与[-rwxrwxrwx]有关，后缀无关</p>
<ul>
<li>正规文件：纯文本文件ASCII（给人读的）、二进制文档（执行的）、数据格式文件（软件用的）</li>
<li>目录-d、链接文件-l（硬链接与软链接）</li>
<li>设备与设备文件：区块设备文件-b（内存硬盘等）、字符设备文件-c（鼠标键盘等）</li>
<li>数据接口文件-s：用于网络上的数据承接（常出现于/run或/tmp下）</li>
</ul>
<p><img src="https://s2.loli.net/2024/08/08/QJ41jHhu5cL3pGY.jpg" alt="Linux.jpg"></p>
<ul>
<li>/sbin、/usr/sbin、/usr/local/sbin（指令）：管理员可以使用的可执行命令；</li>
<li>/bin——————（指令）：存放shell解释器，给普通用户使用的命令；</li>
<li>/root—-（账户/指令）：系统管理员的目录；</li>
<li>/home-（账户）：用户目录，新增用户时会在此文件下新建；</li>
<li>/usr——-（账户）：应用程序存放位置<ul>
<li>/bin：应用程序；</li>
<li>/share：多用户共享数据；</li>
<li>/lib：库函数文件；</li>
<li>/local：软件升级包；</li>
<li>/src：内核源代码；</li>
</ul>
</li>
<li>/boot——（系统必要）：系统内核and引导装载文件；</li>
<li>/etc———（系统必要）：存放系统的部分配置文件and子目录列表；</li>
<li>/sys———（系统必要）：虚拟档案系统，类似/proc；</li>
<li>/lib、/lib32、64、x32（系统必要）：动态链接资源库；</li>
<li>/dev———（外部文件）：存放设备文件，即驱动、网卡等；</li>
<li>/mnt——-（外部文件）：文件系统挂载；</li>
<li>/media—（外部文件）：其他设备挂载，U盘等；</li>
<li>/proc——-（运行过程）：该目录中的数据都在内存中，即内存的映射！；</li>
<li>/var———-（运行过程）：存放系统运行过程中经常变化的文件；</li>
<li>/lost+found—（临时）：系统非法关机后会有内容，否则为空；</li>
<li>/run——————-（临时）：系统启动临时文件；</li>
<li>/tmp——————（临时）：系统运行临时文件；</li>
<li>/srv（扩展）：服务启动后要访问的数据目录，部署服务器后有内容；</li>
<li>/opt（扩展）：额外安装的软件；</li>
</ul>
<h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>Linux下的可执行文件，全称<strong>Executable and Linking Format</strong>，elf文件相关定义在<code>/usr/include/elf.h</code>中，有32位和64位版本，区别仅在于部分成员大小不一样，内容如下：</p>
<ul>
<li>包括.out &amp; .o &amp; .so &amp; .elf &amp; .prx文件；readelf，启动！！！</li>
<li>.out/可执行文件：包含代码和数据（有相对固定地址），可直接运行，系统根据地址加载到内存执行</li>
<li>.o/可重定位文件：包含基础代码和数据，而且都没有指定地址，需要与其他文件配合使用</li>
<li>.so/共享目标文件：也叫动态库文件，包含代码与数据，是在原程序运行时动态链接的</li>
<li>详见！！！<a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf">Understanding_ELF.pdf (seebug.org)</a></li>
</ul>
<p>相关概念如下：</p>
<ul>
<li>目标文件：可重定位目标文件（汇编器生成的）、可执行目标文件、共享目标文件（链接器+加载器都用，同时具有ScHead和ProHead）；</li>
<li><p>动态链接：是解析符号引用的过程，在进程初始化和运行期间都可能发生</p>
</li>
<li><p>链接器：以目标文件为输入，经过符号解析（目标文件中的符号和其定义进行关联）与重定位（将符号的定义与在内存中的位置关联），输出可加载和运行的可执行目标文件。不看程序头表</p>
</li>
<li>加载器：用于加载可执行文件到内存，看不见节头表，将节换为段</li>
<li>程序解析器：系统执行程序时，系统函数 exec(BA_OS)会被调用，内核会去读取该程序的某一节，解析出其包含的ELF 程序解析器的路径字符串。有的话，解析器程序将从系统手中接过控制权继续执行，读取并映射可执行程序的段到内存中，有些则直接将文件内容载入内存</li>
</ul>
<p>根据链接和运行时的角度，其文件格式稍有不同（实际上除了ELF文件头外，位置都不固定）：</p>
<p><img src="https://s2.loli.net/2024/08/08/TvNhMSLPYWJFG6g.png" alt="elf.png"></p>
<p>大致包括四部分：ELF头（ELF header)、程序头表（Program header table)、节（Section)OR段（Segment）、节头表（Section header table)OR段头表</p>
<p><strong>ELF文件头</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];	<span class="comment">//魔数,16Byte,见下表</span></span><br><span class="line">    Elf32_Half    e_type;         <span class="comment">//文件类型</span></span><br><span class="line">  	Elf32_Half    e_machine;      <span class="comment">//架构</span></span><br><span class="line">  	Elf32_Word    e_version;      <span class="comment">//目标文件版本</span></span><br><span class="line">  	Elf32_Addr    e_entry;        <span class="comment">//程序的入口虚拟地址</span></span><br><span class="line">  	Elf32_Off	  e_phoff;        <span class="comment">//程序头表的偏移量，木有则为0</span></span><br><span class="line">  	Elf32_Off 	  e_shoff;        <span class="comment">//节头表开始在文件中的偏移量，同上</span></span><br><span class="line">  	Elf32_Word    e_flags;        <span class="comment">//处理器特定标志位</span></span><br><span class="line">  	Elf32_Half    e_ehsize;       <span class="comment">//ELF头字节大小</span></span><br><span class="line">  	Elf32_Half    e_phentsize;    <span class="comment">//程序头表中每一个表项的字节大小</span></span><br><span class="line"> 	Elf32_Half    e_phnum;        <span class="comment">//程序头表中共有多少个表项</span></span><br><span class="line"> 	Elf32_Half    e_shentsize;    <span class="comment">//节头表字节大小</span></span><br><span class="line">  	Elf32_Half    e_shnum;        <span class="comment">//节头表表项数目</span></span><br><span class="line">  	Elf32_Half    e_shstrndx;     <span class="comment">//一个节头表项的索引,该项指向存储&quot;节名字表&quot;,没有就设为&quot;SHN_UNDEF&quot;</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>偏移</th>
<th>内容</th>
<th>偏移</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-3</td>
<td>0x7f+”ELF“</td>
<td>4</td>
<td>0非法文件,1代表32位,2代表64位</td>
</tr>
<tr>
<td>5</td>
<td>0非法编码,1小端,2大端</td>
<td>6</td>
<td>ELF文件头版本,通常为1</td>
</tr>
<tr>
<td>7-15</td>
<td>暂未使用</td>
<td>16</td>
<td>本数组大小</td>
</tr>
</tbody>
</table>
</div>
<p><strong>程序头表</strong>：提供程序加载到内存中的段信息，为数组结构，每一项结构如下（一个段包含1个或多个节）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elf32_Word    p_type;         <span class="comment">//本段的类型</span></span><br><span class="line">  Elf32_Off 	p_offset;       <span class="comment">//偏移位置</span></span><br><span class="line">  Elf32_Addr    p_vaddr;        <span class="comment">//本段应加载的虚拟地址</span></span><br><span class="line">  Elf32_Addr    p_paddr;        <span class="comment">//加载物理地址,根据系统选择</span></span><br><span class="line">  Elf32_Word    p_filesz;       <span class="comment">//本段在文件中大小</span></span><br><span class="line">  Elf32_Word    p_memsz;        <span class="comment">//本段在内存中的大小</span></span><br><span class="line">  Elf32_Word    p_flags;        <span class="comment">//本段内容属性,系统会根据此段赋予一定权限</span></span><br><span class="line">  Elf32_Word    p_align;        <span class="comment">//为0/1时则虚拟地址和偏移没有对齐要求,否则表示对其要求2的次方</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
<p><strong>节头表</strong>：同上，也是数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Elf32_Word    sh_name;        <span class="comment">//节的名称,其值为&quot;节名字表&quot;中的偏移</span></span><br><span class="line">  Elf32_Word    sh_type;        <span class="comment">//节的类型</span></span><br><span class="line">  Elf32_Word    sh_flags;       <span class="comment">//本节的属性,1运行时可写,2运行时占用内存单元,4指令</span></span><br><span class="line">  Elf32_Addr    sh_addr;        <span class="comment">//本节内容需要映射的起始地址</span></span><br><span class="line">  Elf32_Off 	sh_offset;      <span class="comment">//本节相对于文件开头的偏移量</span></span><br><span class="line">  Elf32_Word    sh_size;        <span class="comment">//本节大小,字节</span></span><br><span class="line">  Elf32_Word    sh_link;        <span class="comment">//指向节头表中本节的位置</span></span><br><span class="line">  Elf32_Word    sh_info;        <span class="comment">//附加信息</span></span><br><span class="line">  Elf32_Word    sh_addralign;   <span class="comment">//对齐方式,同上</span></span><br><span class="line">  Elf32_Word    sh_entsize;     <span class="comment">//有些节内容为一张表,该项指定节中每一表项的大小,为0代表不是表格</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p><strong>节</strong>：专用于链接过程（也就是没有执行时）。.开头的都是系统保留的，当然也可以自己插入自定义的段<code>objcopy</code>工具可以将图片、音乐之类的作为段插入到目标文件中。此外gcc提供了一个扩展机制，使得程序员可以指定变量所处的段<code>__attribute__((section(&quot;hah&quot;)))</code>，变量前加上此扩展可以把对应的变量放到对应的段，下面是一些常见的段：</p>
<ul>
<li>.data段保存已初始化的全局静态变量和局部静态变量</li>
<li>.rodata存放只读数据，包括但不限于格式化字符串，const关键字修饰的变量</li>
<li>.bss存放未初始化的全局变量和局部静态变量（仅在装载时占用空间）</li>
<li>.plt和.got动态链接的跳转表和全局入口表</li>
<li>.init和.fini程序的初始化与终结代码段</li>
<li>.debug调试信息。gcc的-g参数用于加上调试信息，会最终多出来一个debug段，<code>strip</code>可以去除ELF文件中的调试信息。ELF采用DWARF标准的调试信息格式，微软采用CodeView标准。</li>
<li><p>.line包含调试符号的行号，即源代码行号编译后指令的对应表</p>
</li>
<li><p>.text程序指令代码；.rel.text代码段的重定位表</p>
</li>
<li><p>其他链接相关：.dynamic动态链接信息；.dynstr动态链接的字符串；.dynsym动态链接符号表；.relname重定位信息；</p>
</li>
<li><p>其他：.comment存放编译器版本控制信息；.note注释节；</p>
</li>
<li><p>字符串相关：.hash符号哈希表，帮助查找符号；.interp包含ELF程序解析器的路径名；.shstrtab节名字表；.symtab符号表；.strtab字符串表，存储ELF文件中用到的各种字符串；</p>
<blockquote>
<p><code>nm</code>、<code>objdump</code>、<code>readelf</code>查看符号表。<code>ldd xx</code>可以查看目标依赖于哪些共享库</p>
</blockquote>
</li>
</ul>
<p><strong>字符串表</strong>：包含若干以”null”结尾的字符串，第一个字符串为空串，用于表示”NULL”，该表不一定只有一个，节名字表也类似结构（索引指向开头，直到’\0’出现）。</p>
<p>以上面这个25字节的表为例子：包含0-null、1-name.、7-Variable、11-able、16-able、24-null</p>
<p><strong>符号表</strong>：用于定位和重定位程序中的符号定义和引用，下面是一项的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">	Elf32_Word st_name;		<span class="comment">//符号名字,是一个指向字符串表的索引值,0代表没名字</span></span><br><span class="line">	Elf32_Addr st_value; 	<span class="comment">//符号的值,没有固定类型</span></span><br><span class="line">	Elf32_Word st_size; 	<span class="comment">//符号大小,即字节数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> st_info; 		<span class="comment">//符号类型属性</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> st_other; 	<span class="comment">//暂未使用,0</span></span><br><span class="line">	Elf32_Half st_shndx; 	<span class="comment">//索引值,指向相关联的节在节头表中的位置</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p><strong>重定位信息</strong>：比如函数名，就代表跳转到该段程序入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">	Elf32_Addr r_offset;		<span class="comment">//对重定位文件来说是节中的字节偏移量,对.out和.so来说是虚拟地址</span></span><br><span class="line">	Elf32_Word r_info; 		<span class="comment">//重定位作用的符号表索引</span></span><br><span class="line">	Elf32_Sword r_addend;		<span class="comment">//在Elf32_Rela中有,用于计算需要重定位的域值</span></span><br><span class="line">&#125; Elf32_Rel(a);</span><br></pre></td></tr></table></figure>
<p><strong>段</strong>：有若干节构成，存在于装载（目标文件载入内存）和动态连接（解析目标文件中的符号引用）过程中</p>
<p>代码段/文本段：.text、.rodata、.hash、.dynsym、.dynstr、.plt、.rel.got</p>
<p>数据段：.data、.dynamic、.got、.bss</p>
<p>注释段/注释节：用于给其他程序检查目标文件的一致性和兼容性</p>
<p>动态段：提供给动态链接器所需要的信息</p>
<h3 id="内核介绍"><a href="#内核介绍" class="headerlink" title="内核介绍"></a>内核介绍</h3><p>宏/单内核特点（Linux）：</p>
<ul>
<li>内部分多个模块，但运行时是个单独的二进制大映像</li>
<li>内核程序以内核空间的身份运行</li>
<li>模块间通讯直接调用其他模块中的函数</li>
<li>安全性差、占用资源多</li>
</ul>
<p>微内核（minix、鸿蒙、L4）：</p>
<ul>
<li>大部分内核都作为单独的进程在特权状态下运行，消息传递进行通讯</li>
<li>微内核部分=消息转发站；</li>
<li>通讯开销大、硬件访问慢-驱动用户态下运行</li>
</ul>
<p>混合内核（Mac、Win）：</p>
<ul>
<li>让微内核结构中的一些运行在用户空间的代码跑在内核空间</li>
</ul>
<p>Linux6.5：RISC-V 64、Rust、WiFi-7、USB4.2、CPU并行启动</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内核文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/arch</td>
<td>支持的体系结构</td>
</tr>
<tr>
<td>/document</td>
<td>说明文档</td>
</tr>
<tr>
<td>/drivers</td>
<td>系统中的主要驱动设备</td>
</tr>
<tr>
<td>/fs</td>
<td>支持的文件系统和文件操作</td>
</tr>
<tr>
<td>/include</td>
<td>其下/linux包含一些关键数据结构</td>
</tr>
<tr>
<td>/init</td>
<td>内核初始化代码</td>
</tr>
<tr>
<td>/ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>/Kernel</td>
<td>内核管理核心代码</td>
</tr>
<tr>
<td>/lib</td>
<td>核心库代码</td>
</tr>
<tr>
<td>/mm</td>
<td>内存管理代码</td>
</tr>
<tr>
<td>/net</td>
<td>网络功能，实现常见的网络协议</td>
</tr>
<tr>
<td>/scripts</td>
<td>配置内核的脚本</td>
</tr>
<tr>
<td>/block</td>
<td>块设备驱动I/O调度的代码</td>
</tr>
<tr>
<td>/crypto</td>
<td>常见加密、压缩、校验算法</td>
</tr>
<tr>
<td>/security</td>
<td>SELinux模块代码</td>
</tr>
<tr>
<td>/sound</td>
<td>音频设备驱动</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>内存管理：/mm<br>4KB的内存页，并采用页缓存技术（基数树管理页缓存中包含的页）；<br>三级页表=偏移1、2、3+页内偏移（页目录、中间页目录、页表、物理页帧）</p>
</li>
<li><p>进程调度：/kernel+/arch<br>生命周期、优先级、共享CPU、多处理器下的负载均衡</p>
</li>
<li><p>进程间通信：/ipc<br>管道、共享内存、消息队列、套接字、信号</p>
</li>
<li><p>虚拟文件系统VFS：/fs<br>为Ext文件系统提供一个通用的抽象接口</p>
</li>
<li><p>网络堆栈：/net<br>在TCP上有个Socket层，是网络子系统的标准API，为各种网络协议提供接口</p>
</li>
<li><p>设备驱动程序：/drivers<br>支持特定设备的运转</p>
</li>
<li><p>体系架构：/arch</p>
</li>
<li><p>系统调用接口SCI：/kernel+/arch，内核提供的来让用户态转为内核态</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_26227857/article/details/44244433">系统调用表</a></p>
</blockquote>
</li>
</ul>
<p>关键数据结构</p>
<ul>
<li>Task_struct（进程结构）：<code>/include/linux/sched.h</code></li>
<li>Linux_binprm（二进制代码装入）：<code>/include/linux/binfmts.h</code></li>
<li>Super_block（超级块）：<code>/include/linux/fs.h</code></li>
<li>Inode（索引节点）：<code>/include/linux/fs.h</code></li>
<li>File（文件）：<code>/include/linux/fs.h</code></li>
<li>Dentry（目录项）：<code>/include/linux/dcache.h</code></li>
<li>SK_buff（套接字缓冲区）：<code>/include/linux/skbuff.h</code></li>
<li>Net_device（网络设备）：<code>/include/linux/netdevice.h</code></li>
<li>Kern_ipc_perm（ipc的消息队列）：<code>/include/linux/ipc.h</code></li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>目标：地址独立、地址保护</p>
<p>管理内容：内存初始化、页表的管理、页面分配器、小块内存分配器、vmalloc机制、虚拟内存管理、缺页中断、页面回收</p>
<p>内存初始化：</p>
<ul>
<li>内核启动页表<code>arch/x86/kernel/head.s</code></li>
<li>内存初始化<code>init/main.c</code>的<code>static void __init mm_init(void)</code></li>
<li>对于32位linux采用2级页表，64位则采用4级页表</li>
</ul>
<p>物理内存空间管理：</p>
<ul>
<li><p>数据结构：设置了一个mem_map[]数组管理内存页面page，其在系统初始化时由free_area_init()函数创建。数组元素是page结构体，每个page结构体对应一个物理页面。</p>
<blockquote>
<p>page定义在<code>/include/linux/mm_types.h</code>；mem_map[]定义在<code>mm/page_alloc.c</code></p>
</blockquote>
</li>
<li><p>Buddy/伙伴算法：对空闲空间管理，mm/page_alloc.c中实现 </p>
</li>
<li>Slab算法：面向对象管理，适合于小块内存的申请，减少了内部碎片</li>
</ul>
<p>虚拟地址空间管理：</p>
<ul>
<li>进程虚拟空间分为内核区和用户区</li>
<li>/include/linux/mm_types.h中<code>mm_struct</code>定义了每个进程的虚存用户区</li>
<li>/include/linux/mm.h定义的<code>vm_area_struct</code>为上述虚存用户区的中单独的虚拟区域结构</li>
<li>/mm/mmap.c中的<code>do_mmap()</code>完成执行映像向虚存区域的映射，建立有关的虚存区域</li>
</ul>
<p>请页机制：相关处理函数<code>do_page_fault()</code></p>
<ul>
<li>缺页异常：malloc/mmap首次申请、代码段首次映射地址空间、内存不足发生页交换、栈不够、访问非法地址</li>
<li><p>没有访问权限：copy on write、程序错误被杀</p>
</li>
<li><p>发生过程：</p>
<ol>
<li>在内存中有空闲物理页面时，分配一物理页帧，转第5步；</li>
<li>依据页面置换算法选择将被替换的物理页帧F，对应逻辑页Q；</li>
<li>如Q被修改过，则把它写回外存；</li>
<li>修改Q的页表项中驻留位置为0；</li>
<li>将需要访问的页P装入到物理页面F；</li>
<li>修改p的页表项驻留位为1，物理页帧号为f；</li>
<li>重新执行产生缺页的指令</li>
</ol>
</li>
</ul>
<p>交换机制：通过将磁盘上一部分空间作为交换空间，当物理内存不足时，将一部分暂不用的数据换入到交换空间中，来解决内存不足的问题。守护进程<code>kswapd()</code></p>
<p>缓冲机制：采用页面高速缓存（加快对磁盘文件的访问）、缓冲区高速缓存（针对I/O）、交换区缓存</p>
<p>常用内存分配函数:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>分配原理</th>
<th>最大内存</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_get_free_pages()</code></td>
<td>直接对页框进行操作</td>
<td>4MB</td>
<td>适用于分配较大量的连续物理内存</td>
</tr>
<tr>
<td><code>kmem_cache_alloc()</code></td>
<td>基于slab机制实现</td>
<td>128KB</td>
<td>适合需要频繁申请释放相同大小内存块时使用</td>
</tr>
<tr>
<td><code>kmalloc()</code></td>
<td>基于kmem_cache_alloc实现</td>
<td>128KB</td>
<td>最常见的分配方式，需要小于页框大小的内存时使用</td>
</tr>
<tr>
<td><code>vmalloc()</code></td>
<td>建立非连续物理内存到虚拟地址的映射</td>
<td></td>
<td>物理不连续，适合需要大内存，但对地址连续性没有要求的场合</td>
</tr>
<tr>
<td><code>alloc_bootmem()</code></td>
<td>在启动kernel时，预留一段内存，内核看不见</td>
<td></td>
<td>小于物理内存大小，内存管理要求较高</td>
</tr>
<tr>
<td><code>Ioremap()</code></td>
<td>实现已知物理地址到虚拟地址的映射</td>
<td></td>
<td>适用于物理地址已知的场合，如设备驱动</td>
</tr>
<tr>
<td><code>dma_alloc_coherent</code></td>
<td>基于_alloc_pages实现</td>
<td>4MB</td>
<td>适用于DMA操作</td>
</tr>
</tbody>
</table>
</div>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程=执行的程序，由程序段+相关数据段+PCB（进程控制块）组成实体/进程映像。具有如下特性：动态性（有生命周期）、并发性（可多个实体同存）、独立性（独立运行）、异步性（各自推进）</p>
<p>进程初始化过程：</p>
<ol>
<li>创建进程控制块，并将其加入到进程表中；</li>
<li>分配该进程所需资源；</li>
<li>设置进程初始状态，如运行态、等待态等；</li>
<li>加载到内存中，进行重定位给操作；</li>
<li>为程序设置栈空间，将参数、环境变量等数据拷贝到栈中；</li>
<li>启动开始函数；</li>
</ol>
<p>进程创建过程如下：</p>
<p><img src="https://s2.loli.net/2024/08/08/dOhI1EHlvS26T8u.png" alt="fork.png"></p>
<ul>
<li>vfork函数：父进程会一直阻塞，直到子进程调用exit()或者exec()为止；且父子共享地址空间，如果子进程修改了某个变量，这将影响到父进程</li>
<li>clone函数：不仅可以创建进程或者线程，还可以指定创建新的命名空间、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li>
<li>do_fork函数（/kernel/fork.c）,copy_process函数（主要用于创建子进程的描述符与相关数据结构）</li>
<li>内核级线程创建API<code>kthread_create</code>、<code>kthreat_run</code>最终也是调用do_fork实现</li>
</ul>
<p><strong>0号进程</strong>/idle进程/swapper进程：Linux内核初始化阶段从无到有创建的一个内核线程，在/include/linux/init_task.h，所有进程的父进程</p>
<p><strong>1号进程</strong>/init进程：由idle通过kernel_thread创建，在内核空间完成初始化函数start_kernel后, 加载init程序，完成系统的初始化</p>
<p><strong>2号进程</strong>/kthreadd进程：由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理</p>
<p>进程状态：创建态、就绪态、执行态、阻塞态、终止态；</p>
<p>进程终止：</p>
<ul>
<li>主动：main函数返回，链接程序自动添加exit()；主动调用exit()</li>
<li>被动：收到一个不能处理的信号、产生了异常、收到SIGKILL等终止信号</li>
<li>exit()系统调用把退出码转换成内核要求的格式并且调用do_exit()函数来处理</li>
</ul>
<p>进程调度：调度策略大致分为非实时和实时调度策略</p>
<ul>
<li>非实时：SCHED_NORMAL（使用CFS调度器来调度运行）、SCHED_BATCH（CFS调度器。采用分时策略，根据动态优先级分配）、SCHED_IDLE（CFS调度器。适用于优先级较低的后台任务）</li>
<li><p>实时：SCHED_FIFO（先进先出）、SCHED_RR（时间片轮转，可抢占）</p>
</li>
<li><p>实现于/kernel/sched.c</p>
</li>
<li>优先级：初始优先级即nice值，-20到19默认0，越小越高；动态优先级prio值以nice为基数经过effective_prio()函数返回，同样实现于上述文件</li>
</ul>
<p>CFS/完全公平调度算法：每个进程运行一段时间、循环轮转，选择运行虚拟时间最少的进程为下一个运行进程。维护一个以vruntime为索引的红黑树，始终选择树中最左侧叶子节点。实现于/kernel/sched/fair.c</p>
<blockquote>
<p> 时间记账vruntime=实际运行时间*nice为0的权重值/当前进程的权重值（权重越大vruntime增加的越慢）；权重值有对应表查找</p>
</blockquote>
<p><strong>锁机制</strong>：</p>
<ul>
<li><p>原子操作atomic_t：确保指令执行期间不被打断，要么全部执行完，要么根本不执行</p>
</li>
<li><p>自旋锁spinlock_t（中断处理过程）：防止多于一个的执行线程同时进入临界区</p>
</li>
<li><p>信号量/睡眠锁semaphore：一个任务试图获得一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠</p>
</li>
<li><p>互斥体mutex：同上，但计数通常为1而非数量</p>
</li>
<li><p>读写锁rwlock_t：允许多个线程并发地读访问临界区，但是写访问只限制于一个线程</p>
</li>
</ul>
<p>内存屏障：防止处理器或编译器对指令执行和内存修改进行重新排序；</p>
<blockquote>
<p>load屏障：在该屏障后的都要缓冲区内运行完后才可以执行<br>store屏障：强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存<br>full屏障：保障了早于屏障的内存读写操作的结果提交到内存之后，再执行晚于屏障的读写操作</p>
</blockquote>
<p>内存屏障接口函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>barrier</td>
<td>阻止编译器跨越屏障对载入或存储操作进行优化</td>
</tr>
<tr>
<td>rmb</td>
<td>阻止跨越屏障的载入动作发生重排序</td>
</tr>
<tr>
<td>read_barrier_depends</td>
<td>阻止跨越屏障的具有数据依赖关系的载入动作重排序</td>
</tr>
<tr>
<td>wmb</td>
<td>阻止跨越屏障的存储动作发生重排序</td>
</tr>
<tr>
<td>mb</td>
<td>阻止跨越屏障的载入和存储动作重新排序</td>
</tr>
<tr>
<td>smp_rmb</td>
<td>在SMP上提供rmb()功能，在UP上提供barrier()功能</td>
</tr>
<tr>
<td>smp_read_barrier_depends</td>
<td>在SMP上提供read_barrier_depends()功能，在UP上提供barrier()功能</td>
</tr>
<tr>
<td>smp_wmb</td>
<td>在SMP上提供wmb()功能，在UP上提供barrier()功能</td>
</tr>
</tbody>
</table>
</div>
<p><strong>沙箱机制</strong>：隔离环境</p>
<p>SELinux（LSM安全模块）中</p>
<ul>
<li><p>自主访问控制DAC：对象（一般指文件等）的属主全权管理该对象的访问控制策略，有权读取、修改、转移对象信息，并且可以把这种权限转移给其他主体</p>
</li>
<li><p>强制访问控制MAC：每一个主体（包括用户和程序）和客体都拥有固定的安全标记，主体能否对客体进行相关操作，取决于主体和客体所拥有安全标记的关系</p>
</li>
</ul>
<blockquote>
<p>SELinux三种工作模式：强制（违反阻止并记录）,容忍（违反不阻但记录）,关闭</p>
</blockquote>
<p>Chroot：更改根目录，但常用于进行逃逸</p>
<p>Seccomp-BPF：白名单设置系统调用，并使用Berkeley Packet Filter规则实现，可以对任意系统调用及其参数进行过滤</p>
<p>命名空间：mount、uts、ipc、pid、network、user等类似设置</p>
<p>LibOS：库操作系统，根据某类应用的特殊需求，由某一高级编程语言将原本属于操作系统内核的某些资源管理功能按照模块化的要求，以库形式提供给应用程序的特殊操作系统。与应用程序在编译时被链接到一起，形成一个只有<strong>单地址空间</strong>的二进制文件并<strong>工作在应用层</strong></p>
<h3 id="IO设备与驱动"><a href="#IO设备与驱动" class="headerlink" title="IO设备与驱动"></a>IO设备与驱动</h3><p>Linux上的驱动包括：字符设备（字节为单位的I/O传输，键鼠等）、块设备（磁盘等）、网络设备。<code>ls -al /dev</code>查看目录下的设备文件，该目录是动态生成的、使用devtmpfs虚拟文件系统挂载的、基于RAM的虚拟文件系统，打开设备就相当于打开这些文件。</p>
<p>为管理设备，Linux给设备都编的有设备号，包含主副，主的用来区分不同种类，副的区分不同设备。在/include/linux/fs.h中有相关设备号分配的函数，<code>alloc_chrdev_region()</code>自动分配、<code>register_chrdev_region()</code>需要主动指定</p>
<p><strong>字符设备</strong>：include/linux/cdev.h中的cdev数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">//设备驱动对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>	<span class="comment">//驱动程序对应的内核模块的指针</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>	<span class="comment">//操作函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">//将字符设备串为链表</span></span><br><span class="line">    <span class="type">dev_t</span> dev;	<span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;		<span class="comment">//次设备号个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>块设备驱动</strong>：一般一块512B，有缓存，通常由文件系统调用；对应用层来说通常有如下两种访问方式；/dev和文件系统挂载点，前者和字符设备一样，通常用于配置，后者在mount之后就可以通过文件系统直接访问一个块设备</p>
<p><img src="https://s2.loli.net/2024/08/08/BqSFH36ATZQrDL2.png" alt="mount.png"></p>
<p>I/O操作类型：同步阻塞I/O（发起后等待返回）、同步非阻塞I/O（一直发直到返回）、异步阻塞I/O、异步非阻塞I/O、多路复用（多线程）</p>
<p><strong>Linux驱动</strong>：模块可以扩充内核功能，驱动程序也算是一种模块。<code>insmod</code>将模块加入正在运行的内核，<code>rmmod</code>将其从内核删除；在内核启动时装载叫静态装载，运行时叫动态装载。</p>
<p>在开发驱动时：不能访问C库，只能访问有限的系统调用或者使用汇编，此外还需要注意同步与并发。<code>module_init()</code>驱动代码的入口点，每当加载该模块时就会被调用，<code>module_exit()</code>当驱动在内核被卸载时自动调用</p>
<ul>
<li>/proc文件系统：仅存在于内存，其下的文件都绑定于一个内核函数，也可以进行修改</li>
<li>/sys文件系统：除了上面的功能外，还能够统一管理设备模型（使用了kobject对象，它使得所有设备在底层具有统一的接口，包括设备、驱动、总线等）</li>
</ul>
<h3 id="Linux内核漏洞"><a href="#Linux内核漏洞" class="headerlink" title="Linux内核漏洞"></a>Linux内核漏洞</h3><p>用户态漏洞是指用户态程序漏洞，通常包括应用程序的漏洞，以及操作系统用户态模块的漏洞。<br>内核漏洞是指运行在RING0的程序所具有的能被利用的Bug或缺陷。</p>
<blockquote>
<p>运行在Ring0上的操作系统内核、驱动共享同一个虚拟地址空间，可以完全访问系统空间的内存。而不像用户态进程那样拥有独立私有的内存空间</p>
</blockquote>
<ul>
<li>内存破坏漏洞：栈溢出、堆溢出（溢出、内存泄漏）</li>
<li>未初始化的/未验证/已损坏的指针引用：空指针引用<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2692">CVE - CVE-2009-2692 (mitre.org)</a>、空指针间接引用本地拒绝服务漏洞<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2627">CVE - CVE-2014-2627 (mitre.org)</a></li>
<li>整数溢出：Linux内核中的TCP协议栈整数溢出<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11477">CVE - CVE-2019-11477 (mitre.org)</a></li>
<li>竞态条件：脏牛漏洞，内存子系统在处理copy-on-write（COW）时出现竞争条件，导致私有只读存储器映射被破坏，可利用此漏洞非法获得读写权限，进而提升权限<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5159">CVE - CVE-2016-5159 (mitre.org)</a></li>
<li>基于Cache的侧信道攻击：利用 CPU cache 访问速度和主存访问速度间的巨大时间差异进行侧信道分析</li>
<li>Hook：修改系统调用函数表<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.19.2/source/arch/x86/syscalls/syscall_32.tbl">sys_call_table</a>；先去掉该表的写保护，劫持system_call并获取上表地址，找到需要的函数进行替换</li>
</ul>
<p>缓冲区溢出防护机制：</p>
<ul>
<li><p>Canary-金丝雀：将随机产生的canary(探测值)插入到返回地址和局部变量之间，在函数返回之前检查canary，如果检测到错误的canary则证明溢出</p>
<p>gcc编译选项<code>-fstack-protector</code>仅对局部变量中含有char数组的函数插入，<code>-fstack-protector-all</code>所有函数启用，<code>-fno-stack-protector</code>禁用堆栈保护</p>
<p>绕过：猜数、获取该值并在shellcode中写入、攻击检查函数、更改存储的canary值</p>
</li>
<li><p>NX（DEP）：将数据所在内存页(默认的堆页、栈页以及内存池页）标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。对应操作系统中的NX/XD属性，指明该内存不能执行代码</p>
<p><code>gcc -z execstack -o test test.c</code>关闭NX保护，默认开启</p>
<p>绕过：关闭DEP、ROP、ret2lib</p>
</li>
<li><p>ASLR地址随机化：共享库、栈、mmap、堆、内核地址空间、VDSO的随机化；</p>
<p>绕过：伪随机、堆喷射定位内存、ROP链、GOT表劫持</p>
</li>
</ul>
<p>提权技术：</p>
<ol>
<li>修改cred结构提权</li>
<li>利用系统权限检查缺陷，为/bin/bash设置S位，再使用设置了S位的/bin/bash打开shell，从而获取root权限。（<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-8660">CVE - CVE-2015-8660 (mitre.org)</a>）</li>
<li>利用漏洞对任意文件写数据（脏牛）</li>
<li>直接修改/etc/passwd中用户的uid和gid为0</li>
<li>直接修改/etc/shadow文件中root用户的密码</li>
</ol>
<p>内核漏洞防御机制：检查输入输出、安全验证和过滤、安全编码、驱动白名单、CFI-控制流完整性（限制程序运行中的控制流转移，使其始终处于原有的控制流图所限定的范围内）、VSM-虚拟安全模式（微型操作系统运行LSA服务）、SMEP-监督模式执行保护（禁止内核CPU访问用户空间）、KPTI-内核页表隔离（完全分离用户空间与内核空间页表）</p>
<h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><p><a target="_blank" rel="noopener" href="https://www.redhat.com/zh/topics/linux/what-is-selinux">SELinux</a>是一种基于域-类型模型的强制访问控制MAC安全系统，它定义了每个人对系统上的应用、进程和文件的访问控制。</p>
<ul>
<li><p>过程：当程序发出访问对象的请求时，SELinux会检查访问向量缓存表AVC，其中缓存有主体和对象的访问权限，如果SELinux无法做出决定，那么该请求将被发送到安全服务器进行检查匹配。</p>
</li>
<li><p>区别：而传统Linux与Unix采用DAC（自主访问控制），即对象拥有者可以任意修改或授予此对象相应的rwx权限。相比于此，SeLinux对于用户和进程只赋予最小权限，并防止了权限的升级（这些策略由管理员定制，一般用户无法更改）</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>SElinux命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getenforce</td>
<td>查看SELinux状态</td>
</tr>
<tr>
<td>setenforce 1/0</td>
<td>设置状态1为强制，0为宽容模式</td>
</tr>
<tr>
<td>seinfo/sestatus</td>
<td>查看SE大致信息/详细信息</td>
</tr>
<tr>
<td>semodule</td>
<td>模块管理</td>
</tr>
<tr>
<td>chcon</td>
<td>更改文件目录设备的安全上下文</td>
</tr>
<tr>
<td>restorecon</td>
<td>恢复安全上下文</td>
</tr>
<tr>
<td>sesearch</td>
<td>查看系统详细策略信息-allow语句</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>状态：Enforcing-1（验证并限制）、Permissive-0（验证但不限制仅警告）、Disable（关闭SElinux，需要修改配置文件/boot/grub/grub.conf-优先读取或/etc/selinux/config）<code>SELINUX=enforcing</code>：当前SELinux的状态；<code>SELINUXTYPE=targeted</code>：当前SELinux的策略</p>
</blockquote>
<p>Selinux的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/584479924">MAC</a>由三个相对独立的子模型构成：TE（类型强制）、MCS（多类别模型）、MLS（多层级模型）</p>
<ul>
<li>TE：A和B进程类型只能访问给定对象类型，即分类</li>
<li>MCS：类别标记后的对应访问</li>
<li>MLS：主体和对象均有安全层级</li>
</ul>
<p>LSM框架：其允许安全模块插入内核中，用于提高传统DAC安全性。当用户进程经过DAC检查后，会由LSM Hook与SElinux的相关模块进行检查</p>
<p><img src="https://s2.loli.net/2024/08/08/yliHUouNIZ4dGVD.png" alt="LSM.png"></p>
<h3 id="Namespace及Cgroups机制"><a href="#Namespace及Cgroups机制" class="headerlink" title="Namespace及Cgroups机制"></a>Namespace及Cgroups机制</h3><p>两者在Linux用于隔离进程，前者负责信息隔离，后者负责进程资源大小限制。</p>
<ul>
<li>UTS NameSpace：提供了主机名和域名的隔离，使得每个容器就拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点</li>
<li>PID Namespace：两个不同命名空间下的进程可以有同一个PID</li>
<li>Mount NameSpace：使得不同空间下的文件操作互不影响；fs/mount.h中的mnt_namespace结构体</li>
<li>IPC NameSpace：进程间通信如信号量、消息队列、共享内存的隔离</li>
<li>Network namespace：网络资源如设备、协议栈、路由表等的隔离</li>
<li>User namespace：隔离了安全相关的标识符和属性</li>
</ul>
<p>Cgroups：若干控制组组成树状结构，子节点继承父结点属性，而每一层中有若干子系统，每一个子系统控制该层级的不同资源</p>
<p>子系统：cpu（限制进程cpu使用率）、cpuacct（统计cpu使用报告）、cpuset（用于分配cpu节点或内存结点）、memory（限制内存使用）、blkio（限制进程对块设备的操作）…</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zy0t1.github.io">Zy0t1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zy0t1.github.io/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/">http://zy0t1.github.io/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zy0t1.github.io" target="_blank">Zy0t1's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/" title="Windows不完全讲解"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows不完全讲解</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/" title="数据库与云"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据库与云</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/web.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zy0t1</div><div class="author-info__description">中二次元晚期</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zy0t1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zy0t1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wy1078041755@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62036500" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-amp-%E7%9B%AE%E5%BD%95-amp-%E7%BE%A4%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">文件&amp;目录&amp;群组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.</span> <span class="toc-text">内核介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E9%A9%B1%E5%8A%A8"><span class="toc-number">7.</span> <span class="toc-text">IO设备与驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E"><span class="toc-number">8.</span> <span class="toc-text">Linux内核漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SELinux"><span class="toc-number">9.</span> <span class="toc-text">SELinux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespace%E5%8F%8ACgroups%E6%9C%BA%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">Namespace及Cgroups机制</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Zy0t1</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>