<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows不完全讲解 | Zy0t1's blog</title><meta name="author" content="Zy0t1"><meta name="copyright" content="Zy0t1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于Windows的内容，上至应用说明，下至文件分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows不完全讲解">
<meta property="og:url" content="http://zy0t1.github.io/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/index.html">
<meta property="og:site_name" content="Zy0t1&#39;s blog">
<meta property="og:description" content="基于Windows的内容，上至应用说明，下至文件分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp">
<meta property="article:published_time" content="2023-09-07T03:47:17.000Z">
<meta property="article:modified_time" content="2024-08-08T08:18:31.771Z">
<meta property="article:author" content="Zy0t1">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Windows">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp"><link rel="shortcut icon" href="/img/web.png"><link rel="canonical" href="http://zy0t1.github.io/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows不完全讲解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-08 16:18:31'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/web.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Zy0t1's blog"><span class="site-name">Zy0t1's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Windows不完全讲解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-07T03:47:17.000Z" title="发表于 2023-09-07 11:47:17">2023-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T08:18:31.771Z" title="更新于 2024-08-08 16:18:31">2024-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Windows不完全讲解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<p>Windows历史！！！！</p>
<ul>
<li><p>MS-DOS：微软魔改的86-DOS——Windows1.0：简单的对DOS的图形化包装——Windows2.0——Windows3.0：更改界面UI、添加图标等并且能够模拟32位处理器</p>
</li>
<li><p>支持32位处理器的Windows9x系列但仍有16位的代码：包括95、98、98E、Me等。出现了开始菜单和IE的捆绑销售</p>
</li>
<li><p>支持32位/64位处理器的Windows NT系列没有16位：new technology的意思，win2000——XP引入了家庭企业版——Vista——7基于Vista——8/8.1——WindowsPhone——10——11</p>
<blockquote>
<p>没有9？因为seven “ate” nine</p>
</blockquote>
</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIN+E、I、M、R、V、+/-</td>
<td>文件管理、设置、最小化(多个shift还原)、运行、剪切板、放大缩小</td>
</tr>
<tr>
<td>CTRL+Z、Y、shift+Esc、Shift+N</td>
<td>撤销、恢复、任务管理器、新建文件夹</td>
</tr>
<tr>
<td>alt+F4、Enter</td>
<td>关闭当前程序、查看文件属性</td>
</tr>
<tr>
<td>Shift+delete</td>
<td>永久删除，不在回收站</td>
</tr>
<tr>
<td>F11</td>
<td>全屏</td>
</tr>
</tbody>
</table>
</div>
<p><strong>文件扩展</strong>：仅仅用来告诉程序如何打开该文件，并不会对文件内容有啥破坏。在windows下扩展后缀用于指示如何打开该文件，而在linux下则是根据文件属性来判断的。</p>
<ol>
<li><p>.inf文件即驱动的说明文件；驱动，即硬件驱动程序，是使硬件正常工作的一种软件；.inf文件里存放着关于驱动的适配厂商，版本号等信息</p>
</li>
<li><p>.sys文件，系统级驱动程序文件的可执行代码</p>
</li>
<li><p>.dll，动态链接库；.lib静态链接库</p>
</li>
<li><p>.bin，二进制文件</p>
</li>
<li><p>.ini文件即初始化文件；是windows系统配置文件采用的存储格式；类似功能还有.cfg、.conf、.tx*</p>
<blockquote>
<p>.ini文件由若干节（[xxxx]中括号包围）构成，每节都由若干键-值构成（abb=xxxx），分号用于表示注释，直到行末；目前还存有少数.ini文件，大多都用注册表代替</p>
</blockquote>
</li>
</ol>
<p><strong>压缩技术</strong>：信息熵-符号出现次数越多，则信息越小h(x)=log2(1/p(x))</p>
<p>无损压缩与有损压缩（常用于视频图片等不容易被发现的）；哈夫曼编码，LZ77算法，LZ78算法</p>
<p>BMP：win平台上专用的位图，未经过压缩的原图；PNG：无损压缩比gif小，压缩算法LZ77；GIF：压缩算法LZW，包括动态GIF和静态GIF；JPG/JPEG：有损压缩，得到的图片最小；</p>
<p>MP3：压缩率1:10~12左右（lame编解码器）空间占用mp1&gt;mp2&gt;mp3；WMA：微软推出的与MP3类似，但是压缩率更高，音质更好；WAV：win下面的原声；APE：无损压缩，比率1:5？；FLAC：无损压缩，好；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>音乐</th>
<th>图片</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>WAV</td>
<td>BMP</td>
<td>未压缩，体积大</td>
</tr>
<tr>
<td>FLAC</td>
<td>PNG</td>
<td>无损压缩</td>
</tr>
<tr>
<td>MP3</td>
<td>JPEG</td>
<td>压缩率高</td>
</tr>
<tr>
<td>WMA/OGG</td>
<td>webp</td>
<td>更高</td>
</tr>
<tr>
<td>AAC</td>
<td>AVIF/HEIF</td>
<td>最高</td>
</tr>
</tbody>
</table>
</div>
<p><strong>环境变量</strong>：简单来说就是告诉计算机，你这个程序在哪里，可以方便操作系统打开这个程序。格式<code>%xxx%</code>包括用户变量和系统变量：</p>
<ul>
<li>用户变量指的就是操作系统对于当前用户（多用户）所能够快速操作的程序</li>
<li>系统变量就是该操作系统（多系统）可以快速打开的程序</li>
</ul>
<p><code>dir env:</code>显示所有环境变量；<code>$env:Path</code>显示Path环境变量；<code>$env:Path +=&quot;;C:\xx&quot;</code>添加环境变量（在CLI中仅限当前，关闭后消失）</p>
<p><strong>注册表</strong>：用来管理计算机的各个软硬件，包括控制面板、任务管理器、时间的改写、系统开机显示等偏向系统方向的内容，记录了用户安装在计算机上的软件和每个程序的相互关联信息，可以说是一种数据库；结构为：根键——项——值；</p>
<ul>
<li>根键：最大的文件夹，以HKEY为前缀，全大写</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>根键名称</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>HKEY_LOCAL_MACHINE</td>
<td>与机器硬件有关部分</td>
</tr>
<tr>
<td>HKEY_USERS</td>
<td>包含了所有的用户（xxx1&amp;xxx2）的设置信息</td>
</tr>
<tr>
<td>HKEY_CURRENT_USER</td>
<td>当前用户的信息，从第二项中单独分离出来的</td>
</tr>
<tr>
<td>HKEY_CLASSES_ROOT</td>
<td>定义文件扩展名、类型、图标等;从H1\software\classes分离</td>
</tr>
<tr>
<td>HKEY_CURRENT_CONFIG</td>
<td>相关配置的驱动的加载；从H1\config中分离</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>项：小文件夹，除了大的文件夹都是项</p>
</li>
<li><p>值：包括三部分：值的名称—值的类型—值的数据</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>值类型</th>
<th>具体</th>
</tr>
</thead>
<tbody>
<tr>
<td>REG_SZ/字符串值</td>
<td>固定长度字符串</td>
</tr>
<tr>
<td>REG_BINARY二进制值</td>
<td>多数硬件组成信息存储</td>
</tr>
<tr>
<td>DWORD/QWORD</td>
<td>数据的表示是4字节长/8字节长，大多驱动参数为DWORD</td>
</tr>
<tr>
<td>REG_MULTI_SZ多字符串值</td>
<td>含有多个文本值的字符串</td>
</tr>
<tr>
<td>REG_DWORD可扩充字符串值</td>
<td>解析的变量？</td>
</tr>
</tbody>
</table>
</div>
<p><strong>用户账户管理UAC</strong>：</p>
<p>目前win10以后有如下账户，管理员用户（Ad）、Guest、Default（防止系统引导出错的账户）、WDAGUtility（Defender账户）、自己的账户；</p>
<blockquote>
<p>（在专业版中能GUI查看，家庭版命令net user可以进行管理）</p>
</blockquote>
<p>用户组则是用于将相同类型的账号进行分类，每组权限不一，且不同组的共享资源是可以相互访问的。默认包括：Administrator组、Users组、Guest组。</p>
<p>自己的账户，默认处于用户组和管理员组，只有相关操作时才会暂时升到管理员权限</p>
<p><strong>常见进程</strong>：</p>
<ul>
<li>System进程：用于实现页面内存管理的进程，最高优先级。</li>
<li>csrss：客户端服务子系统(Client/Server Runtime Subsystem)；控制 Windows图形相关子系统</li>
<li>Lsass：本地安全权限服务；本地安全权限服务控制Windows安全机制。</li>
<li>Explorer：资源管理器；管理Windows图形Shell,包括开始菜单，任务栏，桌面和文件管理</li>
<li>Taskmgr：Windows任务管理器；执行Windows的任务。</li>
<li>Winlogon：Windows登陆进程；Windows用户的登陆程序。  </li>
<li>Svchost：主机服务程序；标准的动态链接库主机处理服务。</li>
<li>Services：Windows服务控制；管理Windows服务。   </li>
</ul>
<h3 id="命令与批处理脚本"><a href="#命令与批处理脚本" class="headerlink" title="命令与批处理脚本"></a>命令与批处理脚本</h3><p>cmd是windows下模仿DOS操作系统（之前的磁盘操作系统）的程序，但受到windows的限制，即不可能删除windows文件，但在DOS系统下可以；cmd也可以叫做bat，用cmd编写的脚本类似于Linux下的shell脚本，dos或win下的这样批处理脚本后缀.bat或.cmd</p>
<blockquote>
<p>这里再另外介绍以下powrshell，部分命令与cmd相同，大部分命令进行更新，更换为更容易理解的动名词短语形式。此外cmd类似于解释器，而powrshell的相当于一门面向对象的语言，借助.net平台（和win集成）可以运行其他许多在.net平台上编写的程序，也可向下兼容cmd的批处理脚本，对应脚本.ps1（使用的语法叫做cmdlet）</p>
</blockquote>
<h4 id="运行win-R键"><a href="#运行win-R键" class="headerlink" title="运行win+R键"></a>运行win+R键</h4><p>.cpl : 即Control Panel extension控制面板扩展程序</p>
<p>.msc ：即Micosoft management Console微软管理控制台</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">winver<span class="literal">-------------------</span>查看windows版本</span><br><span class="line">regedit<span class="literal">------------------</span>打开注册表编辑器</span><br><span class="line">firewall.cpl<span class="literal">-------------</span>防火墙</span><br><span class="line">mstsc<span class="literal">--------------------</span>远程桌面连接</span><br><span class="line">compmgmt.msc<span class="literal">-------------</span>计算机管理</span><br><span class="line">services.msc<span class="literal">-------------</span>服务管理</span><br><span class="line">optionalfeatures<span class="literal">---------</span>可选功能(如Hyper<span class="literal">-V</span>)</span><br><span class="line">appwiz.cpl<span class="literal">---------------</span>卸载更改程序</span><br><span class="line">shutdown<span class="literal">-----------------</span>关机</span><br><span class="line">certmgr.msc<span class="literal">--------------</span>证书管理</span><br><span class="line">control<span class="literal">------------------</span>打开控制面板</span><br><span class="line">appwiz.cpl<span class="literal">---------------</span>卸载部分软件</span><br></pre></td></tr></table></figure>
<h4 id="cmd基本命令"><a href="#cmd基本命令" class="headerlink" title="cmd基本命令"></a>cmd基本命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">help balabala(查询balabala命令的详细用法)</span><br><span class="line"><span class="literal">---------------</span>目录<span class="literal">----------------------------</span></span><br><span class="line"><span class="built_in">cd</span>..(返回上一级)</span><br><span class="line"><span class="built_in">cd</span> \(返回根目录)</span><br><span class="line"><span class="built_in">cd</span> /d d:/test(切换到d盘的test文件夹，/d为参数)</span><br><span class="line"><span class="literal">------------</span>文件相关<span class="literal">----------------------------</span></span><br><span class="line"><span class="built_in">dir</span>(显示当前目录下文件夹)</span><br><span class="line">tree d:/test(树状列出)</span><br><span class="line"><span class="built_in">md</span> test6(建立test6文件夹)</span><br><span class="line"><span class="built_in">rd</span> test6(删除test6文件夹,需确认)  /s(非空时需要确认) /s/q(非空时不需要确认)</span><br><span class="line"><span class="built_in">copy</span>/<span class="built_in">move</span>  d:\test1  e:\test2(把test1文件夹复制/移动到test2文件夹下)</span><br><span class="line"><span class="built_in">del</span> test5.pdf(专门删除文件，不是文件夹，不经常回收站)</span><br><span class="line"><span class="built_in">ren</span> d:\test1  test4(重命名文件/文件夹)</span><br><span class="line">attrib<span class="literal">--------------</span>(设置文件属性)</span><br><span class="line"><span class="literal">------------</span>网络<span class="literal">-------------------------------</span></span><br><span class="line">ping ip/域名(测试连通)   <span class="literal">-n</span> <span class="number">5</span>(测试五次)</span><br><span class="line">tracert ip/域名(路由追踪)</span><br><span class="line">ipconfig(查看本机ip)</span><br><span class="line">arp(用于显示连接在同一网段下的其他IP)</span><br><span class="line"><span class="literal">------------</span>进程<span class="literal">-------------------------------</span></span><br><span class="line">tasklist(显示当前正在运行的进程)</span><br><span class="line"><span class="built_in">start</span> xx.exe(开启某程序)</span><br><span class="line">taskkill /im xxx.exe(按照名称关闭进程)</span><br><span class="line">taskkill /pid <span class="number">123456</span>(按PID关闭进程)</span><br><span class="line"><span class="literal">------------</span>其他<span class="literal">-------------------------------</span></span><br><span class="line">shutdown /s(关机) /<span class="built_in">r</span>(重启) /<span class="built_in">h</span>|f(休眠) /a(取消关机) /s /t <span class="number">100</span>(<span class="number">100</span>s后关机)</span><br><span class="line"><span class="built_in">cls</span>(清屏)</span><br><span class="line">F7(查看所有执行过的命令，左边会有编号)</span><br><span class="line">F9(搭配F7，按照编号选择命令)</span><br></pre></td></tr></table></figure>
<h4 id="批处理脚本"><a href="#批处理脚本" class="headerlink" title="批处理脚本"></a>批处理脚本</h4><p>后缀文件保存为.bat，双击即可食用；至于脚本，是因为同样类似于解释型语言，一条条翻译运行；</p>
<p>cmd窗口与python的交互窗口类似；当然下面所列的也可以在cmd窗口中直接运行；可以与正则表达式配合使用</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-------------条件循环-------</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%a%</span> <span class="keyword">equ</span> <span class="variable">%b%</span> (<span class="built_in">echo</span> yes) <span class="keyword">else</span> (<span class="built_in">echo</span> no)	#如果a=b..</span><br><span class="line">#<span class="keyword">exit</span>(存在哪个文件)<span class="keyword">equ</span>(相等);<span class="keyword">neq</span>(不等);<span class="keyword">lss</span>(小于);<span class="keyword">leq</span>(小或等);<span class="keyword">gtr</span>(大于);<span class="keyword">geq</span>(大或等);</span><br><span class="line"><span class="keyword">for</span>  <span class="variable">%%I</span> <span class="keyword">in</span> (ABC) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%I</span>	#输出ABC</span><br><span class="line">#<span class="keyword">for</span> %I <span class="keyword">in</span>(内容<span class="number">1</span>，内容<span class="number">2</span>...) <span class="keyword">do</span> command (在bat文件中用<span class="variable">%%I</span>)</span><br><span class="line"></span><br><span class="line">------------显示与变量设置---</span><br><span class="line"><span class="built_in">echo</span> (显示当前回显状态)</span><br><span class="line">@<span class="built_in">echo</span> off (从本行开始关闭回显，去掉@则从下行开始，on则打开，@负责单行的回显，一般作为文件开始)</span><br><span class="line"><span class="built_in">set</span> a=aaa (设置变量a值为“aaa”，不要用%<span class="number">0</span>~<span class="number">9</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%a%</span> (输出变量a的值)</span><br><span class="line"><span class="comment">rem (注释)</span></span><br><span class="line">%<span class="number">0</span> <span class="variable">%1.....%</span><span class="number">9</span> (第<span class="number">0</span>-<span class="number">9</span>个参数，%<span class="number">0</span>表示自身，指的是在命令行中运行脚本时带的参数)</span><br><span class="line">-------------其他----------</span><br><span class="line"><span class="built_in">title</span> xxx (变更窗口标题)</span><br><span class="line"><span class="built_in">pause</span> (暂停)</span><br><span class="line">&amp;(顺序执行多条命令，不管结果)</span><br><span class="line">&amp;&amp;(顺序执行，碰到错误命令后不再执行)</span><br><span class="line">||(顺序执行命令，碰到正确后不再执行)</span><br><span class="line">|  (管道符，后面的做前面的输入)</span><br><span class="line">&gt;(清除原本内容后再写入)</span><br><span class="line">&gt;&gt;(接着写)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在PS中默认不支持脚本，需要用管理员权限开启，并输入<code>Set-ExecutionPolicy RemoteSigned</code>更改执行策略</p>
</blockquote>
<h3 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h3><p>ps: $开头的一般均为临时文件；</p>
<ol>
<li>Windows：win系统文件</li>
</ol>
<ul>
<li>addins：存放系统附加功能</li>
<li>appcompat：应用兼容性相关</li>
<li>apppath：保存程序的修补备份文件</li>
<li>assembly：由.Net Framwork自动创建，包含多个托管模块以及一些资源文件的逻辑组合；</li>
<li>boot：主要功能为一键备份所需，可删；另一个boot.ini为系统启动时的引导文件；</li>
<li>Debug：系统层面的调试文件夹，存放调试日志.log</li>
<li>Downloaded Program Files：存放过去的IE浏览器扩展，目前已空；可删；</li>
<li>Help：Windows帮助文件；可扔；</li>
<li>INF：存放 为硬件提供服务的.inf文件和.pnf文件；</li>
<li>Microsoft.NET：.net根据官方文档，电脑的驱动以及系统更新需要此支持；</li>
<li>Offline web pages：脱机浏览文件，即没网的时候仍可浏览的网页；</li>
<li><strong>PLA</strong>：性能日志和警报，依据性能计数器阈值生成警报等；</li>
<li>Prefetch：存放系统预读取过的信息，加快访问速率；可删内容；</li>
<li><strong>security</strong>：系统重要的数据文件；</li>
<li><strong>System32</strong>：存放64位的windows系统；<ul>
<li>drivers：里面存放驱动程序文件的可执行代码.sys文件</li>
</ul>
</li>
<li><strong>SysWOW64</strong>：是64位的windows用来存放32位windows的地方；</li>
<li>TAPI：win升级时备份的旧版本文件；可删；</li>
<li>TEMP：系统运行过程中的的临时文件夹；需清理；</li>
<li>Templnst：存储部分应用的离线模板文件夹；</li>
<li>Tracing：WindowsLiveMassage会创建的文件；现在没啥用；</li>
<li>twain_32：实现扫描功能，需外接设备；没啥用；</li>
<li><strong>WinSxS</strong>：存放不同版本的windows组件，减少dll引起的不同版本引用的问题</li>
</ul>
<ol>
<li><p>Program File：系统中64位软件的安装目录</p>
</li>
<li><p>Program File(x86)：系统中32位软件安装目录</p>
</li>
<li><p>Program Data：放置程序使用数据等</p>
</li>
<li><p>Users：存储系统所有用户的软件及数据等；包括桌面和开始菜单</p>
<ul>
<li>Default：存放创建新账户时的配置文件</li>
<li>Lenovo：Lenovo用户的存储的数据内容（这里主要介绍其中AppDate里的内容）<ul>
<li>Local：与安装的程序相关的文件夹，其中的数据不会因为用户的切换而无法显示</li>
<li>LocalLow：低级别访问数据</li>
<li>Roaming：可随着用户的配置而转移的数据</li>
</ul>
</li>
<li>公用：所有用户可用文件夹</li>
</ul>
</li>
<li><p>Intel：安装驱动时的文件夹，安装过后可扔</p>
</li>
</ol>
<blockquote>
<p> 下面是Windows文件夹下一些主题配置相关文件</p>
<p>Cursors：鼠标指针，以.cur格式存放。en-US、zh-CN：语言文件夹。</p>
<p>Fonts：字体文件。IME：存放系统默认的输入法。</p>
<p>Media：系统提示音等。Resources：系统主题文件。Web：系统自带的图片壁纸</p>
</blockquote>
<h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h3><p>PE（Portable Executable），可移植的可执行文件。由COFF（UNIX下的通用对象文件格式）发展过来，对应Linux下的ELF文件；PE指的32位的可执行文件也叫PE32，对于64位的叫PE+或PE32+是一种扩展形式。因为PE文件在装载时被映射到进程虚拟空间中运行，所以在官网中也称PE为映像文件。</p>
<p><strong>有关操作</strong>：</p>
<ul>
<li><p>与gcc的<code>__attritube__()</code>类似，VC使用<code>#pragma</code>来提示编译器</p>
</li>
<li><p>VC的cpp编译器：<code>cl /c /Za hello.c</code>/c表示只编译为.obj文件，/Za则是禁用掉默认扩展，/Zl关闭默认链接库</p>
</li>
<li><p>链接器link</p>
</li>
<li><p>可执行文件查看器dumpbin：<code>dumpbin [/ALL|/SUMMARY] xx.obj</code>一个看全部信息，一个仅看基本</p>
</li>
</ul>
<p>二进制下打开4D 5A开头对应ASCII码中的MZ，其后面不远就有PE，这些标志着PE文件的叫做PE指纹；整体结构：DOS首部—NT映像头—块表/节表—块/节</p>
<blockquote>
<p>详细概述见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE 格式 - Win32 apps | Microsoft Learn</a></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>后缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>可执行系列</td>
<td>.exe  &amp;&amp; .scr</td>
</tr>
<tr>
<td>库系列</td>
<td>.dll &amp;&amp; .ocx &amp;&amp; .cpl &amp;&amp; .drv</td>
</tr>
<tr>
<td>驱动程序系列</td>
<td>.sys  &amp;&amp; .vxd</td>
</tr>
<tr>
<td>对象文件系列</td>
<td>.obj</td>
</tr>
</tbody>
</table>
</div>
<p>不同于Linux下目标文件和最终的可执行文件，VC生成的.obj文件与.exe文件格式不太相同，前者采用的是没有PE可选头的COFF格式，后者则是完整的PE格式。COFF格式以<code>IMAGE_FILE_HEADER</code>开头，之后就是段表和段，在PE中该头以<code>IMAGE_NT_HEADER</code>代替，在其前面还添加了DOS头（兼容DOS系统），后面内容基本一致。我们主要介绍PE</p>
<ul>
<li><p>DOS部首：DOS MZ(4D 5A)文件头，DOS块共64字节，最低四字节，存放着PE的地址，在DOS MZ和PE头之间剩下的是DOS插桩程序。DOS部首<code>IMAGE_DOS_HEADER</code>中有<code>e_cs</code>和<code>e_ip</code>两个成员来指向上述插桩程序入口地址，当PE在DOS下被执行时，最开始两个字节“MZ”使其误以为是正常的DOS可执行文件，之后读取上述两个成员值，跳转到DOS stub中，该段代码可以在DOS下运行，其唯一作用就是在终端输出“This program cannot be run in DOS”或”This program must be run under Win32”，然后退出。在目前的DOS头中唯一有用的就是其<code>e_lfanew</code>成员，其表明了NT头的偏移位置。</p>
</li>
<li><p><strong>PE文件头/NT映像头</strong>：4B+20B+224B；这里以32位做实例，存在于<winnt.h>头文件中，详情参考<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_nt_headers32">Microsoft Learn</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS</span> &#123;</span><br><span class="line">	DWORD Signature;		<span class="comment">//字串，4B</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;		<span class="comment">//映像文件头，20B</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;	<span class="comment">//可选映像头，224B，64位下240B</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>字串：”50\45\00\00”=”PE\0\0”标志着NT头的开始；在DOS程序头的3CH位置的四个字节，是前面字符串的偏移地址。</p>
</li>
<li><p>映像文件头（main）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span>&#123;</span><br><span class="line">	WORD Machine		<span class="comment">//机器类型,x86=14CH</span></span><br><span class="line">	WORD NumberOfSection		<span class="comment">//文件中节的个数,important,每个节固定40字节</span></span><br><span class="line">	DWORD TimeDateStamp		<span class="comment">//文件生成的时间戳</span></span><br><span class="line">	DWORD PointerToSymbolTable		<span class="comment">//COFF符号表的偏移（用于调试）</span></span><br><span class="line">	DWORD NumberOfSymbols		<span class="comment">//符号表中的符号数目（用于调试）</span></span><br><span class="line">	WORD SizeOfOptionalHeader		<span class="comment">//可选头大小,important,用于寻找节表的开始位置</span></span><br><span class="line">	WORD Characteristics		<span class="comment">//文件属性</span></span><br><span class="line">&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选映像头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER</span> &#123;</span><br><span class="line">  WORD Magic;		<span class="comment">//幻数，一般是010BH</span></span><br><span class="line">  BYTE MajorLinkerVersion;		<span class="comment">//连接程序的主版本号</span></span><br><span class="line">  BYTE MinorLinkerVersion;		<span class="comment">//连接程序次版本号</span></span><br><span class="line">  DWORD SizeOfCode;		<span class="comment">//代码段总尺寸-important-对齐后的值</span></span><br><span class="line">  DWORD SizeOfInitializedData;		<span class="comment">//已初始化数据总尺寸</span></span><br><span class="line">  DWORD SizeOfUninitializedData;	<span class="comment">//未初始化数据总尺寸</span></span><br><span class="line">  DWORD AddressOfEntryPoint;	<span class="comment">//开始执行位置-important!!!</span></span><br><span class="line">  DWORD BaseOfCode;		<span class="comment">//代码节开始位置-important</span></span><br><span class="line">  DWORD BaseOfData;		<span class="comment">//数据节开始位置</span></span><br><span class="line">  DWORD ImageBase;		<span class="comment">//可执行文件默认装入的基地址-如果装入时用该值做基地址则无需再重定位,EXE默认400000H，DLL默认10000000H</span></span><br><span class="line">  DWORD SectionAlignment;	<span class="comment">//装入内存时节的对齐数字</span></span><br><span class="line">  DWORD FileAlignment;		<span class="comment">//节的对齐数字，一般是扇区长（512B）</span></span><br><span class="line">  WORD MajorOperatingSystemVersion;		<span class="comment">//要求最低的OS主版本号</span></span><br><span class="line">  WORD MinorOperatingSystemVersion;		<span class="comment">//最低OS的次版本号</span></span><br><span class="line">  WORD MajorImageVersion;		<span class="comment">//可执行文件主版本号</span></span><br><span class="line">  WORD MinorImageVersion;		<span class="comment">//次版本号</span></span><br><span class="line">  WORD MajorSubsystemVersion;	<span class="comment">//最小子系统主版本号</span></span><br><span class="line">  WORD MinorSubsystemVersion;	<span class="comment">//最小子系统次版本号</span></span><br><span class="line">  DWORD Win32VersionValue;	<span class="comment">//保留，一般0</span></span><br><span class="line">  DWORD SizeOfImage;		<span class="comment">//装入内存后映像的总尺寸-SectionAlignment的整数倍</span></span><br><span class="line">  DWORD SizeOfHeaders;		<span class="comment">//NT映像头+节表大小</span></span><br><span class="line">  DWORD CheckSum;		<span class="comment">//CRC检验和，一般EXE为0，</span></span><br><span class="line">  WORD Subsystem;		<span class="comment">//可执行文件的子系统</span></span><br><span class="line">  WORD DllCharacteristics;		<span class="comment">//何时被DllMain调用</span></span><br><span class="line">  DWORD SizeOfStackReserve;		<span class="comment">//初始化线程时保留的栈大小</span></span><br><span class="line">  DWORD SizeOfStackCommit;		<span class="comment">//提交的栈大小</span></span><br><span class="line">  DWORD SizeOfHeapReserve;		<span class="comment">//保留堆大小</span></span><br><span class="line">  DWORD SizeOfHeapCommit;		<span class="comment">//提交堆大小</span></span><br><span class="line">  DWORD LoaderFlags;		<span class="comment">//与调试有关</span></span><br><span class="line">  DWORD NumberOfRvaAndSizes;	<span class="comment">//数据目录的项数，一般16</span></span><br><span class="line">  IMAGE_DATA_DIRECTORY 	DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];	<span class="comment">//数据目录，存放该可执行文件上一些数据表的起始RVA和尺寸</span></span><br><span class="line">&#125;IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>16个数据表【4B-起始虚拟地址|4B-数据表大小】：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#optional-header-data-directories-image-only">目录项</a></p>
<p>关于VA、RVA、FOA等的计算：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/12312370.html">RVA和FOA的相互转换 - zpchcbd 博客园</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>节表/块表：用来说明节的具体信息，每个节都有一个节表，节表数量由映像文件头决定；一个节表40B；通俗版参考：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1407996-1-1.html">PE文件笔记六 节表和节</a></p>
<blockquote>
<p>VA：内存中虚拟地址；RVA：相对虚拟地址的偏移；FA：文件的地址；FOA：在文件中的偏移地址，没有被载入内存；VA = RVA + ImageBase</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];		<span class="comment">//8字节的节名，数组表示</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;</span><br><span class="line">  &#125; Misc;		<span class="comment">//obj文件用来表示本节物理地址，EXE文件中表示节的实际字节数</span></span><br><span class="line">  DWORD VirtualAddress;		<span class="comment">//加载进内存后，本节的偏移地址地址</span></span><br><span class="line">  DWORD SizeOfRawData;		<span class="comment">//未加载的文件在对齐后的节的尺寸</span></span><br><span class="line">  DWORD PointerToRawData;		<span class="comment">//本节在原始文件中的偏移地址</span></span><br><span class="line">  DWORD PointerToRelocations;	<span class="comment">//obj文件中表示该节重定位信息的偏移，EXE中无意义</span></span><br><span class="line">  DWORD PointerToLinenumbers;	<span class="comment">//行号表位置</span></span><br><span class="line">  WORD  NumberOfRelocations;		<span class="comment">//需要重定位的数目</span></span><br><span class="line">  WORD  NumberOfLinenumbers;		<span class="comment">//在行号表中的行号数目</span></span><br><span class="line">  DWORD Characteristics;		<span class="comment">//节属性-代码节=60000020h即可执行、可读、节中包含代码-数据节=C0000040h即可读、可写、包含已初始化数据</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>根据可执行文件获取每一节在内存中位置：</p>
<ol>
<li>读取<code>IMAGE_FILE_HEADER.NumberOfSection</code>，获取<strong>节</strong>数目</li>
<li>读取<code>IMAGE_OPTIONAL_HEADER.SizeOfHeaders</code>来定位<strong>节表</strong>的位置</li>
<li>对于每一节，首先读取<code>IMAGE_SECTION_HEADER.PointerToRawData</code>来得到该<strong>节</strong>在原始文件中的偏移地址—FOA，读取<code>IMAGE_SECTION_HEADER.SizeOfRawData</code>得到<strong>节</strong>在原始文件中的总字节数</li>
<li>读取<code>IMAGE_OPTIONAL_HEADER.ImageBase</code>得到<strong>文件</strong>在内存中的基地址—ImageBase，之后读取<code>IMAGE_SECTION_HEADER.VirtualAddress</code>获得本<strong>节</strong>相对于文件的偏移地址—RVA，两者再相加获得本节的虚拟地址—VA，同时根据<code>IMAGE_SECTION_HEADER.Characteristics</code>获取节的具体属性</li>
</ol>
</li>
<li><p>节数据：</p>
<ol>
<li><p>代码节.text或.code：PE文件均有，含有程序可执行代码</p>
</li>
<li><p>引出函数节.edata：一般在DLL中，本文件向其他文件提供的可调用函数列表。</p>
</li>
<li><p>引入函数节.idata：<code>IMAGE_IMPORT_DESCRIPTOR</code>结构数组，每引入一个DLL，数组就多一项，最后一项全0表示结束。</p>
</li>
<li><p>已初始化数据节.data：编译时已经固定值的数据</p>
</li>
<li><p>未初始化数据节.bss：未初始化的全局变量和静态变量</p>
</li>
<li><p>资源节.rsrc或.rdata：程序要用到的资源，树形结构</p>
</li>
<li><p><code>.debug$S</code>符号相关的调试信息段；<code>.debug$P</code>预编译头文件调试信息；<code>.debug$T</code>类型相关调试信息</p>
</li>
<li><p>.drectve段：区别于GCC下的链接脚本，在VC中编译器通过该段来告诉链接器如何对本目标文件进行链接</p>
</li>
<li><p>重定位信息段.reloc：存放重定位信息</p>
</li>
</ol>
</li>
</ul>
<h3 id="Win引导"><a href="#Win引导" class="headerlink" title="Win引导"></a>Win引导</h3><p>首先了解各大致过程：电源开启—&gt;分区引导（MBR）—&gt;操作系统引导（NTLDR/Bootmgr）—&gt;文件系统引导（DBR，每个卷/盘/区可以有不同的文件系统）；下面的介绍均以windows为例子</p>
<p><strong>硬盘结构</strong>：</p>
<ul>
<li><p>CHS寻址：借助3D参数，磁头0-255、柱面0-1023、扇区1-63</p>
<blockquote>
<p>3D参数：磁头数head（8位）、柱面数/磁道号cylinders（10位）、扇区数sectors（6位，每个扇区512字节）</p>
</blockquote>
</li>
<li><p>Int 13H调用：BIOS提供的基本功能，用于磁盘的复位、读写、校验、定位、诊断、格式化等，使用上述CHS寻址；</p>
</li>
<li><p>LBA寻址：将所有的扇区统一编号，从0开始；该地址为线性地址，由地址翻译器（硬件）将前面所述物理地址转换到此；同时也扩展了Int 13H，将其8G的限制突破；常用于下面的UEFI引导</p>
<blockquote>
<p>LBA地址=当前柱面号×255×63+当前磁头号×63+（当前扇区数-1）；因为不存在C/H/S=0/0/0，所以最后减一</p>
</blockquote>
</li>
</ul>
<p>分区与引导：用于对一个或多个真实存在的磁盘进行分区（划分为一个或多个），而每个分区都需要有自己的文件系统用来让OS进行管理，这些文件系统也需要有引导，一般都在开头位置的引导区。分区中也存放着操作系统的引导代码，引导重点在于OS的启动过程。</p>
<p><strong>Legacy BIOS引导模式</strong>：</p>
<p>使用MBR磁盘格式，系统只能在MBR格式磁盘上；这里以win的启动为例；过程如下：</p>
<ol>
<li><p>通电电压不稳，主板发送RESET信号给CPU，稳定后不在发送。CPU执行0xFFFF0h处指令，此处为BIOS程序</p>
</li>
<li><p>BIOS执行，进行POST（加电自检）木有问题后加载第一个扇区（MBR）到内存0x7c00h处</p>
</li>
<li><p>执行MBR，查找第一个活动分区，并将其第一个扇区（PBR）加载到内存</p>
</li>
<li><p>执行PBR，跳过BPB到可执行代码处NTLDR</p>
<blockquote>
<p>BPB:即BIOS参数记录块，描述能够使可执行引导代码找到相关参数的信息。记录着本分区的起始扇区、结束扇区、文件存储格式、硬盘介质描述符、根目录大小、FAT 个数,分配单元的大小等重要参数。</p>
</blockquote>
</li>
<li><p>PBR读取VBR（卷引导记录，用于告诉计算机OS在分区里的位置）；CPU跳转执行bootmgr代码</p>
</li>
<li><p>寻找BootMGR，木有则寻找ntldr（在win 8之后默认bootmgr）</p>
</li>
<li><p>执行bootmgr，读取BCD文件，如果有多个系统则列举供选择</p>
</li>
<li><p>选择win则加载winload.exe到内存，CPU执行，并读取\windows\bootstat.dat；接着加载内核程序Ntoskrnl.exe，将CPU执行权交给内核</p>
</li>
<li><p>内核程序初始化完成</p>
</li>
</ol>
<p><strong>MBR分区模式</strong>：</p>
<p>即主引导记录分区，也叫做DOS（磁盘操作系统）分区。包括：主引导记录MBR（开机必读）、硬盘主分区表DPT、引导扇区标记boot record ID；</p>
<ul>
<li><p>MBR：占前446字节，存放着系统主引导程序，位于磁盘0柱面、0磁头、1扇区</p>
</li>
<li><p>DPT：占64字节，记录磁盘基本分区，一共包含4个分区项，每项16字节；</p>
<blockquote>
<p>1B分区状态—3B起始磁头号+起始扇区+柱面号—1B分区类型（识别主分区还是扩展分区）—3B分区结束磁头号+扇区+柱面号—1D本分区之前已经占用的扇区数—1D本分区占用总扇区数</p>
</blockquote>
</li>
<li><p>Boot record ID：占2字节，合法的话就=0xAA55</p>
</li>
<li><p>扩展分区：正常情况下按照DPT项数只有4个分区，为了更多分区扩展，在每个逻辑盘前都有上述结构，其中的第一项存放当前逻辑盘的地址，第二项存放的是下一个逻辑盘前的引导记录等，最后两项为空。</p>
</li>
<li><p>最多只能识别2TB、最多4个主分区或3主分区+1扩展分区；</p>
</li>
</ul>
<hr>
<p><strong>UEFI BIOS引导模式</strong>：</p>
<p>win7支持，win8默认，使用GPT磁盘格式，没有自检过程；</p>
<p>阶段 = SEC（安全验证）—PEI（EFI前期初始化）—DXE（驱动执行环境）—BDS（启动设备选择）—TSL（操作系统加载前期）—RT（系统运行阶段）—AL（关机或系统恢复）</p>
<ol>
<li>同上进行通电，但CPU执行UEFI指令，并进行相关设备的初始化</li>
<li>查找EFI分区（FAT32格式，不一定是第一个分区，其中包含系统引导的关键数据程序）</li>
<li>加载<code>\Boot\EFI\bootmgfw.efi</code>（专用于引导windows的引导文件）</li>
<li>读取BCD文件，其中包含多个系统的信息，可供用户选择</li>
<li>后面同上</li>
</ol>
<p><strong>GPT分区模式</strong>：</p>
<p>全局唯一标识分区表，是可扩展固件接口EFI标准的一部分，用于代替MBR</p>
<p>包括=保护MBR+GPT头+分区表+分区区域+分区表备份+GPT头备份</p>
<ul>
<li><p>保护MBR：存放了一份传统MBR（1扇区），防止不支持GPT的管理工具破坏硬盘。在这个MBR中只有一个标识为0xEE的分区（也没有引导程序等，只有一个DPT、结束标志和磁盘签名），来表明该硬盘使用GPT分区表</p>
<blockquote>
<p>0x07普通分区、0x27恢复分区、0xEE该扇区为PMBR</p>
</blockquote>
</li>
<li><p>GPT头：用于记录分区表的信息，下面仅列出部分重要信息</p>
<blockquote>
<p>0x0C-4B-GPT头字节总数、0x18-8B-GPT头所在扇区号、0x48-8B-分区表起始扇区号、0x50-4B-分区表项数、0x54-4B-每个分区表项数字节数</p>
</blockquote>
</li>
<li><p>分区表：2-33号扇区，共可容纳128个分区表项，每个表项128B</p>
<blockquote>
<p>0x20-8B-分区起始地址、0x28-8B-分区结束地址</p>
</blockquote>
</li>
<li><p>每个分区最多1EB=1048576TB空间、支持128个主分区、分区表大小不固定</p>
</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统是让OS可以管理的一种文件集合。</p>
<ul>
<li>分类包括：扩展文件系统（Ext）、新技术文件系统（NTFS）、文件分配表（FAT）、光盘文件系统（CDFS）、高性能文件系统（HPFS）等。</li>
<li>内容包括：文件系统数据、内容（具体文件）、元数据（文件信息）、文件名、应用程序等</li>
</ul>
<p>在win下常用簇作为单位，扇区sector &lt; 簇Cluster：4KB，为单位分配空间，即占用空间，其内部的未使用叫内部碎片，外部碎片是介于两个簇之间但 &lt; 4KB的未使用的空间。</p>
<blockquote>
<p>松弛/文件残留空间：指的是文件最后一个数据单元中未使用的字节；<br>卷松弛：硬盘在使用前需要格式化，有些空间未经格式化就无法被使用，这种未被格式化的空间就叫卷松弛（卷是指磁盘，真正实用的即格式化好的叫做分区）</p>
</blockquote>
<p>分配簇/文件空间的算法主要有：</p>
<ul>
<li>连续分配：文件连续存储</li>
<li>链式分配：指针指向下一簇，必须连着读</li>
<li>索引分配：所有位置的指针都写入一个索引块中</li>
</ul>
<p>Windows支持的文件系统有：FAT12、FAT16、<strong>FAT32</strong>、<strong>NTFS</strong>、WINFS等。Linux支持Ext2、Ext3、Minix、NTFS等。</p>
<h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT32即文件分配表FAT表项大小为32位，exFAT的表项大小64位；采用链式分配法管理已经分配或未分配的簇；</p>
<p>所有版本的FAT布局相同：物理盘划分为=引导区—文件分配表区（FAT区）—数据区（DATA区），前两者合称为系统区</p>
<ul>
<li><p>引导区：从头开始占用三个扇区，其中保存了物理盘每扇区的字节数、每一簇对应的扇区数以及引导记录等；其后面还有部分留白扇区（0x24以后的内容会根据版本号有区别，这里以FAT32为例子）；FAT16只占用1个扇区，而且后面没有留白</p>
<p>在FAT32中，引导区=DBR+保留分区；下面是分区引导区的内容（只有部分较为重要内容）</p>
<blockquote>
<p>DBR：Dos Boot Record即分区引导扇区，用于引导操作系统引导程序的一部分，用于加载文件系统元数据</p>
</blockquote>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节位置</th>
<th>内容</th>
<th>字节位置</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00-0x02</td>
<td>汇编指令跳转引导代码EB 58 90</td>
<td>0x03-0x0a</td>
<td>文件系统版本</td>
</tr>
<tr>
<td>0x0b-0x0c</td>
<td>每扇区的字节数</td>
<td>0x0d</td>
<td>每簇的扇区数</td>
</tr>
<tr>
<td>0xe-0xf</td>
<td>FAT表相对起始扇区号</td>
<td>0x10</td>
<td>FAT表个数（一般是2，用于备份）</td>
</tr>
<tr>
<td>0x15</td>
<td>介质描述符，0xf8表示固定磁盘，0xf0表示可移动磁盘</td>
<td>0x18-0x19</td>
<td>每磁道扇区数</td>
</tr>
<tr>
<td>0x1a-0x1b</td>
<td>磁头数</td>
<td>0x24-0x27</td>
<td>FAT表的扇区数</td>
</tr>
<tr>
<td>0x30-0x31</td>
<td>DBR大小</td>
<td>0x32-0x33</td>
<td>引导扇区的备份扇区号</td>
</tr>
<tr>
<td>0x52-0x59</td>
<td>FAT文件系统类型</td>
<td>0x5a-0x1fd</td>
<td>未使用，但可以包含OS启动代码</td>
</tr>
<tr>
<td>0x1fe-0x1ff</td>
<td>0xAA55结束标志</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>FAT区：由两个相同的FAT表构成，用于备份，其中包含了文件占用的簇链、空闲空间等；FAT中每个簇都有一个表项，例如三号表项就对应的3号簇；表项记录如下（注意虽然是32位，但高4位保留，FAT16=0002H-FEFFH个可用簇号）：</p>
<ul>
<li>未使用/空闲的簇：0x0000</li>
<li>损坏的簇：-9或0xffffff7</li>
<li>文件下一个簇的地址</li>
<li>文件最后一个簇或文件结束标志：-1或0x0fffffff</li>
</ul>
</li>
<li><p>根目录区（ROOT区）：属于数据区的一部分；在FAT32中区域、大小都不固定，而在FAT12/16中，固定在FAT区之后的32个扇区，最多可以存放512（32*16）个目录项；根目录下的任何文件或者子目录都会有一个根目录表项，一般位于第二簇（数据区才开始有簇！）</p>
</li>
<li><p>目录区：属于数据区，一个目录项占32字节。以表的形式存在，又叫做目录表—DIR（Directory_Table）或文件目录表—FDT（File_Directory_Table）每个表项对应一个文件或者子目录相关信息（在FAT中文件和文件夹处理方式相同）</p>
<blockquote>
<p> 子目录项的最后一项为0。长文件名的需要用长文件名（LFN）目录项来存储。文件属性一项最高两位不用：0x01只读、0x02隐藏文件、0x04系统文件、0x08包含磁盘卷标签的表项、0x10子目录表项、0x20归档文件（即长文件名）</p>
</blockquote>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>位置</th>
<th>说明</th>
<th>位置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>00-07</td>
<td>文件正名</td>
<td>08-0A</td>
<td>扩展名</td>
</tr>
<tr>
<td>0B</td>
<td>文件属性(按二进制分)</td>
<td>0C</td>
<td>保留</td>
</tr>
<tr>
<td>0D-0F</td>
<td>文件创建时间，24位</td>
<td>10-11</td>
<td>16位创建时间，相对于1980年</td>
</tr>
<tr>
<td>12-13</td>
<td>16位最近访问时间</td>
<td>14-15</td>
<td>起始簇号的高16位</td>
</tr>
<tr>
<td>16-17</td>
<td>16位最新修改时间</td>
<td>18-19</td>
<td>16位最新修改时间，相对1980</td>
</tr>
<tr>
<td>1A-1B</td>
<td>起始簇号低16位</td>
<td>1C-1F</td>
<td>文件字节长度</td>
</tr>
</tbody>
</table>
</div>
<p>当使用长目录项时，必定会有一个标准目录项，标准目录项中的短文件名由长文件名中派生出来，“长文件名前6个字符+‘~’（0x7e）+1个数字+文件扩展名”。LEN目录项都依次位于标准目录项之前。</p>
<blockquote>
<p>下面是LFN表项的具体内容，同样32字节，一个长文件名文件可能有多个该表项；文件名以Unicode格式保存，且占2字节</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位置</th>
<th>内容</th>
<th>位置</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>序列号</td>
<td>0x1-0xa</td>
<td>长文件名的5个文件名字符</td>
</tr>
<tr>
<td>0xb</td>
<td>长文件名属性，LFN=0x0F</td>
<td>0xc</td>
<td>保留</td>
</tr>
<tr>
<td>0xd</td>
<td>校验和，根据短文件名算出</td>
<td>0xe-0x19</td>
<td>长文件名的6个文件名字符</td>
</tr>
<tr>
<td>0x1a-0x1b</td>
<td>保留</td>
<td>0x1c-0x1f</td>
<td>长文件名的2个文件名字符</td>
</tr>
</tbody>
</table>
</div>
<p>其中序列号从1起，若是最后的则加上’0x40’（或运算）并填入，若对应文件/目录被删记为’0xE5’</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/08/08/aNZUVGriyACpoLm.png" alt="fat32.png"></p>
<p>对于删除的文件来说，文件正名第一字节为<code>0xe5</code>，表示清空回收站；如果只是移动到回收站并没有清空，则只会改变FAT区的簇链。</p>
<h4 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h4><p>win_xp之后首选文件系统，使用B+树来组织目录项，解决了FAT的磁盘大小限制、空间利用率以及文件名长度等问题。NTFS具体内容太过麻烦，这里仅作部分说明（<a target="_blank" rel="noopener" href="https://forensics.xidian.edu.cn/cat/cn/blog/03-ntfs">NTFS文件系统解析 – 取证猫 (xidian.edu.cn)</a>）</p>
<blockquote>
<p>同样用簇为单位，但是稍有区别，在NTFS中有逻辑簇号LCN与虚拟簇号VCN之分，前者是实际上占的簇号，后者是本文件的第几个簇号</p>
</blockquote>
<p>NTFS使用NTFS Log记录详细的事务日志，跟踪卷的文件系统的元数据变化（人话：有相关文件记录元数据）。</p>
<p>格式：1个引导扇区+15个扇区的NTLDR区域+MFT区+文件区</p>
<ul>
<li>引导扇区：包含引导程序和BPB参数（用于定位后面的NTLDR区），格式与FAT的分区引导区相似</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>内容</th>
<th>字节偏移</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>JMP指令</td>
<td>0x03</td>
<td>OEM标识‘NTFS’</td>
</tr>
<tr>
<td>0x0B</td>
<td>每扇区字节数</td>
<td>0x0D</td>
<td>每簇扇区数</td>
</tr>
<tr>
<td>0x0E</td>
<td>保留扇区数</td>
<td>0x10</td>
<td>0</td>
</tr>
<tr>
<td>0x15</td>
<td>介质描述符</td>
<td>0x16</td>
<td>0</td>
</tr>
<tr>
<td>0x18</td>
<td>每磁道扇区数</td>
<td>0x1A</td>
<td>磁头数</td>
</tr>
<tr>
<td>0x1C</td>
<td>隐藏扇区数</td>
<td>0x20</td>
<td>0</td>
</tr>
<tr>
<td>0x28</td>
<td>总扇区数</td>
<td>0x30</td>
<td><code>$MFT</code>簇号</td>
</tr>
<tr>
<td>0x38</td>
<td><code>$MFTMirr</code>簇号</td>
<td>0x40</td>
<td>文件记录段字节数</td>
</tr>
<tr>
<td>0x41</td>
<td>0</td>
<td>0x44</td>
<td>索引缓冲簇数</td>
</tr>
<tr>
<td>0x45</td>
<td>0</td>
<td>0x48</td>
<td>卷序列数</td>
</tr>
<tr>
<td>0x50</td>
<td>校验和</td>
<td>0x54</td>
<td>启动指令码</td>
</tr>
<tr>
<td>0x01FE</td>
<td>0xAA55结束标志</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>NTLDR区：引导程序的一部分（与NTFS没有必要联系，以前多用该程序来启动加载windows）</p>
</li>
<li><p><strong>主控文件表MFT</strong>：包含卷中所有的信息，以数组实现，每个文件记录项大小1KB，一个文件至少一项。在这个表中的前16项位置固定，且有备份；以<code>$</code>符开头，0-11如下，12-15保留。</p>
<blockquote>
<p>注意：MFT区包含下面这些内容，<code>$MFT</code>表项的<code>$DATA</code>属性中记录的是真正MFT项的位置（文件目录的MFT），而<code>$MFTMirr</code>的内容同上</p>
</blockquote>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件名</th>
<th>描述</th>
<th>文件名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$MFT</code></td>
<td>主文件表</td>
<td><code>$MFTMirr</code></td>
<td>主文件表的备份</td>
</tr>
<tr>
<td><code>$LogFile</code></td>
<td>日志文件，记录元数据变化</td>
<td><code>$Volumn</code></td>
<td>卷文件</td>
</tr>
<tr>
<td><code>$AttrDef</code></td>
<td>属性定义列表</td>
<td><code>$Root</code></td>
<td>根目录文件(索引树)</td>
</tr>
<tr>
<td><code>$Bitmap</code></td>
<td>位图文件，每位对应1簇，1有0未</td>
<td><code>$Boot</code></td>
<td>引导文件，包含DBR扇区</td>
</tr>
<tr>
<td><code>$BadClus</code></td>
<td>坏簇记录文件</td>
<td><code>$Secure</code></td>
<td>文件安全属性与访问控制</td>
</tr>
<tr>
<td><code>$UpCase</code></td>
<td>大小写字符转换表文件</td>
<td><code>$Extend</code></td>
<td>扩展属性</td>
</tr>
</tbody>
</table>
</div>
<p>  对于每一个表项（包括上面这些文件），大多以’FILE‘（4B）开头，以0xFF FF FF FF结束；表项=MFT头+属性</p>
<p>  每一个文件/MFT表项有对应的64位文件引用地址=16位序列号（见下表，放高位）+ 48位文件地址（也可以说是表项序号，从0递增，放低位），对于较大文件的属性除了MFT外，还有一个扩展区域来存放多余的内容。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>内容</th>
<th>字节偏移</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-3</td>
<td>MFT标志(好的‘FILE’，坏的‘BAAD’)</td>
<td>4-5</td>
<td>更新序列号</td>
</tr>
<tr>
<td>6-7</td>
<td>更新序列号的大小与数组</td>
<td>8-15</td>
<td>日志文件序列号</td>
</tr>
<tr>
<td>16-17</td>
<td>序列号</td>
<td>18-19</td>
<td>硬连接数</td>
</tr>
<tr>
<td>20-21</td>
<td>第一个属性的偏移地址</td>
<td>22-23</td>
<td>标志00表删除-01正在使用-02目录被删-03目录正在使用</td>
</tr>
<tr>
<td>24-27</td>
<td>文件记录的实际长度</td>
<td>28-31</td>
<td>文件记录的分配长度</td>
</tr>
<tr>
<td>32-39</td>
<td>基本文件记录中的文件索引号</td>
<td>40-41</td>
<td>下一个属性ID</td>
</tr>
<tr>
<td>42-43</td>
<td>边界</td>
<td>44-47</td>
<td>文件记录参考号</td>
</tr>
<tr>
<td>48-1023</td>
<td>属性和固定值</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>  属性分为两部分，属性头+属性体（属性内容）。属性头描述了本属性名字长度等，以及最关键的是常驻属性（属性内容存在MFT中）还是非常驻属性（存在文件区），一般来说900B以下的都是常驻属性，其属性体数据结构不同。</p>
<blockquote>
<p>常驻与非常驻用于说明属性内容的位置，属性内容是说明是什么。每一个属性都有独特的数据结构，即属性体结构。在NTFS中文件内容是属性的一部分，对应的属性类型为<code>$DATA</code></p>
</blockquote>
<p>  常驻属性头格式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>内容</th>
<th>字节偏移</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-3</td>
<td>属性类型</td>
<td>4-7</td>
<td>属性长度</td>
</tr>
<tr>
<td>8</td>
<td>0常驻，1非常驻</td>
<td>9</td>
<td>属性名长度</td>
</tr>
<tr>
<td>10-11</td>
<td>属性名的开始偏移</td>
<td>12-13</td>
<td>标志</td>
</tr>
<tr>
<td>14-15</td>
<td>属性ID</td>
<td>16-19</td>
<td>属性体大小</td>
</tr>
<tr>
<td>20-21</td>
<td>属性体偏移</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>  非常驻属性头据格式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>内容</th>
<th>字节偏移</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-15</td>
<td>同常驻（）</td>
<td>16-23</td>
<td>属性体的起始虚拟簇号</td>
</tr>
<tr>
<td>24-31</td>
<td>属性体结束虚拟簇号</td>
<td>34-35</td>
<td>压缩单位大小</td>
</tr>
<tr>
<td>36-39</td>
<td>无意义</td>
<td>40-47</td>
<td>属性体的分配大小</td>
</tr>
<tr>
<td>48-55</td>
<td>属性体实际大小</td>
<td>56-63</td>
<td>属性体初始大小</td>
</tr>
<tr>
<td>64+</td>
<td>DataRun（属性内容）</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>  非常住属性的内容叫做数据流DataRun，流的大小不一，其第一个字节的低4位表示流大小的字节数，高4位表示包含流的起始簇地址的字节数（DataRunList），后面紧跟着分别是数据流长度+数据流偏移（单位都是簇）</p>
<blockquote>
<p>关于虚拟簇号即VCN，区别于逻辑簇号LCN，前者的起始位置是本文件系统开头，后者则是实际的硬盘上的簇号位置</p>
</blockquote>
<p>特性：NTFS中其索引区别于FAT的线性搜索，采用的是B*树进行，索引和名字等都是以属性记录的。此外在NTFSv3之后，还有EFS，即加密文件系统，可以命令行下使用<code>cipher.exe</code>来使用。在NTFS中还有稀疏文件与文件压缩的方法，来提高空间利用率</p>
<blockquote>
<p>稀疏文件：将文件内容（仅<code>$DATA</code>）中的非0数据写入磁盘，而将连续的0以非常驻属性中的备用流表示，该流仅包含流的长度（0数据的簇数），而没有其起始地址。剩下的非0数据则以常规数据流形式存在</p>
</blockquote>
<p>对于NTFS文件的删除，首先要在<code>$Root</code>中删除相关索引项，之后设置对应的MFT表项，最后在<code>$Bitmap</code>中将对应的位设置为0.</p>
<h3 id="Windows内存结构与管理"><a href="#Windows内存结构与管理" class="headerlink" title="Windows内存结构与管理"></a>Windows内存结构与管理</h3><p><strong>DOS内存布局</strong>：运行于实模式中，寻址范围只有1MB。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>F0000-FFFFF</td>
<td>ROM BIOS</td>
</tr>
<tr>
<td>A0000-F0000</td>
<td>设备保留区</td>
</tr>
<tr>
<td>400-4F0、4F0-500、500-700</td>
<td>BIOS、用户、DOS通信区</td>
</tr>
<tr>
<td>0-400</td>
<td>中断向量表</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Windows内存布局</strong>：</p>
<p>开机后一般运行于保护模式下，这就使得每个32位进程都拥有4GB的虚拟内存寻址空间，且会根据OS版本对虚拟内存空间进行划分，下面是x86下32win的虚拟内存大致分布情况</p>
<ul>
<li><p>FFFFFFFF-80000000=2GB（内核模式分区）：操作系统使用，不可读写；其中的数据所有进程共享，但被保护</p>
<blockquote>
<p>Ring0（用户模式）-Ring3（内核模式）；Ring0仅限于用户模式区，后者可访问所有内存、硬件、使用所有处理器指令，但是对其代码空间不提供保护</p>
</blockquote>
</li>
<li><p>7FFFFFFF-7FFF0000=64KB（禁入分区）：防止跨系统或跨用户边界的传输数据，不可读写</p>
</li>
<li><p>7FFEFFFF-00010000（用户模式区）：进程私有空间</p>
</li>
<li><p>0-0000FFFF=64KB（空指针赋值区）：用户捕捉NULL指针，不可读写；用来帮助程序员捕获对空指针的赋值</p>
</li>
</ul>
<p><strong>虚拟地址转译</strong>：默认情况下x86上的windows使用二级页表，来将虚拟地址转换为物理地址，页表大小默认4KB；</p>
<p>32位虚拟地址=页目录索引+页表索引+字节索引（12bit）</p>
<blockquote>
<p>CR3寄存器页目录——页目录索引找到具体页目录项(PDE)——页表——根据页表索引找到页表项(PTE)——得到具体物理地址</p>
</blockquote>
<p><strong>内存分配与管理函数</strong>：内存API大致分三类有以下三类</p>
<ul>
<li><p>虚拟内存管理：适用于占用内存较大，但不一定立即用到的程序；能够提前分配一小部分内存，需要时就会从保留的内存块中再利用</p>
<ol>
<li>分配/保留虚拟内存；参数：内存地址—大小—类型—保护标志</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(IpMem,Size,Type,Access)</span><br><span class="line"><span class="comment">//Ipmem可NULL,Size单位字节</span></span><br><span class="line"><span class="comment">//Type类型MEM_COMMINT提交内存、MEM_RESERVE保留内存、MEM_TOP_DOWN尽可能在高地址分配内存</span></span><br><span class="line"><span class="comment">//Access,PAGE_READONLY内存可读、PAGE_READWRITE可读可写</span></span><br></pre></td></tr></table></figure>
<ol>
<li>释放虚拟内存；参数：地址—大小—类型</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualFREE</span>(IpMem,Size,Type)</span><br><span class="line"><span class="comment">//Type为释放的类型,MEM_DECOMMIT取消内存提交、MEM_RELEASE释放</span></span><br></pre></td></tr></table></figure>
<ol>
<li>改变页保护属性；参数：地址—大小—类型—旧属性地址</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualProtect</span>(IpMem,Size,Access,IpOldAccess)</span><br><span class="line"><span class="comment">//前三者同上，最后是一个地址用来存放旧的保护属性</span></span><br></pre></td></tr></table></figure>
<ol>
<li>内存锁定与解锁；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualLock</span>(IpMem,Size)		<span class="comment">//确保进程运行时，指定内存总在内存中</span></span><br><span class="line"><span class="built_in">VirtualUnlock</span>(IpMem,Size)	<span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>堆管理：适用于经常需要分配小块内存的程序</p>
<blockquote>
<p>缺省堆：默认1MB，进程在编译时个已更改该值，在程序运行时如果需要使用临时内存则会从其中分配内存。Win32确保在任意时刻都只能有一个线程可以在缺省堆上分配释放内存</p>
</blockquote>
<ol>
<li>创建新堆</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapCreate</span>(flOption,dWINitalSize,cbMaximumSize)</span><br><span class="line"><span class="comment">//flOption可选：0、HEAP_NO_SERIALIZE、HEAP_GENERATE_EXCEPTIONS</span></span><br><span class="line"><span class="comment">//后两者指出堆的初始化大小和最大容量，单位Byte，会自动对齐为页大小的整数倍</span></span><br></pre></td></tr></table></figure>
<ol>
<li>分配堆内存/重新分配堆内存</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapAlloc</span>(hHeap,dwFlags,dwBytes)</span><br><span class="line"><span class="comment">//堆句柄，可由HeapCreate、GetProcessHeap取得</span></span><br><span class="line"><span class="comment">//可选HEAP_ZERO_MEMORY(内存清0)、HEAP_GENERATE_EXCEPTIONS、HEAP_NO_SERIALIZE</span></span><br><span class="line"><span class="comment">//要分配的堆内存大小</span></span><br><span class="line"><span class="built_in">HeapReAlloc</span>(hHEAP,dwFlags,lpMem,dwBytes)</span><br><span class="line"><span class="comment">//第三个参数指明内存堆地址</span></span><br></pre></td></tr></table></figure>
<ol>
<li>释放堆内存</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapFree</span>(hHeap,dwFlags,lpMem)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存映射文件管理：简单说就是无需打开文件等操作，可以通过映射快速操纵文件内容</p>
<p>相关API<code>CreateFileMapping()</code>、<code>MapViewOfFile()</code>、<code>UnmapViewOfFile()</code>、<code>FlushViewOfFile()</code></p>
</li>
</ul>
<h3 id="Windows内存安全机制"><a href="#Windows内存安全机制" class="headerlink" title="Windows内存安全机制"></a>Windows内存安全机制</h3><p>相关位置在windows Defender中应用和浏览器控制下的攻击防护设置</p>
<h4 id="数据执行保护DEP"><a href="#数据执行保护DEP" class="headerlink" title="数据执行保护DEP"></a>数据执行保护DEP</h4><p>通过使可写内存的不能执行，或者来让可执行内存不可写来消除威胁。常用于防范缓冲区溢出，其他叫法：NX/XD/WX；</p>
<p>具体见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/memory/data-execution-prevention">数据执行保护 - Win32 apps | Microsoft Learn</a>；</p>
<p>在Win中DEP相关设置如下：</p>
<ul>
<li>OptOut：除了手动添加到排除列表中的进程外，均开起了DEP保护；多用在Server中</li>
<li>OptIn：仅应用于核心的系统可执行文件；多用于普通win</li>
<li>AlwaysOn：对所有进程启用DEP保护，没有例外，不可关闭</li>
<li>AlwaysOff：所有禁用，也不能被动态开启</li>
</ul>
<p>具体实现有两种模式：硬件实现和软件实现</p>
<ul>
<li>如果CPU支持内存页NX属性，则支持硬件实现，可通过Windows DEP tabsheet查看（桌面环境下高级系统设置-高级性能设置-数据执行保护）</li>
<li>软件支持的DEP不能直接阻止在数据页上执行代码</li>
</ul>
<p><strong>对抗措施</strong>：通过执行已经加载的模块中的指令，或者是调用系统函数不受DEP的影响，但是使用的栈上的参数则是攻击者构造的。</p>
<ul>
<li><p>利用ret-to-libc执行命令或进行API调用，如WinExec等</p>
<blockquote>
<p>在库中找到一段执行系统命令的代码或函数，用这段代码的地址覆盖返回地址；参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhang293/p/9026587.html">内存保护机制及绕过方法——利用Ret2Libc绕过DEP之ZwSetInformationProcess函数 - zhang293 - 博客园 (cnblogs.com)</a></p>
</blockquote>
</li>
<li><p>将包含ShellCode的内存页面标记为可执行，在跳过去执行</p>
</li>
<li><p>分配可执行内存，再将ShellCode复制到其中，再跳进去执行</p>
<blockquote>
<p>需要使用ROP技术（能够连续调用已存在的程序代码，来创建一连串指令码序列）调用API函数WriteProcessMemory、HeapCreate、VirtualAlloc、memcopy实现</p>
</blockquote>
</li>
<li><p>尝试关闭DEP再运行ShellCode</p>
<blockquote>
<p>一个进程的DEP开启标志保存在内核结构中（_KPROCESS），当DEP置用时ExecuteDisable被置位，禁用时ExecuteEnable被置位，当Permanent置位时表明这些设置不可更改。需要借助NtQueryInformationProcess()和NtSetInformationProcess()函数来设置ProcessExecuteFlags类。</p>
</blockquote>
</li>
</ul>
<h4 id="栈溢出检查GS"><a href="#栈溢出检查GS" class="headerlink" title="栈溢出检查GS"></a>栈溢出检查GS</h4><p>在VS中默认设置该选项</p>
<p>原理：当程序启动时，会首先计算出该程序的cookie值（动态、4B），然后将其保存在加载模块的.data节中，如果函数被调用，那么该值就会被复制到栈中（retAd、EBP之后，局部变量之前），用于在函数结束时进行检查。此外他对栈中变量进行重新排序：对函数栈帧进行重排，将字符串缓冲区分配在栈帧的最高地址上、将函数参数复制到寄存器或栈缓冲区上，防止参数被溢出</p>
<p>条件：当函数有字符串缓冲区（且&gt;=5字节时）或使用_alloca函数在栈上分配空间时，编译器才在栈中保存该cookie值。</p>
<p><strong>缺陷</strong>：</p>
<ul>
<li>一个函数中含有多个缓冲区时，都放在同一个栈里面，可以从一个缓冲区溢出到另一个缓冲区</li>
<li>对于参数数量不确定的函数来说，预先不知道函数参数的个数，因此无法进行保护</li>
<li>alloca()函数动态分配的缓冲区不可避免地放在栈顶</li>
<li>结构成员当中如果有缓冲区时，这个缓冲区将位于struct或class声明的固定位置</li>
</ul>
<p><strong>绕过</strong>：</p>
<ul>
<li>利用异常处理器绕过cookie检查</li>
<li>替换栈和.data节中的cookie来绕过</li>
<li>覆盖父函数的栈数据来绕过GS检查</li>
</ul>
<h4 id="地址空间随机分配ASLR"><a href="#地址空间随机分配ASLR" class="headerlink" title="地址空间随机分配ASLR"></a>地址空间随机分配ASLR</h4><p>进行随机化的对象有：映像（可执行文件和DLL的加载地址）、栈（每个线程起始栈的地址）、堆（改变已分配堆的基地址）</p>
<p>实现方式：VS编辑器—DYNAMICBASE、映像加载基址随机化</p>
<p><strong>缺陷及绕过</strong>：一个被多个进程同时使用的DLL，由于一直有人使用，因此其地址是固定的</p>
<ul>
<li>返回地址部分覆盖：随机化一般发生在地址的高16位，找到对应高地址空间下可以利用的跳转指令进行覆盖</li>
<li>大多程序在编译时没有使用随机化，因此这些程序中没有启用ASLR的模块的相关跳转指令便可以作为跳板，用来引导至恶意代码</li>
</ul>
<h4 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h4><p>SafeSHE用来检测和保护和防止堆栈中的SEH函数指针被覆盖的技术</p>
<p>原理：编译器在链接生成二进制映像文件时，会将所有合法的异常处理函数的地址解析出来制作成一张安全的SEH表，并保存在程序映像文件中的数据块里，每当这些函数被调用时，就会与SEH表中的地址进行匹配（如果映像文件不支持，则该表的地址为0）</p>
<p>加载过程：程序影响加载到内存时，系统定位该表，并使用Shareuser内存中的一个随机数进行加密，将加密后的表地址、映像文件开始地址、长度、合法SEH函数数目作为一条记录放入到ntdll加载模块数据内存中</p>
<p>异常处理过程：首先检查该异常处理程序是否在栈中，不在的话则不执行；并再次被检查是否位于映像文件的地址空间；在的话，则执行，否则：</p>
<p>如果该地址位于不可执行页上，则检查DEP开启状态（开了就报错，否则执行）；若位于可执行页上，则判断系统是否允许跳转到加载模块的内存空间外执行，可以则执行否则抛错</p>
<p><strong>绕过</strong>：必须要使用.Net编译器且开启SafeSEH连接选项</p>
<ul>
<li>利用未启用SafeSEH的模块作为跳板</li>
<li>利用加载模块之外的地址进行绕过（比如堆区一般会直接跳转执行）</li>
</ul>
<h3 id="Win技术栈"><a href="#Win技术栈" class="headerlink" title="Win技术栈"></a>Win技术栈</h3><p>Windows API：Win操的内核提供的接口函数，常见的就是Win32 API，但目前的win基本都是64位的，为了兼容早些时候的32位的应用，64位win中模拟出了一个32位的win，也就是一个子系统，在WoW64中实现。上述API函数一般都是位于dll中的</p>
<ul>
<li><code>kernel32.dll</code>：负责内存管理、进程管理等</li>
<li><code>user32.dll</code>：负责处理用户的请求</li>
<li><code>gdi32.dll</code>：用于在屏幕上显示文本图形</li>
</ul>
<p>Windows SDK：Software Develope Kit即软件开发工具包，顾名思义里面包含了开发所需要用到的一系列的库和工具（比如编写C语言时的头文件与相关库等）</p>
<p>COM：是一种规范/标准，由于C++的二进制层面标准问题，微软自己规定的该标准，用于方便在windows上实现软件组件之间的相互操作。</p>
<p>ATL：Active Template Library则是微软提供的一个<strong>模板库</strong>，用于简化上述COM组件的开发。（这里单独拿出来，但实际上是作为MFC的补充库）</p>
<p>MFC：Microsoft Foundation Class是一个<strong>类库</strong>，一般用于开发具有图形界面的应用程序。如果是Win32API写的话需要大量的过程，而MFC则以类的形式封装。</p>
<p>WinRT&amp;UWP：即Windows Runtime，是一种标准，建立在之前的COM上。相比与早期的Win下用MFC和ATL进行开发，该标准以C++17的特性等为基础，最大的特点是使用该标准（一堆API函数）实现的应用，也就是UWP（Universal Windows Platform）windows通用平台应用，可以在不同版本的Win版本中运行。</p>
<blockquote>
<p>微软商店中下载到的都属于UWP应用，在WinPhone/Win10/11中下载到的东西都是一样的。UI与功能都算是实现了一次开发，多处运行。</p>
</blockquote>
<p>.NET：这是一个比较大的话题了，是微软用来与Java体系竞争的，这么理解会容易点。Java、Kotlin=C#、F#、VB；JVM=CLR（Common Language Runtime）公共语言运行时。这里主要还是C#占大头<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fv411h73J">.net Framework、Standard、Core都是些什么东西_哔哩哔哩_bilibili</a></p>
<ul>
<li><p><code>.NET FramWork</code>是一种框架（旧版本），当时只能在Win中运行。</p>
</li>
<li><p><code>.NET Core</code>是上面框架<code>FramWork</code>的提升，可以跨平台，也是一堆API</p>
</li>
<li><code>.NET</code>上面FrameWork和Core的统一，从5.0开始，后面都是开源的</li>
<li><code>.NET Standard</code>规范，说通俗点就是统一后的API</li>
<li><code>ASP</code>是在<code>.NET</code>上实现的用于Web的框架/库，类比于JavaWeb等。</li>
<li><code>ADO</code>用于在该平台上访问和操作数据的，类比于JDBC</li>
<li><code>WPF</code>、<code>WinForm</code>也是框架，用于Windows图形桌面应用的开发。<code>UWP</code>也可以用C#等语言开发</li>
<li><code>mono</code>早些FrameWork仅提供于win下，社区就自己开发了这个跨平台，目前已整合到.NET中</li>
</ul>
<h3 id="Windows认证"><a href="#Windows认证" class="headerlink" title="Windows认证"></a>Windows认证</h3><p>本机用户密码的hash存放在<code>/Windows/System32/config/SAM</code>中，该文件在OS启动之后被锁定/占用，用户无法打开。对于Kerberos域环境下的域控则是在<code>NTDS.DIT</code>文件中</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2445?time__1311=n4%2BxnieDqQqWqBIKGNcmYxgDjxYT92rETWD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-13">LM-Hash &amp;&amp; NTLM-Hash - 先知社区 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/336237.html">内网攻防：LM 与 NTLM认证以及NTLM中继攻击与反射 - FreeBuf网络安全行业门户</a></p>
</blockquote>
<h4 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h4><p>本地认证流程：</p>
<ol>
<li>开机，winlogon.exe进程显示登陆界面要求输入用户名和密码</li>
<li>用户输入后由winlogon.exe发送给lsass.exe进程</li>
<li>lsass.exe计算明文密码相应的hash</li>
<li>之后与SAM数据库中的对比，正确就返回User SID和组发给winlogon.exe</li>
</ol>
<p>LM Hash：xp及server 03之前，基于DES算法。</p>
<ol>
<li>密码——》大写——》16进制字符串，不足14字节的话后面补0</li>
<li>14字节对半分——》拆开后转为比特流，不足56bit的在左边+0</li>
<li>将56bit再分为7bit一组，每组末尾+0</li>
<li>将两个变换后的64bit——》16进制——》分别作为DES密钥，对明文<code>KGS!@#$%</code>进行加密</li>
<li>两串密文拼接</li>
</ol>
<p>NTLM hash：密码字符串——》ASCII字符串——》Hex进制字符串——》Unicode字符串——》MD4消息摘要算法</p>
<h4 id="网络认证"><a href="#网络认证" class="headerlink" title="网络认证"></a>网络认证</h4><p>上面说的都是本地登录，在网络环境下，windows也有相应机制。早期的基于LM hash的LM机制，以及目前的NTLM协议与Kerberos协议。</p>
<blockquote>
<p>NTLM协议包括v1、v2、session v2三个版本，我们这里仅说明最简单的v1版本。</p>
<p>具体实现：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/13101?time__1311=mqmxnDBDcD0A3x05d4%2BxCqkDj2QiDuQD80YD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F">NTLM认证详解 - 先知社区 (aliyun.com)</a></p>
</blockquote>
<p>NTLM认证协议，基于Challenge/Response挑战响应验证机制，用于对域上主机进行身份验证。</p>
<p>NTLM v1：</p>
<ol>
<li>用户登陆客户端之后，客户端对密码hash处理后缓存，并将用户名发送给服务端，发起认证请求</li>
<li>服务器生成8B的随机数（质询Challenge），并返回客户端（v2中是16B）</li>
<li>客户端使用缓存的hash对此随机数进行DES加密，得到Response并发送给服务器（v2中是HMAC-MD5加密）</li>
<li>服务器发送“用户名”、“Challenge”、“Response”给域控制器</li>
<li>域控根据“用户名”在其数据库中检索对应的NTLM Hash密码，并用此来加密“Challenge”，之后与“Response”比较，相同则验证成功</li>
</ol>
<h4 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h4><p>又名三头犬协议，基于票据Ticket，经常使用于域环境中。什么是域环境，可以理解为一个公司的内部网络，该协议用于在内部网络下进行身份检验等，目前的windows server中默认使用该协议。</p>
<p>三头犬，指的三个基本概念：KDC密钥分发中心（和WinDefender一样占一个用户）、Client客户端、Server服务端。</p>
<p>当一个新的员工来到公司，访问自家服务器大致需要经过如下步骤：</p>
<ol>
<li>C首先向KDC服务器获取TGT（票据授权票据），该票据有一定的时间限制</li>
<li>之后C再次向KDC访问，需要访问什么服务器，就获取对应的Server Ticket（也可以叫TGS Ticket）</li>
<li>C来到想要访问服务器前，提交自己的信息和上面的Server Ticket，服务端验证通过后可以向C提供服务</li>
</ol>
<p>综上，大致就是先验证身份=正式加入公司了，之后获取访问服务器的权限。接下来我们再向下进一步</p>
<p>KDC包括以下三个部分：</p>
<ul>
<li>一个DB：包含一个域内所有的用户名、密码等信息</li>
<li>AS-授权服务中心：对用户的身份进行验证，之后颁发TGT（第一次访问对象）</li>
<li>TGS-票据授予服务：验证TGT与C的权限，验证可以之后颁发对应的Server Ticket（第二次访问对象）</li>
</ul>
<p>Client向KDC获取TGT：</p>
<ol>
<li><p>Client通过命令行工具<code>kinit</code>将自己的用户名、加密类型、时间戳、要访问的服务器名等信息根据密码加密之后发给AS，方便起见就叫信息包A。注意KDC中必定也有密码，就形成了对称加密，当然密码一般都经过加盐哈希处理</p>
</li>
<li><p>AS收到请求后根据DB中存储的密码来进行验证，成功之后AS先随机生成一个TGS session key，之后发送两个东西：由TGS密码加密生成TGT（包括Client的ID、TGS session key等）、由Client密码加密的信息包B（包括要访问的服务器ID、TGS session key等）</p>
</li>
<li><p>Client对信息包B按照自己的密码解密，如果错误则本地验证失败。</p>
<blockquote>
<p>此时的Client多了一个TGS session key和TGT</p>
</blockquote>
</li>
</ol>
<p>Client向KDC获取ST：</p>
<ol>
<li><p>Client首先利用TGS session key对自身ID等信息加密后得到信息包C，带着TGT一起发送给TGS</p>
</li>
<li><p>TGS首先利用密码解密TGT得到TGS session key，之后再对信息包C解密，获得Client信息</p>
</li>
<li><p>TGS将信息包C中的信息和解密后的TGT进行对比验证，并检查TGT是否过期</p>
</li>
<li><p>验证成功后TGS随机生成Server session key，并发送两个东西给Client：由Server密码加密的ST（包括Server session key、Client的ID等）、由TGS session key加密的信息包D（包括客户端信息与时间戳、Server session key）</p>
</li>
<li><p>Client利用TGS session key对信息包D解密验证</p>
<blockquote>
<p>此时Client又多了一个ST和Server session key</p>
</blockquote>
</li>
</ol>
<p>Client访问Server：</p>
<ol>
<li>Client将ST和Server session key加密过的自身信息，这里就叫做信息包E，一起发送给Server</li>
<li>Server首先利用自己的密码对ST进行解密，得到Server session key，并用这个东西对信息包E进行解密来获取Client信息</li>
<li>之后服务端对Client信息进行检查，包括是否过期、客户端ID、时间戳等</li>
<li>一切验证无误之后正常交流</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zy0t1.github.io">Zy0t1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zy0t1.github.io/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/">http://zy0t1.github.io/2023/09/07/Windows%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B2%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zy0t1.github.io" target="_blank">Zy0t1's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/Windows/">Windows</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/16/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/" title="对称密码&amp;Hash"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">对称密码&amp;Hash</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/07/Linux%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AF%B4%E6%98%8E/" title="Linux不完全说明"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux不完全说明</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/web.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zy0t1</div><div class="author-info__description">中二次元晚期</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zy0t1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zy0t1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wy1078041755@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62036500" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC"><span class="toc-number">2.</span> <span class="toc-text">命令与批处理脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cwin-R%E9%94%AE"><span class="toc-number">2.1.</span> <span class="toc-text">运行win+R键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cmd%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">cmd基本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC"><span class="toc-number">2.3.</span> <span class="toc-text">批处理脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">系统文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">PE文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Win%E5%BC%95%E5%AF%BC"><span class="toc-number">5.</span> <span class="toc-text">Win引导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FAT32"><span class="toc-number">6.1.</span> <span class="toc-text">FAT32</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NTFS"><span class="toc-number">6.2.</span> <span class="toc-text">NTFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">Windows内存结构与管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">Windows内存安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%89%A7%E8%A1%8C%E4%BF%9D%E6%8A%A4DEP"><span class="toc-number">8.1.</span> <span class="toc-text">数据执行保护DEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%A3%80%E6%9F%A5GS"><span class="toc-number">8.2.</span> <span class="toc-text">栈溢出检查GS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%9A%8F%E6%9C%BA%E5%88%86%E9%85%8DASLR"><span class="toc-number">8.3.</span> <span class="toc-text">地址空间随机分配ASLR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SafeSEH"><span class="toc-number">8.4.</span> <span class="toc-text">SafeSEH</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Win%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">9.</span> <span class="toc-text">Win技术栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E8%AE%A4%E8%AF%81"><span class="toc-number">10.</span> <span class="toc-text">Windows认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81"><span class="toc-number">10.1.</span> <span class="toc-text">本地认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81"><span class="toc-number">10.2.</span> <span class="toc-text">网络认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kerberos"><span class="toc-number">10.3.</span> <span class="toc-text">Kerberos</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Zy0t1</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>