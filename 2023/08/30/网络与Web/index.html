<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络基础 | Zy0t1's blog</title><meta name="author" content="Zy0t1"><meta name="copyright" content="Zy0t1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一些关于网络与Web的知识，尽量不向网络中的底层涉及，侧重于实际用到的">
<meta property="og:type" content="article">
<meta property="og:title" content="网络基础">
<meta property="og:url" content="http://zy0t1.github.io/2023/08/30/%E7%BD%91%E7%BB%9C%E4%B8%8EWeb/index.html">
<meta property="og:site_name" content="Zy0t1&#39;s blog">
<meta property="og:description" content="一些关于网络与Web的知识，尽量不向网络中的底层涉及，侧重于实际用到的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp">
<meta property="article:published_time" content="2023-08-30T10:04:23.000Z">
<meta property="article:modified_time" content="2024-08-08T03:30:24.621Z">
<meta property="article:author" content="Zy0t1">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp"><link rel="shortcut icon" href="/img/web.png"><link rel="canonical" href="http://zy0t1.github.io/2023/08/30/%E7%BD%91%E7%BB%9C%E4%B8%8EWeb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-08 11:30:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/web.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Zy0t1's blog"><span class="site-name">Zy0t1's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-30T10:04:23.000Z" title="发表于 2023-08-30 18:04:23">2023-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-08T03:30:24.621Z" title="更新于 2024-08-08 11:30:24">2024-08-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>
<h3 id="0x01-URL"><a href="#0x01-URL" class="headerlink" title="0x01.URL"></a>0x01.URL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#anchor</span><br></pre></td></tr></table></figure>
<p>首先介绍一下格式：协议 // 主机 ：端口/路径 .html ? 查询参数 # 锚点</p>
<p>URI （统一资源标识符）一种概念—实现方式：URL（统一资源定位符）、URN（统一资源命名符）</p>
<blockquote>
<p>URN需要解析器对该目标文件的独一无二的、不变的字符串进行解密来推出当前所在位置</p>
</blockquote>
<ul>
<li><p>协议：就是网络协议，在计算机网络中有具有规定信息交流的作用；包括http和https（超文本传输协议；网页），后者是前者的加密版本，具有更高的安全性（但目前http用的还是多）这样的协议还有FTP（文件传输协议；下载文件）、SMTP（电子邮件传输协议；发送接收电子邮件）</p>
</li>
<li><p>主机：就是我们所需要的网页文件等在哪台服务器上，上述例子中的主机段写（包括平常写的<code>www.xxxxxx.com</code>）是该网站所在的服务器的域名，在经过DNS服务器之后，会转换为IP地址（比如192.168.1.1等）；简单说就是该网站所存在的服务器的地址 （PS：如果记得IP地址的话，也可以用IP替换域名输入）</p>
</li>
<li><p>端口：首先说明端口是干什么的：确定你所需要的服务，然后从这个门（端口）进去。平时在浏览网站时很少会见到这个东西，因为端口大多都是默认的（有对应关系）；端口还分为物理意义上的端口和逻辑意义上的端口，我们这里介绍的是逻辑意义上的端口，物理端口指的就是集线器，HUB，路由等；</p>
<blockquote>
<p>逻辑意义上的接口范围是0~65535（TCP/UDP都有65535个端口），其中公认端口（每个端口有明确的服务）0—1023，动态端口（不固定服务）1024—65535</p>
</blockquote>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口号</th>
<th>服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>20、21</td>
<td>FTP（20连接、21传输）</td>
</tr>
<tr>
<td>25</td>
<td>SMTP</td>
</tr>
<tr>
<td>53</td>
<td>DNS</td>
</tr>
<tr>
<td>22</td>
<td>SSH</td>
</tr>
<tr>
<td>80/443</td>
<td>HTTP/S</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>路径：简单来说就是我们计算机上的文件的位置，网页文件（.html）在服务器上也有相应的存储路径。下面再来介绍一下相对路径和绝对路径</p>
<blockquote>
<p>绝对路径：这个最简单理解，就是 E:\学习资料\Asia 这样的，后面可以跟上具体的 文件名字.文件格式 animal_video01.mp4</p>
<p>相对路径：就是以当前的文件位置为基准，比如选取上面的Asia中的一个文件时可以直接输入animal_video02.mp4；如果我想要换成Europe（在学习资料目录下，与Asia同等级）就输入../Europe/animal_video01.mp4；如果是想要在当前目录继续向下就是2022/AKT01.mp4。总结一下就是，向上一级../ ，向下一级 /文件名</p>
</blockquote>
</li>
<li><p>查询参数：举个例子吧，在网上找百度网盘的资源时，会让你输入提取码，从URL上面来看 就是？后面会跟着一个password=xxxxxx，当你输入密码的时候，后面的xxxxxx就会变成你所输入的密码，也就是所说的参数；当然参数也不止这点功能，根据参数的不同，调用出来的界面也不一定相同（就像百度网盘提取码输入错误和正确，肯定是两个不同的界面）</p>
</li>
<li><p>锚点：显示当前网页内部的定位符号，类似于一键返回顶端这个功能。需要注意的是，服务器并不会处理锚点，走到预定位置是浏览器实现的</p>
</li>
</ul>
<hr>
<h3 id="0x02-DNS"><a href="#0x02-DNS" class="headerlink" title="0x02.DNS"></a>0x02.DNS</h3><p>域名系统，作用就是将难记的IP地址转换为相对简单的网址，DNS服务器中存储的信息就是前面所说对应关系。</p>
<ul>
<li><p>功能：域名到IP的转换、设置主机别名、邮件服务器别名、负载分配</p>
</li>
<li><p>应用层协议，运行在UDP上，53号端口。</p>
</li>
<li><p>DNS域名解析过程如下:</p>
<p>浏览器输入目标域名——本地hosts文件检查，有就调用——查找本地DNS解析器<strong>缓存</strong>——查找首选DNS服务器——根DNS——顶级域名DNS——权威服务器——返回本地DNS服务器</p>
</li>
</ul>
<blockquote>
<p>在该过程中，上级服务器给自己一个DNS，自己再去查，叫做递归查询；如果是上级服务器直接查找到目标，然后再返回给自己叫迭代查询</p>
</blockquote>
<ul>
<li>域名等级：<code>.com</code>顶级域名，<code>bilibili.com</code>一级域名，<code>www.bilibili.com</code>二级域名；需要注意的是，如果需要使用二级域名，首先必须注册对应的一级域名。下面是一些常见的顶级域名：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>顶级域名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>.com / .net  /.org</td>
<td>目前来说使用没有限制（商业/网络服务商/非营利组织）</td>
</tr>
<tr>
<td>.gov</td>
<td>政府机构</td>
</tr>
<tr>
<td>.edu</td>
<td>教育机构</td>
</tr>
<tr>
<td>.mil</td>
<td>军事机构</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>DNS资源记录（RR）：提供了主机名到IP地址的映射，每条记录均是4元组：(Name,Value,Type,TTL)；TTL记录该条记录的剩余存活时间，替他三项依据Type而定（由表可见，邮件服务与Web服务可在一台服务器上）：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>A/AAAA</td>
<td>主机名</td>
<td>IPv4/6地址</td>
</tr>
<tr>
<td>NS</td>
<td>域</td>
<td>具体主机名</td>
</tr>
<tr>
<td>CNAME</td>
<td>别名</td>
<td>规范主机名</td>
</tr>
<tr>
<td>MX</td>
<td>邮件服务器别名</td>
<td>规范主机名</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>DNS报文：查询回答报文格式相同；</p>
<p>12B的首部区域=标识符2B + 标志4b + 问题数+回答RR数+权威RR数+附加RR数</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>区域</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>问题区</td>
<td>正在查询的主机名字+问题类型</td>
</tr>
<tr>
<td>回答区</td>
<td>存RR</td>
</tr>
<tr>
<td>权威区</td>
<td>TLD</td>
</tr>
<tr>
<td>附加信息区</td>
<td>else</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="0x03-IP"><a href="#0x03-IP" class="headerlink" title="0x03.IP"></a>0x03.IP</h3><p>标识本机在网络中的地址，目前分为IPv4和IPv6地址，位于OSI模型的网络层；</p>
<ul>
<li><p><strong>IPv4</strong>：一共分为A、B、C、D、E五类，IPv4地址共有4个字段，也就是说32bit，每8bit用十进制表示；</p>
<p>IPv4地址由两部分构成-网络地址和主机地址，网络地址用于著名在哪个网络中，主机地址用于表明在这个网络中的位置；</p>
<p>这里是各个等级对应的范围（其中全0，全1的IP地址保留不用）下面从二进制来看一下ABC三类地址的构造</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>范围（左闭右开）</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0.0.0.0~128.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>128.0.0.0~192.0.0.0</td>
</tr>
<tr>
<td>C</td>
<td>192.0.0.0~224.0.0.0</td>
</tr>
<tr>
<td>D</td>
<td>224.0.0.0~240.0.0.0</td>
</tr>
<tr>
<td>E</td>
<td>240.0.0.0~248.0.0.0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>CIDR</strong>：消除了上述IPV4的A、B、C类网络的概念，因为实在是不公平，对于低类网络来说，基数大，但是能有主机号少，而等级高的其实也用不了那么多，因此采用CIDR技术，来消除上述不等；举ge例子<code>192.168.1.1/20</code>表示，前20位是网络号，后面的12位就是主机号。</p>
<p><strong>子网掩码</strong>：出于CIDR的使用而产生用来区分网络号与主机号，在IPV4中，子网掩码与其长度相同，均为32位。其转换为二进制时，1必须是连续的，有多少个1，就代表IP地址前几位是网络号（即网络地址），后面的则是主机号，可以通过IP地址与子网掩码的与运算确定网络地址。</p>
</li>
<li><p><strong>WAN</strong>指广域网（互联网），<strong>MAN</strong>指城域网，<strong>SAN</strong>存储区域网络（仅用于存储访问），<strong>CAN</strong>校园网，<strong>LAN</strong>指局域网（家庭、打印店组网），<strong>WLAN</strong>无线局域网（只是不用光缆的局域网），<strong>VLAN</strong>虚拟局域网，<strong>PAN</strong>指个人区域网络（USB、蓝牙等）；以上仅指明范围，与IP无关。</p>
</li>
<li><p><strong>Socket</strong>：IP:端口=套接字socket，服务端端口通常在1024以下，客户端用1025~1624，相互形成客户—服务器通信；其他策略有远程程序套用（RPC）、管道。</p>
</li>
<li><p><strong>IPV6</strong>：也叫做IPng，相比于IPv4具有更多的地址数量、还能提高网络性能（精简了数据包）。共128位=8组x4个十六进制数，<code>/</code>后面跟着前缀长度or掩码n，表示前n位是网络地址，后128-n位为主机号；支持內嵌IPV4。</p>
<p><strong>报头格式</strong>：</p>
<p>4bit表示IP版本+8bit流量分类+20bit流标签</p>
<p>16bit有效载荷的长度+8bit处理选项字段+8bit最大跳数</p>
<p>128bit源IP地址+128bit目标IP地址=40Byte，后面跟扩展报头</p>
</li>
<li><p><strong>Mac地址</strong>：物理地址，一张网卡一个，没有重复的，共48位；在OSI模型的数据链路层。</p>
<p><strong>ARP</strong>：地址解析协议，负责将IP地址转换为MAC地址，用于在物理层面上传输信息；在同一个网段时，通过查表对应MAC地址，否则进行广播查询（一般来说新设备接网后表上就有记录）。在不同网段时，先发送给网关，由网关再广播查询。</p>
</li>
</ul>
<blockquote>
<p>表单叫ARP表，包括动态和静态表项。动态表项会随着时间而删除，通常很短，如果有使用就延长；静态ARP表项可以指定通信时固定的MAC与IP的绑定，防止由动态造成的ARP污染</p>
</blockquote>
<hr>
<h3 id="0x04-HTTP"><a href="#0x04-HTTP" class="headerlink" title="0x04.HTTP"></a>0x04.HTTP</h3><p>HTTP超文本传输协议，基于TCP/IP协议，默认端口80，用于传输网页。服务端接收到信息后与CGI交互，解释处理表单内容，产生处理；</p>
<ul>
<li><p>特点：</p>
<ol>
<li>无连接：每次一个请求。</li>
<li>媒体独立：传任何类型数据（content-type规定主体内容格式）。</li>
<li>无状态：对于客户没有记忆能力（搭配cookie使用以保持登陆状态）。</li>
</ol>
</li>
<li><p>发展：</p>
<p>HTTP/0.9：请求仅包含一个get方法和URL，响应仅含有HTML文档，如果没找到，则返回有关服务器错误代码。</p>
<p>HTTP/1.0：有了现在的完整请求行和部分请求报头，响应有了状态码的返回，可以支持除HTML文档以外的类型。</p>
<p>HTTP/1.1：完善了Http/1.0，请求报头中增加Host，在传送报文上使用pipe技术，连接可以复用。</p>
<p>HTTP/2：基于SPDY协议，是一种二进制协议而非之前的文本协议，多路复用。</p>
<p>HTTP/3：在传输使用QUIC协议，多路复用协议，延迟更低；在http2中使用单个TCP连接传输，而3中的QUIC使用UDP运行多个流，一旦有错误，仅错误的那条进行重新传输。</p>
</li>
<li><p><strong>请求报文</strong>：客户端向服务端首次发送</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求方法+空格+请求URL+空+Http版本---------------------------------------请求行</span><br><span class="line">头部字段名：值--------------------------------请求头部/消息报头</span><br><span class="line">空行</span><br><span class="line">（请求正文）</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法（共8种）</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>向特定资源发送请求</td>
</tr>
<tr>
<td>post</td>
<td>请求处理数据，此时含有请求正文</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>消息报头（可由服务端自定义其他的）</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>客户端能够接收的文件类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>支持的字符集编码</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器可支持的内容压缩编码类型</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
</tr>
<tr>
<td>Authorization</td>
<td>Http授权的证书类型</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>请求响应过程遵循的缓存机制</td>
</tr>
<tr>
<td>Connection</td>
<td>表明是否需要持久连接的</td>
</tr>
<tr>
<td>Cookie</td>
<td>包含在请求URL域名下的所有有关cookie值</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>MIME</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>MIME：媒体类型，是一种用在响应头中的，表示文件的性质与格式；<code>type(图片还是文本)/格式(png,html)</code></p>
</blockquote>
<ul>
<li><strong>响应报文</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http版本+状态码+英文（not found？）-------------------状态行</span><br><span class="line">响应首部------------------------消息报头</span><br><span class="line">空行</span><br><span class="line">主体------------------响应正文</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态码</th>
<th>栗子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx(正在处理)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2xx(成功)</td>
<td>200(ok)、204(no content)</td>
<td>请求成功；服务器正常处理，但就是没返回内容</td>
</tr>
<tr>
<td>3xx(重定向，即需要附加操作)</td>
<td>301、302</td>
<td>请求资源换URL，并返回新家地址；暂时搬走、</td>
</tr>
<tr>
<td>4xx(客户端错误)</td>
<td>400、401、403、404</td>
<td>请求报文有错误；需要身份验证；拒绝；未找到</td>
</tr>
<tr>
<td>5xx(服务端错误)</td>
<td>500、501、503</td>
<td>服务器内部错误；不支持请求功能；超载</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="0x05-Cookie"><a href="#0x05-Cookie" class="headerlink" title="0x05.Cookie"></a>0x05.Cookie</h3><p>Cookie即服务器分发的身份证明。</p>
<ul>
<li><p>过程如下：</p>
<p>客户端发送一个post请求到服务器，将自己的用户名密码都给封装进去——》服务器收到后创建一个session对象，其中有唯一的会话ID——》服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部——》客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部——》服务器返回响应数据</p>
</li>
</ul>
<ul>
<li><p>Cookie的组成：NAME=value；Expires=date；Path=path；Domain=domain_name；Size；Secure；HttpOnly；</p>
<ul>
<li>NAME：cookie的名字；也就是下面要讲的session_ID</li>
</ul>
</li>
</ul>
<ul>
<li>Expires：该cookie的过期时间（登录好几次之后就又得重新登陆就是因为这个）；<ul>
<li>Path：在这里的作用并不是路径，而是说再同一网站之中都可以使用这个cookie。举个栗子：根目录为 / ，当你进入b站的任何界面都会发现右上角依然有你的登录信息；</li>
</ul>
</li>
<li>Domain决定该cookie在那些域是有效的，下面是关于Domain的不同设置</li>
</ul>
<blockquote>
<p>设为一级域名 <code>.baidu.com</code>，则这个域名下的所有二级域名都可以读取该 Cookie；</p>
<p>设为二级域名 <code>image.baidu.com</code>，则该 Cookie 只对设置的域名有效</p>
</blockquote>
<ul>
<li>Size：Cookie文件大小；</li>
<li><p>Secure：Cookie的安全属性，只有true和false两个值，为true时则浏览器只会在HTTPS和SSL等安全协议中传输cookie，而在其他的诸如HTTP中则不会传递；</p>
</li>
<li><p>HttpOnly同上只有true or false两个值当设置为true时，cookie是不允许JS脚本来改变的；</p>
</li>
</ul>
<ul>
<li>Session：会话，这个东西是存在于服务器的内存中，当用户第一次访问网站时，服务器生成一个session对象，并把该对象的唯一的session_ID作为cookie的一部分发送给客户端。自己设置登出时，就是请求结束对话，会指示服务器把相应的session_ID给删除，本地的cookie并不影响。但因为cookie有时间限制，时间过了之后就会被浏览器删除，用户需要再次登录</li>
</ul>
<ul>
<li><p>JWT：Json Web Token，用户第一次登陆后输入用户名和密码给服务器，接下来由服务器生成JWT并发送给客户端，而服务端只保存JWT签名过的密文，在客户端JWT以cookie或其他形式存储，每次请求时都会发送JWT（一般就叫token）。整个体系由header.payload.signature构成。</p>
<p>header表明算法，payload表明数据（不是cookie！），两者首先经过base64编码拼接后，与服务端存储的密码经过header算法之后与signature对照验证</p>
</li>
</ul>
<blockquote>
<p>session存储于服务器，cookie作为数据传输载体将session传递给客户端。token同样产生于服务器但由客户端保管，可以放在cookie中</p>
</blockquote>
<hr>
<h3 id="0x06-HTTPS"><a href="#0x06-HTTPS" class="headerlink" title="0x06.HTTPS"></a>0x06.HTTPS</h3><p>超文本传输安全协议，比HTTP多出了Secure，运行于443端口上。</p>
<p>在HTTP的基础上，经由SSL/TLS协议来进行非对称加密（协议层下面还是TCP），形成客户端、服务端、CA机构三方。TLS前身为SSL，下文所说证书均为TLS证书。下面是一些需要注意的Word：</p>
<ul>
<li><strong>CA</strong>：证书授权中心；有证书就表明CA对该服务器信任。</li>
<li><strong>证书</strong>：包含网址、服务器公钥、所有者信息，还有最重要的数字签名</li>
<li><strong>数字签名</strong>：CA对服务器提交内容，用自己的私钥加密，用以让客户端验证。而CA公钥一般在浏览器中内置</li>
</ul>
<p><strong>服务端与CA</strong>：服务端向CA申请证书，提交各种信息及证明还有钱钱，之后拿到具有数字签名的证书。当客户端请求服务端时，会将该证书发送给客户端。</p>
<p><strong>客户端与服务端</strong>：客户端收到来自服务端的证书后，先结合保存在本地的CA公钥对证书上的信息进行验算，与数字签名对比，如果不对则表明中间被篡改过；无误后，浏览器使用该证书上写的服务端的公钥进行加密并发送，服务端用自己的私钥对该信息解密。</p>
<ul>
<li><p><strong>TLS具体过程</strong>：</p>
<p>由于非对称加密成本较高，故TLS采用，非对称加密来传递对称加密的密钥：</p>
<ol>
<li>Bob打招呼并发送第一随机数</li>
<li>Server接收，生成第二随机数，返回第二随机数、证书等（客户端验证）</li>
<li>Bob接收后，生成第三随机数（预主密钥），并用服务端公钥加密后返回给Server</li>
<li>Server接收到后，用私钥解密，得到预主密钥</li>
<li>双方用三个随机数共同加密生成最终会话密钥</li>
<li>之后进行对称加密进行交流</li>
</ol>
</li>
<li><p><strong>CT</strong>（证书透明度）框架：</p>
<p>解决了对于CA的信任问题。CA对服务端验证后，向区块链上提交CT日志，然后返回一个SCT（证书签署时间戳），将此SCT与证书啥的一同返回给服务端，服务端也会将此信息也返回给客户端；客户端验证服务器、CA、区块链日志，都符合后即可。由于区块链的特性，所以可信度极大地提高。</p>
</li>
</ul>
<hr>
<h3 id="0x07-UDP"><a href="#0x07-UDP" class="headerlink" title="0x07.UDP"></a>0x07.UDP</h3><p>用户数据报协议，位于传输层；多用于应用层的DNS、TFTP（简单文件）、SNMP（简单网络管理）等</p>
<ul>
<li>无连接：客户端只需将数据包送走即可，不用提前与目标机器商量</li>
<li>无拥塞控制：不会探测路是否堵车</li>
<li>不保证可靠交付：不一定送达</li>
<li>面向报文：不拆分不合并，仅加头</li>
<li>首部开销小</li>
</ul>
<p>数据报格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16bit源端口号 + 16bit目的端口号</span><br><span class="line">16位知指明本UDP包长度 + 16bit校验和</span><br><span class="line">数据~~~~</span><br></pre></td></tr></table></figure>
<p>在计算校验和时，先将其全部置0，之后添加一个12Byte的伪首部（伪首部与TCP包的相同，但是协议号为17-UDP），之后按照16bit的倍数进行0填充，再2B一组对其反码进行求和，将和再求反码填入校验和；（伪首部和填充0并不发送）</p>
<blockquote>
<p>原码-常规表示；正数反码=原码、负数反码=原码除符号位外取反；补码=反码+1</p>
</blockquote>
<hr>
<h3 id="0x08-TCP"><a href="#0x08-TCP" class="headerlink" title="0x08.TCP"></a>0x08.TCP</h3><p>建立链接，用于提供端口，来确定两个IP地址中不同进程之间的通信。使用该协议的应用层协议有：HTTP/S、FTP、SMTP、TELNET、SSH等</p>
<p><strong>报文格式</strong>：</p>
<p>TCP报文段=TCP首部20字节+TCP数据；首部通常为20字节，有时具有可选字段+填充（32bit倍数）</p>
<p>源端口+目的端口+seq序号+ack确认序号+数据偏移+保留+标志位+窗口+检验和+紧急指针</p>
<ul>
<li><p>源端口和目的端口：各占2字节，端口范围0-65535</p>
<blockquote>
<p>0-1023公认端口、1024-49151注册端口(有些软件绑定)、其余动态或私有端口；按协议也可以分为TCP、UDP、保留端口</p>
</blockquote>
</li>
<li><p>序号4B：用于说明本报文段第一个字节的序号；达到最大之后再次从0开始</p>
</li>
<li><p>确认序号4B：表明期望收到的下一个数据包中的第一个字节的序号，是本机收到的上一个序号+1；只有ACK标志=1时，确认序号才有效</p>
</li>
<li><p>数据偏移4b：表明头的长度，1bit=4B的偏移，最大154B偏移，也就是TCP头最大只能154B</p>
</li>
<li><p>保留与标志位：各6bit，前者目前均为0，后者详细如下</p>
<blockquote>
<p>URG：=1时表明该报文应尽快，而不需要按次序传送，用来与紧急指针配合使用，即紧急指针指向的字节前面的，不用太在意顺序</p>
<p>ACK：=1时，确认序号字段有效</p>
<p>PSH：=1时，需要接收方将本报文段<strong>尽快</strong>送给应用层</p>
<p>RST：=1时，表明<strong>连接错误</strong>，需要重连；还可以用来拒绝非法报文段</p>
<p>SYN：=1时&amp;&amp;ACK=1时，表明请求建立一个连接；该标志=1的报文段叫做<strong>同步报文段</strong></p>
<p>FIN：=1时，表明发送端完成发送任务</p>
</blockquote>
</li>
<li><p>窗口4B：滑动窗口，用于实现流量控制；在服务端发送报文上可以理解为对客户端的数据报缓冲区大小，在客户端中该值=min(拥塞窗口cwnd，接收端窗口大小)，其中的cwnd会随着网络的拥堵程度改变</p>
</li>
<li><p>检验和4B：发送端检验存储，由就手段进行验证</p>
</li>
<li><p>紧急指针4B：URG=1时该偏移量才有效，通过与序号字段中的值相加再-1=紧急数据的序号</p>
</li>
</ul>
<p><strong>三次握手</strong>：</p>
<ol>
<li>客户端，发送报文标志位SYN=1开启，表明想要连接，并产生一个随机序号A；</li>
<li>服务端返回标志位SYN=1&amp;ACK=1，表明确认连接请求；确认序号=序号A+1，并生成自己的随机序号B；</li>
<li>客户端检查发送过来的确认序号是否=A+1；正确则，将标志位ACK=1，序号=服务端确认号，确认号=B+1，发送给服务端；服务端检查确认序号与ACK标志位，无误连接成功</li>
</ol>
<p><strong>四次挥手</strong>：</p>
<ol>
<li>客户端发送报文标志位FIN+ACK置1，表明发送结束；</li>
<li>服务端收到客户端的FIN，并发送ACK确认收到FIN；</li>
<li>之后再由服务端发送FIN报文段，请求断开连接；</li>
<li>客户端收到服务端的FIN后，发送ACK，服务端收到并断开连接；客户端等待两个最大存活时间后，如果没有回复，则关闭连接</li>
</ol>
<p><strong>拥塞控制</strong>：</p>
<p>开环控制：设计之前敲定不能变、闭环控制：动态反馈（监测+传送+调整）</p>
<p>TCP采用闭环控制，基于滑动窗口，由发送方维护一个cwnd拥塞窗口，真正的发送窗口值wnd=min(cwnd，rwnd)</p>
<p>四种拥塞控制算法：慢开始、拥塞避免、快重传、快恢复</p>
<ul>
<li>慢开始：每收到一个确认，就把拥塞窗口+1，正常的话就是<strong>2的指数级别</strong>增长；当cwnd&gt;SSTH即慢开始门限时执行拥塞避免</li>
<li>拥塞避免：每经过一个RTT，<strong>cwnd+=1</strong>，线性增长。当出现拥塞时即重传定时器超时，<strong>ssthres=max(cwnd/2，2)</strong>，并让cwnd=1开始执行慢开始算法</li>
<li>快重传FR：收到<strong>三个连续重复ACK</strong>（加上第一次正经的共四个相同ACK），发送方就立即进行重传，执行快恢复算法</li>
<li>快恢复：<strong>ssthres=cwnd/2</strong>，之后执行拥塞避免算法</li>
</ul>
<hr>
<h3 id="0x09-Browser"><a href="#0x09-Browser" class="headerlink" title="0x09.Browser"></a>0x09.Browser</h3><p>目前的浏览器基本均为多进程浏览器，即将许多功能单独分离出来，包括但不限于：浏览器主进程、插件进程、渲染进程、GPU进程、网络进程等，各个进程之间采用IPC进行通信。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47407398">图解浏览器的基本工作原理 - 知乎 (zhihu.com)</a></p>
<p><strong>导航过程</strong>：</p>
<ol>
<li><p>处理用户输入：浏览器进程中的UI线程负责判断其内容是地址还是其他东西，并决定是否发起网络请求</p>
</li>
<li><p>页面资源请求：浏览器主进程通过IPC把URL请求发送给网络进程，发起真正的URL请求</p>
<blockquote>
<p>先查找本地缓存资源，没有的话就先查找Host文件，没有目标再发送DNS请求等其他过程</p>
</blockquote>
</li>
<li><p>响应数据处理：网络线程根据接收到的<code>Content-Type</code>来判断返回值类型，并进行安全检查之后再根据此项发送给渲染进程等其他进程</p>
</li>
<li><p>准备渲染过程：绝大多数返回内容都是页面，交给渲染进程处理</p>
</li>
<li><p>页面处理：渲染引擎与JS引擎共同处理页面并将结果呈现</p>
</li>
</ol>
<p><strong>搜索引擎</strong>：</p>
<ul>
<li><p>搜索引擎结构：搜索器（蜘蛛）—分析器（NLP处理）—索引器（建立索引）—检索器（查找文档）—用户接口</p>
<blockquote>
<p>爬虫抓取策略：DFS、BFS、最佳优先搜索（贪心取优先相关度高）、反向链接搜索（由其他网站指向）、OPIC策略、大站优先策略等</p>
</blockquote>
</li>
<li><p>工作流程：爬行抓取—建立索引（常用倒排索引）—搜索词处理—排序</p>
</li>
<li><p>常见的类别：元搜索引擎（将搜索请求发送给其他搜索引擎，之后再综合排序；dogpile、All4one、webcrawler）、全文搜索引擎（baidu、google等在web内容及标题中搜索）、目录搜索引擎（逐级向下选择）、垂直搜索引擎（专注特定领域）</p>
</li>
</ul>
<p><strong>渲染引擎</strong>：用于获取网页的内容（HTML等），整理排版（CSS），然后显示；目前的浏览器引擎主要指的就是渲染引擎，而JS引擎通常作为渲染引擎的一部分，下面是一些常见的渲染引擎：</p>
<ul>
<li>Geocko：火狐浏览器；开源；</li>
<li>Trident：IE浏览器、世界之窗；</li>
<li>Webkit：Safari浏览器；基于KHTML研发，开源；</li>
<li>Blink：google，edge，Opera浏览器；Google基于webkit研发；开源；</li>
</ul>
<p><strong>渲染过程</strong>：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903877314101255">10分钟看懂浏览器的渲染过程及优化 - 掘金 (juejin.cn)</a></p>
<ol>
<li><p>解析HTML，生成HTML DOM树：</p>
<p>编码转换——标签令牌化——生成节点对象——节点对象构建成树形结构</p>
</li>
<li><p>碰到CSS，生成CSSOM树：同上</p>
<blockquote>
<p>碰到JS代码时会暂停进行，转交给JS引擎解析加载代码，有可能会改变DOM树结构</p>
</blockquote>
</li>
<li><p>合并生成Render tree，即渲染树：将前面两者结合</p>
</li>
<li><p>Layout，遍历渲染树，计算盒子模型详细信息，即每个节点在浏览器窗口的确切位置与大小</p>
<blockquote>
<p>盒子模型：Content（内容）—&gt;Padding（内边距）—&gt;Border（边框）—&gt;Margin（外边框）</p>
<p><img src="https://s2.loli.net/2024/08/08/u41RTcFYyLWwAIK.png" alt="box.png"></p>
</blockquote>
</li>
<li><p>Paint，绘制页面，绘制时间与CSS复杂度成正比</p>
</li>
</ol>
<p>渲染引擎通常以一个进程的形式存在，其下面还包括许多线程，其中的常驻线程有：GUI渲染线程、JS引擎线程、事件触发线程、定时器线程、HTTP请求线程等</p>
<p><strong>JS引擎</strong>：解析JS（翻译为机器语言）来实现网页的动态效果，可以理解为浏览器中的虚拟机</p>
<ul>
<li>SpiderMonkey：鼻祖；后更新为TraceMonkey、JaegerMonkey</li>
<li>Chakra：微软开发，用于IE；</li>
<li>JavaScriptCore：用于webkit，Apple开发；</li>
<li>V8：google基于C++开发，Node.js基于V8引擎开发；</li>
<li>流程：JS代码解析为抽象语法树（ATS）——基于AST解释器将其转换为虚拟机字节码——优化编译器将部分函数优化为本地机器指令执行</li>
</ul>
<p><strong>安全机制</strong>：<a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/303551.html">WEB安全-浏览器的几种防护策略 - FreeBuf网络安全行业门户</a></p>
<ul>
<li><p>同源策略：防止A站的JS修改B站的页面，对于js来说只有同一IP、同一端口、同一协议才能够算作是同源。</p>
<p>不受限制的内容：页面中的链接、重定向、表单提交、跨域资源的引入</p>
<p>进行跨域：<strong>JSONP</strong>（服务端有专门的JSONP请求接口，可以接受JSON格式的参数，并返回该参数的执行结果）、<strong>CORS</strong>（允许浏览器向跨源服务器发出XMLHttpRequest请求）、<strong>Nginx</strong>反向代理可以跨域访问</p>
</li>
<li><p>内容安全策略CSP：开发者在规定浏览器对于危险资源不能加载执行，即有漏洞，但是在该客户端上不被允许执行</p>
</li>
<li><p>沙箱机制：至少会有两个进程出现，一个代理进程一个目标进程，前者与后者之间建立IPC通道并接受各种请求，待病毒特性充分暴露之后会进行回滚机制，将病毒的痕迹和动作抹去</p>
</li>
<li><p>恶意网站拦截：拦截的大多为挂马网站、诈骗钓鱼网站等。目前大多的浏览器采用的大多基于黑名单制度，该项黑名单定期会从服务器获取。<a target="_blank" rel="noopener" href="https://phishtank.org/index.php">PhishTank | Join the fight against phishing</a></p>
<blockquote>
<p>EV SSL证书，拥有该证书的网站会在浏览器地址栏中显示为绿色，拥有特别标注</p>
</blockquote>
</li>
</ul>
<h4 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h4><p>全称是WebAssembly，即在web上的汇编，准确来说wasm就是一套专门用在浏览器上的汇编语言，目的当然就是加快运行速率咯。</p>
<p>我们知道python和js都是JIT（just in time）编译方式的，也就是在运行时再将代码转换为机器码运行，因此对比于C/C++等AOT（ahead of time）这种提前写好机器码的语言会更慢一点。</p>
<p>为了加快浏览器上js的执行速度，因此wasm这种汇编就出现了。</p>
<p>可以C/C++/Go等编译型语言来生成相关wasm文件以此代替js文件。浏览器引擎在收到wasm文件后可以直接对应查表转换为引擎对应字节码加以执行。</p>
<p>一般都是将js和wasm配合使用，用js编写较为复杂的函数功能来供给wasm调用</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://evian-zhang.github.io/wasm-tutorial/">引言 - WASM 汇编入门教程 (evian-zhang.github.io)</a></p>
</blockquote>
<hr>
<h3 id="0x0A-CDN"><a href="#0x0A-CDN" class="headerlink" title="0x0A.CDN"></a>0x0A.CDN</h3><p>内容分发网络，是一种网络模型。通过设置下属缓冲服务器，也叫边缘服务器，即接近用户的服务器（区别于镜像服务器，只有部分内容，有额外操作），来缓解用户对主服务器的流量请求；</p>
<ul>
<li><p><strong>过程</strong>：源服务器通过HTTP包中的<code>cache-control</code>字段来决定内容的缓存形式（是否保存，多长时间等）。对于静态内容来说：初始时源服务器将内容push给CDN服务器，之后用户向CDN请求，如果CDN中没有用户索要内容，则先向源服务器pull内容，之后再分发；而对于动态内容来说，只有一小部分能够设置成由CDN提供</p>
</li>
<li><p><strong>防御DDOS</strong>：为防止某一个服务器流量过高时，会将其部分流量转移到其他服务器上（负载均衡）。在这之中有的采用任播技术，将所有的CDN服务器都共享一个IP，这样其中一个出问题了，就会请求地理上最近的其他CDN，需要专门的负载均衡系统</p>
</li>
<li><strong>用处</strong>：CDN会对包进行处理，去除不必要内容，来减少包大小，加速用户；减少传输距离，即降低了网络带宽费用，降低服务器方费用</li>
</ul>
<p>CDN服务器安置原则：</p>
<ol>
<li>在ISP（互联网服务提供商）处架设CDN集群</li>
<li>在关键的IXP（因特网交换点）先放置CDN，之后邀请ISP入驻</li>
<li>根据地理位置和地区流量检测选择布置</li>
</ol>
<hr>
<h3 id="0x0B-P2P"><a href="#0x0B-P2P" class="headerlink" title="0x0B.P2P"></a>0x0B.P2P</h3><p>peer to peer，即点对点技术，又叫做互联网络对等技术，与此对应的有C/S模式（也有所谓的B/S模式）。每个结点即能充当服务器又能充当客户，基本不存在带宽问题；为实现跨内网交流，要将内网IP更换为公网IP（NAT），从而到达另一个内网；</p>
<p><strong>NAT</strong>：网络地址转换技术，是一种将数据包中IP地址更换为其他IP地址的功能，常由路由器或防火墙实现；目前代指动态NAT（即NAPT），不仅会改IP地址，还能改变数据报的TCP/UDP端口</p>
<p>术语：内部Tuple、外部Tuple、目标Tuple、打洞hole punch；Tuple=IP+Port</p>
<ol>
<li>完全锥形NAT：传统NAT，内部Tuple单独占一个外部Tuple</li>
<li>地址限制型锥型NAT：在锥型基础上，只有之前内部主机联系过的IP才能借助之前的外部Tuple联系，只能发送UDP报文</li>
<li>端口限制圆锥型NAT：在地址限制型基础上，外部机器B想要与A联系，就要用A之前联系B时的目标Tuple（Ip+端口）向外部Tuple通信</li>
<li>对称型NAT：内外交流双方构成的【内部Tuple-目标Tuple】对，单独占用NAT后的一个外部Tuple；而外部IP也只能通过该固定的<strong>外部Tuple</strong>来访问内部；即不仅限制了外部的IP和端口，也限制了内部的IP和端口</li>
</ol>
<p><strong>NAT穿透/打洞</strong>：有了NAT技术之后，任意两个在内网的客户端想要通信，就要建立隧道/打洞</p>
<ul>
<li>1-1、1-2、1-3、1-4打洞：中间服务器C把A和B的外部Turple相互告诉，任意外部都可联系内部</li>
<li>2-2、2-3、2-4、3-3打洞：先同上，由于IP地址受限，因此需要A直接先向B发送连接（A开了一个针对B的口），之后A通过C向B发送邀请（B此时是没有与A连接的，因为B之前没有连过A），让B也直接向A发送邀请（B开了一个针对A的口，两端成功连接）；根据类型指定IP或Port</li>
<li>3-4、4-4常规方法无法打洞</li>
</ul>
<blockquote>
<p>更多细节参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904098572009485">NAT基本原理及穿透详解(打洞)</a></p>
</blockquote>
<p><strong>BitTorrent</strong>：</p>
<p>一种用于文件分发的流行P2P协议，会将文件划分为大小相等的n块</p>
<ul>
<li><p><strong>洪流(torrent）</strong>：是参与一个特定文件分发的集合，每个个体叫对等方，以等长文件块（256KB）为单位</p>
</li>
<li><p><strong>追踪器（tracker）</strong>：划分洪流，登记新来的对等方，将对等方的IP发送给新来的（杂p2p，并不是非常的对等，因为tracker也需要服务器）</p>
</li>
<li><p><strong>种子</strong>：制作<code>.torrent</code>文件，其中包含Tracker服务器地址、文件大小、文件名、块大小等</p>
<p>在拿到之后，会先连接Tracker服务器，之后验证缺少信息并交换信息</p>
</li>
<li><p><strong>磁力链接</strong>：格式<code>magnet:?xt=urn:bith:~~~~</code>后面跟一串40位16进制的数字；<code>magnet</code>协议名，<code>xt</code>表示资源定位点，<code>urn:bith</code>表示Hash名，采用URN来定位资源，Hash值即为资源的唯一命名</p>
</li>
<li><p><strong>最稀缺优先</strong>：具有该洪流中的块列表，资源数最少的块，最先互传；</p>
</li>
<li><p><strong>一报还一报</strong>：向我传送速率最高的对等方获得我方的优先权，规定n个疏通，剩余的阻塞</p>
</li>
</ul>
<p>P2P应用：分布式计算（区块链）、文件共享、流媒体、IP层语音通信（VoIP）、游戏平台</p>
<hr>
<h3 id="0x0C-VPN"><a href="#0x0C-VPN" class="headerlink" title="0x0C.VPN"></a>0x0C.VPN</h3><p>虚拟专用网络VPN，旨在提供一种安全连接到网络服务器的方式。其核心是隧道技术，使用该技术的数据可以是不同协议的数据帧或包，因为隧道协议会将其重新封装后并发出（该过程也叫做挖隧道）。</p>
<p>从两端类型来说分为：</p>
<ul>
<li><p>站点对站点VPN：两端的地点相对固定；</p>
</li>
<li><p>客户端对站点VPN/远程登陆VPN：全隧道模式（所有数据都通过）+半隧道模式（部分数据通过）；</p>
</li>
</ul>
<p>加密方式：AES256+3DES；保护完整性：Hash；认证：PSK+RSA</p>
<p>根据使用的协议：目前较多的IPsec VPN和SSL/TLS VPN，还有Socks5、PPTP、L2F、L2TP协议等</p>
<ul>
<li><p><strong>IPsec VPN</strong>：</p>
<p>IPsec协议位于网络层，多用于站点对站点传输；其VPN有两个主要模式：传输模式（也叫半隧道模式）与隧道模式，在传输模式种并非所有的数据都会经过加密，而后者则会全部加密甚至是IP头。</p>
<p>需要网络中设备安装相应软件并经过身份验证、使得网络管理可见性更广（更底层）</p>
</li>
<li><p><strong>SSL VPN</strong>：</p>
<p>SSL/TLS位于应用层与传输层之间，多用于客户端对站点传输；其VPN模式：门户模式（特定网页或Web应用）和隧道模式（甚至可以访问非Web应用）；</p>
<p>SSL协议广泛应用于浏览器中（多亏HTTPS）因此部署成本较低，只需开放443端口、可以部署在内网中的任一个节点上，移动性强、缺少身份验证可能有安全问题、管理繁琐，需要管理员设置模式</p>
</li>
</ul>
<p><strong>Tor</strong>：洋葱网络/路由，一种“代理节点快速动态变化的加密三重代理”，相当于多重VPN；默认情况下Tor通过3个中继器进行跳转：Guard中继器、Middle中继器、Exit中继器。</p>
<ul>
<li><p><strong>中继器</strong>：当Alice想要访问Bob时，会在Tor服务器中选择上述三种中继器各一个，而且会定时重组选择新的中继器。为了防止所有的Tor中继器被阻塞，每次只会给用户一小部分的中继器信息。</p>
</li>
<li><p><strong>加密过程</strong>：Alice与Guard中继器借助Curve25519椭圆曲线生成一个对称密钥key1，之后Alice使用Guard中继器作为加密跳板来与Middle中继器继续生成key2，以此类推。</p>
<p>最后Alice有了3把key，每当Alice想要访问Bob时，会依次使用key1、key2、key3对数据包进行加密，每经过一个中继器就解一次密，也就是Exit中继器能看到最终传输内容</p>
</li>
</ul>
<hr>
<h3 id="0x0D-FireWall"><a href="#0x0D-FireWall" class="headerlink" title="0x0D.FireWall"></a>0x0D.FireWall</h3><p>Firewall，作用：限制外来用户、限定用户访问特定站点。可以在单独的硬件上，也可以作为软件；作为硬件一般叫做网络防火墙，需要针对广泛的连接进行配置，而后者又叫软件/主机防火墙，可以针对单独的机器设备进行定制。</p>
<ul>
<li><p>两种分段模型：</p>
<ul>
<li><p>外部网络—屏蔽主机防火墙—内部网络；</p>
</li>
<li><p>外部网络—屏蔽路由器—边界网络=DMZ隔离区—屏蔽路由器—内部网络</p>
</li>
</ul>
</li>
<li><p>过滤标准：源IP、目标IP、内容、协议</p>
</li>
<li><p><strong>工作模式</strong>：</p>
<ul>
<li>路由/网关模式：将防火墙当作路由器使用，内外接口处于不同的子网之中，需要更改网络拓扑</li>
<li>透明模式/桥模式：将防火墙当作交换机，类似于路由器中的仅接内部网，可以互相通信，无IP</li>
<li>混合模式：防火墙1网关模式，防火墙2桥模式，之后连接防火墙，防火墙1启动VRRP（虚拟路由器冗余协议）进行备份</li>
</ul>
</li>
<li><p><strong>FireWall类型</strong>：</p>
<ul>
<li>静态包过滤/无状态检测防火墙：运行于OSI的网络层；类似于HTTP的无状态，每一个数据包都需要检查，因此对手动创建的接入控制列表要求较高</li>
<li>电路级网关防火墙：运行在会话层；连接一段时间后仍无异样，就停止监视</li>
<li>动态包过滤/状态检测防火墙：作用域传输层及以上；能够监控持续的连接</li>
<li>代理防火墙/应用层防火墙：运行在应用层；相当于有代理作用的防火墙</li>
<li>混合型：不多bb</li>
</ul>
</li>
</ul>
<p><strong>WAF</strong>：Web应用防火墙，过滤监视HTTP通信来保护Web应用程序；应用层防御；负安全模型（黑名单）/肯安全模型（白名单）；预防SQL注入、XSS、文件上传、第七层Dos攻击等</p>
<p>基于网络的WAF—基于主机的WAF：专门的硬件—作为软件集成，消耗本地资源</p>
<p>基于云的WAF：云服务商将对去到服务器的流量进行检测</p>
<h4 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h4><p>入侵检测系统；对攻击、恶意流量、木马进行检测并发出警告；旁路部署在需要关注的链路上；</p>
<ul>
<li><p><strong>CIDF体系</strong>：为IDS通用模型，包括事件产生器+事件数据库+事件分析器+响应单元</p>
<ol>
<li><p>事件产生器搜集信息数据，并将其转换为GIDO（通用入侵检测对象）标准格式转交给其他组件</p>
</li>
<li><p>事件分析器：接受GIDO，并判断是否构成威胁</p>
</li>
<li><p>事件数据库：存储各种事件</p>
</li>
<li><p>响应单元：根据GIDO作出反应，终止进程、切断链接、报警等</p>
</li>
</ol>
</li>
<li><strong>根据数据源的分类</strong>：<ol>
<li>HIDS：基于主机，数据来源有系统/应用日志、审计日志、端口调用情况等</li>
<li>NIDS：基于网络，对网络中的数据包进行监测分析</li>
<li>DIDS：分布式，高层次IDS接受低层次的IDS信息</li>
</ol>
</li>
<li><strong>根据检测方法的分类</strong>：<ol>
<li>误用检测系统：根据已有库中的攻击模式，对外来入侵判断类型，进行特征模式匹配或借助专家系统判断；误报率低、要求不高、只针对已知攻击</li>
<li>异常检测系统：设定标准与阈值，当超过该标准时就警报；误报率不易控制、大量信息特征采集</li>
<li>混合检测系统：不多bb</li>
</ol>
</li>
<li>根据响应方式分类：实时监测、非实时检测</li>
<li><strong>误用检测分析方法</strong>：<ol>
<li>模式匹配：依赖于模式库，模式库中存储入侵特征</li>
<li>专辑系统：专家知识库，形成IF-THEN规则</li>
<li>状态转换：状态转换图，将入侵过程看作一个行为序列进行分析</li>
<li>基于信誉检测：检测IP、DNS等是否上过黑名单</li>
</ol>
</li>
<li><strong>异常检测方法</strong>：贝叶斯统计、机器学习、神经网络</li>
</ul>
<blockquote>
<p>HIDS基于主机的入侵检测系统，特征检测，部署于内网服务器中；NIDS基于网络入侵检测系统，异常检测，部署于内网节点中</p>
</blockquote>
<p><strong>IPS</strong>：入侵防御系统，区别于IDS，在检测到威胁时，能够自动阻止攻击并采取行动。由于需要流量经过因此需要串行部署。检测方法与IDS相似，这里不多冗余</p>
<p>根据安装的宿主分为：网络入侵防御系统NIPS、主机入侵防御系统HIPS，前者检测分析流量，后者监测文件进程</p>
<ul>
<li>核心组件如下：<ul>
<li>签名库：存放已知攻击特征</li>
<li>异常检测引擎：检测未知攻击和异常行为</li>
<li>阻止引擎：根据检测到的类型及威胁等级来才需相应的措施</li>
<li>管理控制台：配置管理IPS</li>
<li>日志报告系统：记录IPS活动，生成报告并分析数据</li>
</ul>
</li>
</ul>
<p><strong>蜜罐</strong>：模拟若干个容易受攻击的主机或服务吸引攻击者，用于捕获病毒、恶意代码样本等，在攻防对抗中也能够有效地浪费敌方时间。</p>
<p>交互程度：低交互（系统及服务的全模拟，但最安全）、中交互（最模拟OS）、高交互（有真实的OS）</p>
<p>技术分类：牺牲型（提供真实的目标，但较为危险）、外观型（模拟）、测量型（真实、难以绕过、不易被当做跳板）</p>
<blockquote>
<p><strong>蜜网</strong>是由多个蜜罐+防火墙+IDS+监控报警系统等组成的体系结构；<strong>蜜标</strong>是一种特殊的蜜罐诱饵，它不是任何的主机节点，而是一种带标记的数字实体；<strong>蜜场</strong>是通过代理的方式扩展诱饵节点部署范围的蜜罐系统形态</p>
</blockquote>
<p>蜜罐系统主要包括：数据捕获（监控病毒等的行为）、交互仿真（模拟与攻击者的交互）、安全防护（防止蜜罐被破坏）三部分。又可以划分为：诱饵层（散布诱饵信息-面包屑）、探针层（监测恶意访问将其定向到蜜罐）、蜜罐层（仿真系统，并采集信息）、分析层（分析信息，生成威胁情报）</p>
<h4 id="BH"><a href="#BH" class="headerlink" title="BH"></a>BH</h4><p>堡垒机（BastionHost），也叫做运维审计系统，是一台具备强大防御功能和安全审计功能的服务器，说人话就是控制账户及权限，并记录干了什么的东西。</p>
<ul>
<li><strong>核心功能/理念4A</strong>：认证Authen、账号Account、授权Authorize、审计Audit</li>
<li><strong>目标5W</strong>：What、Which、Where、Who、When即谁在什么时候，在哪个位置，能够干什么，并且它干了什么</li>
<li><strong>模块</strong>：<ol>
<li>运维平台：RDP/VNC运维；SSH/Telnet运维；SFTP/FTP运维；数据库运维；Web系统运维；远程应用运维；</li>
<li>管理平台：三权分立；身份鉴别；主机管理；密码托管；运维监控；电子工单</li>
<li>自动化平台：自动改密；自动运维；自动收集；自动授权；自动备份；自动告警</li>
<li>控制平台：IP防火墙；命令防火墙；访问控制；传输控制；会话阻断；运维审批</li>
<li>审计平台：命令记录；文字记录；SQL记录；文件保存；全文检索；审计报表</li>
</ol>
</li>
<li><strong>身份认证方式</strong>：本地认证（直接账密）、远程认证（远程账密）、双因子认证（验证码）、第三方认证（其他绑定的账密）</li>
<li><strong>运维方式</strong>：B/S（借浏览器部署控制）、C/S（客户端）、H5（页面登录控制）、网关</li>
<li><strong>部署方式</strong>：单机（旁挂在交换机旁）、HA高可靠部署（比前者多一个备份，且共用一个IP）、异地同步部署（多地多台）、集群部署（抽两个堡垒机当总的，一主一备）</li>
</ul>
<hr>
<h3 id="0x0E-Network-of-VM"><a href="#0x0E-Network-of-VM" class="headerlink" title="0x0E.Network of VM"></a>0x0E.Network of VM</h3><ul>
<li><p><strong>NAT</strong>（默认）：内部设置分配私有地址，外网无法访问；在每个虚拟机中虚拟机软件会创建一个默认网关（IP固定），之后虚拟机上网流量必定经过本网关，再到宿主机，因此各个虚拟机之间无法交流；</p>
<p>宿主相对于虚拟机来说是外网，虚拟机可以访问宿主，但不能反过来</p>
</li>
<li><p><strong>NAT网络/模式</strong>：虚拟机之间可以相互连接，相较于NAT来说，有一个虚拟网关、DHCP、交换机将各个虚拟机存放在同一个网络之中，可以访问互联网；搭建靶场！！！</p>
</li>
<li><p><strong>桥接</strong>：虚拟机与宿主机平级，会占用多个宿主网关的分配地址，之间可以互ping</p>
</li>
<li><p><strong>内部网络</strong>：虚拟机可以互通，但是无法与宿主交流，相当于虚拟机们自己在一个独立的网络中；如果要互ping，需要提前配置网络</p>
</li>
<li><p><strong>仅主机模式</strong>：相较于内部网络，会自动分配IP地址（有DHCP），而且可以与宿主互ping，但是不能上网</p>
</li>
</ul>
<hr>
<h3 id="0x0F-MIMT-amp-DOS"><a href="#0x0F-MIMT-amp-DOS" class="headerlink" title="0x0F.MIMT &amp; DOS"></a>0x0F.MIMT &amp; DOS</h3><h4 id="MIMT"><a href="#MIMT" class="headerlink" title="MIMT"></a>MIMT</h4><p>中间人攻击，即在两台正常通信的计算机中间塞入攻击者这个”中介”，包括但不限于DNS欺骗、ARP污染等。大多都用于监听，不会造成真正意义上损伤</p>
<ul>
<li>ARP污染/欺骗：</li>
</ul>
<p>每一台安装了TCP/IP协议的主机都有ARP缓存表，包含动态的和静态的，前者有时限，后者没有，需要注意，网关和终端设备基本都会有该缓存表，初始化时广播查找；</p>
<p>ARP欺骗原理：接受新条目时，并不会区别真假，而是将已有的IP更换为新的MAC地址，攻击者借此给目标和目标所在网关发送两份假信息，实现中间人攻击；将受害者的目标IP转移到攻击者特定的MAC地址上。工具：Cain、Ettercap、NetFuke。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arp -a	//查看缓存表</span><br><span class="line">	-s + IP MAC	//改为静态</span><br><span class="line">	-d (+ IP)	//删除全部或某一条</span><br></pre></td></tr></table></figure>
<p>防御措施：进行静态绑定、使用ARP防火墙</p>
<ul>
<li>DNS欺骗：攻击者冒充域名服务器，受害者所有上网过程（除非直接搞IP）均经过攻击者的审查</li>
<li>SSL劫持：当浏览器网站需要重定向时，由于攻击者在网页代码中插入了挂马网站的链接，导致最终用户进入到该网站</li>
<li>电子邮件劫持：如果攻击者能够访问受信任机构的邮箱，或电子邮件服务器，就可以截获客户的电子邮件，甚至以机构的身份发送钓鱼邮件</li>
<li>IP欺骗、Wi-Fi欺骗、HTTPS欺骗</li>
</ul>
<hr>
<h4 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h4><p>又叫拒绝服务攻击，旨在使目标计算机无法处理正常流量。多基于物联网设备loT，形成DDOS（分布式Dos，能够很好的隐藏自己）；</p>
<p>主要手段有如下：</p>
<ul>
<li>Ping of Death：利用ICMP协议，向目标端口发送大量的大尺寸ICMP包，由于尺寸过大导致目标的缓冲区溢出，从而使系统崩溃或挂起<code>ping -c 1 -s 65535 IP</code>。类似的还有IGMP Flood</li>
<li>UDP Flood：伪造与目标之间的UDP通信，回复地址指向开着echo服务的服务器，则充满足够多数据流。</li>
<li>SYN Flood：半连接状态的TCP连接，填满TCP的请求队列。Land攻击（在此基础上，构造该包的源地址和目的地址均为目标靶机IP）</li>
<li>Smurf攻击：将ICMP应答数据包中的回复地址设置为受害网络的广播地址，让所有主机对此回应，进行消息淹没。Fraggle攻击（在此基础上，采用UDP协议发送伪造消息）</li>
</ul>
<p>根据攻击方式有以下分类</p>
<ul>
<li>弱点攻击/资源层攻击：以适当顺序发送一定数量的定制报文，攻击目标主机的程序/OS</li>
<li>带宽泛洪/容量耗尽：发送大量无用分组</li>
<li>连接泛洪/协议攻击：在攻击目标上创建大量全开/半开的TCP连接（针对协议）</li>
<li>针对中间件或者系统的攻击</li>
</ul>
<p>也可以根据网络层次进行分类：</p>
<ul>
<li><p>网络层：主要消耗网络带宽资源，常见ICMP洪水攻击、ARP洪水攻击、IP分片攻击</p>
</li>
<li><p>传输层：主要使目标服务器过载，常见SYN洪水攻击、ACK洪水攻击、UDP流量攻击</p>
</li>
<li><p>应用层：主要使用户无法正常使用，常见DNS解析攻击、HTTP GET/POST攻击、CC攻击</p>
<blockquote>
<p>CC：挑战黑洞，就是攻击者借助代理不停发送大量数据包给服务器造成资源耗尽</p>
</blockquote>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/" title="数据库与云"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库与云</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/27/x86%E6%B1%87%E7%BC%96/" title="x86汇编"><img class="cover" src="https://s2.loli.net/2024/08/08/lJhAQOvR6n5GtjE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">x86汇编</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/web.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zy0t1</div><div class="author-info__description">中二次元晚期</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zy0t1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zy0t1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wy1078041755@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62036500" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-URL"><span class="toc-number">1.</span> <span class="toc-text">0x01.URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-DNS"><span class="toc-number">2.</span> <span class="toc-text">0x02.DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-IP"><span class="toc-number">3.</span> <span class="toc-text">0x03.IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-HTTP"><span class="toc-number">4.</span> <span class="toc-text">0x04.HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-Cookie"><span class="toc-number">5.</span> <span class="toc-text">0x05.Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-HTTPS"><span class="toc-number">6.</span> <span class="toc-text">0x06.HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-UDP"><span class="toc-number">7.</span> <span class="toc-text">0x07.UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-TCP"><span class="toc-number">8.</span> <span class="toc-text">0x08.TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-Browser"><span class="toc-number">9.</span> <span class="toc-text">0x09.Browser</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WASM"><span class="toc-number">9.1.</span> <span class="toc-text">WASM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0A-CDN"><span class="toc-number">10.</span> <span class="toc-text">0x0A.CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0B-P2P"><span class="toc-number">11.</span> <span class="toc-text">0x0B.P2P</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0C-VPN"><span class="toc-number">12.</span> <span class="toc-text">0x0C.VPN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0D-FireWall"><span class="toc-number">13.</span> <span class="toc-text">0x0D.FireWall</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IDS"><span class="toc-number">13.1.</span> <span class="toc-text">IDS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BH"><span class="toc-number">13.2.</span> <span class="toc-text">BH</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0E-Network-of-VM"><span class="toc-number">14.</span> <span class="toc-text">0x0E.Network of VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x0F-MIMT-amp-DOS"><span class="toc-number">15.</span> <span class="toc-text">0x0F.MIMT &amp; DOS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MIMT"><span class="toc-number">15.1.</span> <span class="toc-text">MIMT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOS"><span class="toc-number">15.2.</span> <span class="toc-text">DOS</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Zy0t1</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>